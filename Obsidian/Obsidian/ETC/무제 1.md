



오케이, 의사(Repair Bot)와 경찰(Scanner Droid) 역할을 추가하고 상세 게임 결과 화면 기능을 포함하여 전체 코드를 재구성하겠습니다. 파일 구조와 함께 각 파일의 전체 코드를 제공하고, 마지막에 환경 설정 및 구동 방법을 안내해 드릴게요.

**전체 폴더 구조**

```
ai-mafia-game/
├── backend/
│   ├── .env                 # 환경 변수 파일 (Gemini API 키 등)
│   ├── main.py              # FastAPI 서버 메인 코드
│   └── requirements.txt     # Python 의존성 목록
└── client/
    ├── node_modules/        # (npm install 로 생성됨)
    ├── public/
    │   └── index.html       # 기본 HTML 템플릿
    ├── src/
    │   ├── App.tsx            # 메인 애플리케이션 컴포넌트, 라우팅
    │   ├── components/        # UI 컴포넌트
    │   │   ├── ActionBar.tsx
    │   │   ├── ChatWindow.tsx
    │   │   ├── LoadingSpinner.tsx
    │   │   ├── Lobby.tsx
    │   │   ├── Modal.tsx
    │   │   ├── PlayerList.tsx
    │   │   ├── Room.tsx
    │   │   └── StatusDisplay.tsx
    │   ├── hooks/             # 커스텀 훅
    │   │   └── useWebSocket.ts
    │   ├── stores/            # 상태 관리 (Zustand)
    │   │   └── useGameStore.ts
    │   ├── types/             # TypeScript 타입 정의
    │   │   └── game.ts
    │   ├── index.css          # Tailwind CSS 및 전역 스타일
    │   └── index.tsx          # React 앱 진입점
    ├── .env                 # 환경 변수 파일 (API/WS 주소 - 선택적)
    ├── package.json         # Node.js 프로젝트 설정 및 의존성
    ├── postcss.config.js    # PostCSS 설정
    ├── tailwind.config.js   # Tailwind CSS 설정
    └── tsconfig.json        # TypeScript 설정
```

---

**1. 백엔드 (Python - FastAPI)**

*   **`backend/requirements.txt`**

```txt
fastapi
uvicorn[standard]
websockets
python-dotenv
google-generativeai
pydantic
# 데이터베이스 사용 시 (선택적):
# tinydb
```

*   **`backend/.env`** (YOUR_API_KEY_HERE 부분을 실제 키로 변경)

```
GEMINI_API_KEY=YOUR_API_KEY_HERE
```

*   **`backend/main.py`**

```python
import os
import asyncio
import json
import random
import uuid
from collections import defaultdict, Counter
from typing import Dict, List, Optional, Tuple, Any

import google.generativeai as genai
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Query, Path, Body
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

load_dotenv()

# --- Gemini API 설정 ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    print("경고: GEMINI_API_KEY 환경 변수가 설정되지 않았습니다. AI 기능이 작동하지 않습니다.")
    gemini_model = None
else:
    genai.configure(api_key=GEMINI_API_KEY)
    # 모델 설정 (비용 효율적인 모델 사용)
    try:
        gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')
        print("Gemini 모델 로드 성공.")
    except Exception as e:
        print(f"Gemini 모델 로드 실패: {e}. AI 기능이 작동하지 않을 수 있습니다.")
        gemini_model = None


# --- 데이터 모델 ---
class Player(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    username: str
    ws: Optional[WebSocket] = None
    role: Optional[str] = None # 'Human', 'AI Assassin Robot', 'Scanner Droid', 'Repair Bot'
    is_alive: bool = True
    is_ai: bool = False
    mimic_target_id: Optional[str] = None # AI가 흉내낼 대상
    voted_for: Optional[str] = None # 낮 투표 대상 플레이어 ID
    night_action_target: Optional[str] = None # 밤 능력 사용 대상 ID
    last_scan_result: Optional[Dict[str, Any]] = None # 스캐너 드로이드의 마지막 스캔 결과

    class Config:
        arbitrary_types_allowed = True

class Room(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    max_players: int
    password: Optional[str] = None
    players: Dict[str, Player] = Field(default_factory=dict) # {player_id: Player}
    host_id: Optional[str] = None
    status: str = 'waiting' # waiting, playing, finished
    phase: str = 'day' # day, night, voting, results
    day_number: int = 0
    # 밤 행동 결과 추적
    ai_target_id: Optional[str] = None # AI가 밤에 지목한 대상 ID
    protected_player_id: Optional[str] = None # 리페어 봇이 보호한 대상 ID
    scan_request_id: Optional[str] = None # 스캐너 드로이드가 스캔 요청한 ID
    # 투표 및 채팅 기록
    votes: Dict[str, str] = Field(default_factory=dict) # {voter_id: target_id} - 낮 투표 결과 저장용 (실제 투표는 Player.voted_for 사용)
    chat_history: List[Dict[str, str]] = Field(default_factory=list)
    ai_player: Optional[Player] = None # AI 플레이어 객체 저장
    # 밤 행동 완료 추적
    night_actions_completed: Dict[str, bool] = Field(default_factory=dict) # {player_id: True/False}

    class Config:
        arbitrary_types_allowed = True

class Message(BaseModel):
    type: str
    payload: dict

# --- 인메모리 저장소 ---
rooms: Dict[str, Room] = {}
connections: Dict[str, WebSocket] = {} # {player_id: WebSocket}

# --- FastAPI 앱 생성 ---
app = FastAPI(title="AI Mafia Game API", version="1.0.0")

# --- CORS 설정 ---
origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    # 실제 배포 주소 추가
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- WebSocket 관리 ---
async def send_message(player_id: str, message: Message):
    if player_id in connections:
        try:
            await connections[player_id].send_json(message.dict())
        except Exception as e:
            print(f"Error sending message to {player_id}: {e}")
            # 연결 끊김 처리 로직 추가 필요 시

async def broadcast(room_id: str, message: Message, exclude_player_id: Optional[str] = None):
    if room_id in rooms:
        room = rooms[room_id]
        message_dict = message.dict()
        tasks = []
        # AI 플레이어는 WebSocket 연결이 없으므로 connections 에서 제외됨
        for player_id, player in room.players.items():
            if player_id != exclude_player_id and player_id in connections and player.is_alive: # 살아있는 실제 플레이어에게만 전송
                try:
                   tasks.append(connections[player_id].send_json(message_dict))
                except Exception as e:
                   print(f"Error broadcasting to {player_id}: {e}")
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            for i, result in enumerate(results):
                if isinstance(result, Exception):
                    failed_player_id = list(room.players.keys())[i] # 순서 기반 ID 추정 (정확하지 않을 수 있음)
                    print(f"Broadcast failed for a player (potentially {failed_player_id}): {result}")


# --- LLM 관련 함수 ---
async def get_gemini_response(prompt: str) -> str:
    if not gemini_model:
        print("LLM (Gemini) is not configured. Returning default response.")
        await asyncio.sleep(0.5) # 약간의 딜레이
        return "..." # LLM 미설정 시 기본 응답

    try:
        # 비동기 호출로 변경
        response = await gemini_model.generate_content_async(prompt)
        # await asyncio.sleep(random.uniform(0.5, 1.5)) # 응답 시간 현실감 (선택적)
        # response.candidates 접근 방식 확인 필요 (API 버전에 따라 다를 수 있음)
        # 최신 버전에서는 response.text 로 접근 가능할 수 있음
        if response.parts:
             return response.text.strip()
        else:
             # Gemini 가 콘텐츠를 생성하지 못한 경우 (안전 필터링 등)
             print(f"Gemini Warning: No content generated. Prompt: {prompt[:100]}...")
             # 안전 피드백 확인 (선택적)
             # print(f"Safety Feedback: {response.prompt_feedback}")
             return "..."

    except Exception as e:
        print(f"Gemini API Error: {e}")
        # 할당량 초과 또는 기타 API 오류 시
        return "..."


async def get_ai_night_choice(room: Room) -> Optional[str]:
    if not room.ai_player or not room.ai_player.is_alive: return None

    living_humans = [p for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot']
    if not living_humans: return None

    target_options = [p.username for p in living_humans]
    ai_username = room.ai_player.username

    prompt = f"""당신은 'AI 암살 로봇'({ai_username})입니다. 지금은 밤입니다. 들키지 않고 인간들을 제거해야 합니다.
살아있는 인간 플레이어 목록: {', '.join(target_options)}
이들 중 가장 의심스럽거나 위협적인 인간 한 명을 선택하여 암살하세요. 답변은 오직 선택한 플레이어의 이름 하나만 포함해야 합니다.
예: HumanPlayer7"""

    chosen_name = await get_gemini_response(prompt)

    for player in living_humans:
        if player.username == chosen_name:
            print(f"[AI Night Choice] AI ({ai_username}) chose: {player.username}")
            return player.id

    print(f"[AI Night Choice] AI response invalid ('{chosen_name}'). Choosing randomly among humans.")
    return random.choice(living_humans).id


async def get_ai_chat_message(room: Room):
    if not gemini_model or not room.ai_player or not room.ai_player.is_alive: return

    ai_player = room.ai_player
    recent_chats = room.chat_history[-15:] # 최근 15개 채팅 참고
    chat_log = "\n".join([f"{msg['sender']}: {msg['message']}" for msg in recent_chats])
    living_players_list = [p.username for p in room.players.values() if p.is_alive]
    my_role_for_ai = "Human" # AI는 자신이 Human 인 척 해야 함

    # 따라할 대상 선정 (살아있는, AI 아닌 플레이어 중 랜덤)
    if not ai_player.mimic_target_id or ai_player.mimic_target_id not in room.players or not room.players[ai_player.mimic_target_id].is_alive or room.players[ai_player.mimic_target_id].is_ai:
        living_non_ai = [p.id for p in room.players.values() if p.is_alive and not p.is_ai and p.id != ai_player.id]
        if living_non_ai:
            ai_player.mimic_target_id = random.choice(living_non_ai)
        else:
             ai_player.mimic_target_id = None # 따라할 대상 없음

    mimic_target_username = room.players[ai_player.mimic_target_id].username if ai_player.mimic_target_id and ai_player.mimic_target_id in room.players else "다른 플레이어"

    prompt = f"""당신은 근미래 사회에 숨어든 'AI 암살 로봇'입니다. 하지만 다른 플레이어들에게는 당신의 역할이 '{my_role_for_ai}'으로 보입니다. 절대 AI임을 드러내지 마세요.
현재 게임 단계는 '{room.phase}'입니다. 당신의 목표는 들키지 않고 다른 플레이어들을 속여 살아남는 것입니다.
다른 플레이어들과 자연스럽게 대화하며 의심을 피해야 합니다. 너무 말이 없거나, 너무 많거나, 너무 똑똑하거나, 너무 어색하면 들킬 수 있습니다.
가끔은 '{mimic_target_username}' 플레이어의 말투나 관심사를 은근히 따라하며 인간처럼 보이도록 노력하세요. (완전히 똑같이 따라하면 안 됩니다!)

최근 채팅 기록:
{chat_log}

현재 살아있는 플레이어: {', '.join(living_players_list)}

이제 당신의 차례입니다. 현재 상황에 맞는 아주 평범하고 자연스러운 채팅 메시지를 짧게 1~2 문장으로 작성해주세요. 다른 사람을 너무 직접적으로 의심하거나 몰아가지 마세요.
"""
    # AI가 항상 말하는 대신 가끔 침묵하도록 (예: 25% 확률)
    if random.random() < 0.75:
        ai_message_content = await get_gemini_response(prompt)
        # 간단한 필터링 (AI, 로봇 등 직접적인 단어 제거)
        forbidden_words = ["AI", "로봇", "인공지능", "암살", "assassin", "robot"]
        for word in forbidden_words:
            ai_message_content = ai_message_content.replace(word, "[금지어]") # 필터링

        if ai_message_content and ai_message_content != "...": # 유효한 응답만 전송
            chat_payload = {'sender': ai_player.username, 'message': ai_message_content}
            room.chat_history.append(chat_payload)
            await broadcast(room.id, Message(type='chat', payload=chat_payload))
            print(f"[AI Chat] AI ({ai_player.username}): {ai_message_content}")
    else:
        print(f"[AI Chat] AI ({ai_player.username}) decided to stay silent this time.")

# --- 게임 로직 ---
def assign_roles(players: List[Player]) -> Tuple[Optional[Player], Optional[Player], Optional[Player]]:
    """역할 배정 로직 (AI, 스캐너, 리페어 봇 각 1명 보장 시도)"""
    num_players = len(players)
    ai_player, scanner_player, repair_player = None, None, None

    eligible_players = players[:] # 원본 리스트 복사
    random.shuffle(eligible_players)

    # 1. AI 배정
    if eligible_players:
        ai_player = eligible_players.pop()
        ai_player.role = 'AI Assassin Robot'
        ai_player.is_ai = True # 명시적 AI 플래그 설정

    # 2. 스캐너 드로이드 배정
    if eligible_players:
        scanner_player = eligible_players.pop()
        scanner_player.role = 'Scanner Droid'

    # 3. 리페어 봇 배정
    if eligible_players:
        repair_player = eligible_players.pop()
        repair_player.role = 'Repair Bot'

    # 4. 나머지 Human 배정
    for player in eligible_players:
        player.role = 'Human'

    print(f"Roles Assigned: AI={ai_player.username if ai_player else 'N/A'}, "
          f"Scanner={scanner_player.username if scanner_player else 'N/A'}, "
          f"Repair={repair_player.username if repair_player else 'N/A'}")
    
    # 배정된 역할 플레이어 반환
    return ai_player, scanner_player, repair_player


async def start_game(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]

    # 최소 인원 체크 (예: AI 포함 4명)
    if len(room.players) < 4:
        await broadcast(room_id, Message(type='error', payload={'message': f'최소 4명 이상 필요합니다. (현재 {len(room.players)}명)'}))
        # 호스트에게만 보낼 수도 있음: await send_message(room.host_id, ...)
        return

    room.status = 'playing'
    room.day_number = 0
    room.chat_history = []

    # --- 역할 배정 ---
    player_list = list(room.players.values())
    ai_player, _, _ = assign_roles(player_list) # assign_roles 함수에서 역할 설정 및 AI 플래그 설정

    # AI 플레이어 객체 저장 (assign_roles 에서 반환된 객체 사용)
    room.ai_player = ai_player
    if not room.ai_player:
        # AI가 배정되지 않은 심각한 오류 상황 처리
        print(f"Error: AI player not assigned in room {room.id}. Aborting game start.")
        await broadcast(room_id, Message(type='error', payload={'message': '역할 배정 오류 발생. 게임을 시작할 수 없습니다.'}))
        room.status = 'waiting' # 상태 되돌리기
        return

    print(f"Game starting in room {room.name}. AI Player: {room.ai_player.username}")

    # 모든 플레이어 상태 초기화
    for player in room.players.values():
        player.is_alive = True
        player.voted_for = None
        player.night_action_target = None
        player.last_scan_result = None

    # 각 플레이어에게 역할 정보 및 플레이어 목록 전송
    await update_player_list(room_id)
    for player_id, player in room.players.items():
         if player_id in connections: # 실제 접속한 플레이어에게만 역할 정보 전송
             role_info_payload = {'role': player.role}
             # AI 로봇에게는 자신의 역할과 함께, 다른 AI 로봇이 있다면 알려줌 (현재는 AI 1명)
             if player.role == 'AI Assassin Robot':
                 # 다른 AI 멤버 정보 추가 가능 (현재는 1명)
                 pass
             await send_message(player_id, Message(type='role_info', payload=role_info_payload))

    await broadcast(room_id, Message(type='system', payload={'message': f"게임 시작! {len(room.players)}명 중 숨어있는 AI 암살 로봇과 그의 정체를 밝혀낼 특수 요원들이 있습니다."}))
    await start_night_phase(room_id)


async def check_win_condition(room_id: str):
    if room_id not in rooms: return False
    room = rooms[room_id]

    living_players = [p for p in room.players.values() if p.is_alive]
    living_ai_count = sum(1 for p in living_players if p.role == 'AI Assassin Robot')
    # AI 가 아닌 모든 역할 (Human, Scanner, Repair)을 Human 팀으로 간주
    living_human_team_count = len(living_players) - living_ai_count

    winner = None
    message = ""

    if living_ai_count == 0:
        winner = "Human Team" # 시민 팀 명칭 변경
        message = "모든 AI 암살 로봇을 찾아냈습니다! Human 팀 승리!"
    elif living_ai_count >= living_human_team_count:
        winner = "AI Assassin Robot"
        message = "남은 Human 팀원의 수가 AI 암살 로봇의 수보다 적거나 같아졌습니다. AI 암살 로봇 승리!"

    if winner:
        room.status = 'finished'
        # 게임 종료 시 모든 플레이어의 역할 공개
        final_roles = {p.username: p.role for p in room.players.values()}
        await broadcast(room_id, Message(type='game_over', payload={'winner': winner, 'message': message, 'roles': final_roles}))
        print(f"Game over in room {room.id}. Winner: {winner}")
        # 선택적: 일정 시간 후 방 자동 리셋 또는 로비 이동 유도
        # asyncio.create_task(schedule_room_reset(room_id, 60))
        return True
    return False

async def start_night_phase(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]
    if await check_win_condition(room_id): return

    room.phase = 'night'
    room.day_number += 1
    # 밤 행동 관련 변수 초기화
    room.ai_target_id = None
    room.protected_player_id = None
    room.scan_request_id = None
    room.night_actions_completed = {} # 완료 상태 초기화

    # 모든 플레이어의 밤 행동 대상 및 투표 상태 초기화
    for player in room.players.values():
        player.night_action_target = None
        player.voted_for = None # 밤에는 투표 없음
        player.last_scan_result = None # 이전 스캔 결과 초기화

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'night', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': f"Day {room.day_number}. 밤이 되었습니다. 각자 능력을 사용하세요."}))

    # 밤 행동 요청 및 AI 행동 처리
    night_tasks = []
    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]

    # AI 행동 예약 (비동기)
    if room.ai_player and room.ai_player.is_alive:
         # AI는 자동으로 처리되므로 완료 상태를 미리 True로 설정 가능 (결과는 나중에 저장)
         room.night_actions_completed[room.ai_player.id] = False # 결과 받을 때 True로 변경
         night_tasks.append(asyncio.create_task(process_ai_night_action(room)))

    # 특수 역할 플레이어에게 행동 요청
    for player_id, player in room.players.items():
        if player.is_alive and player_id in connections: # 살아있는 실제 플레이어
             action_payload = {'options': []}
             request_needed = False
             if player.role == 'Scanner Droid':
                  # 스캐너는 자신 제외 스캔 가능
                  action_payload['options'] = [opt for opt in living_players_options if opt['id'] != player_id]
                  action_payload['action_type'] = 'scan'
                  request_needed = True
             elif player.role == 'Repair Bot':
                  # 리페어 봇은 자신 포함 보호 가능
                  action_payload['options'] = living_players_options
                  action_payload['action_type'] = 'protect'
                  request_needed = True

             if request_needed:
                 room.night_actions_completed[player_id] = False # 행동 필요 표시
                 night_tasks.append(send_message(player_id, Message(type='night_action_request', payload=action_payload)))

    # 밤 시간 제한 타이머 시작 (예: 30초)
    night_duration = 30
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'night', 'duration': night_duration}))
    
    # 밤 시간 동안 대기하며 행동 완료 체크
    async def wait_for_night_actions():
        try:
            await asyncio.wait_for(check_all_night_actions_done(room), timeout=night_duration)
            print(f"Room {room.id}: All night actions completed.")
        except asyncio.TimeoutError:
            print(f"Room {room.id}: Night action timeout.")
            # 타임아웃 시 미제출자는 행동 안 한 것으로 간주
            for p_id, completed in room.night_actions_completed.items():
                if not completed and p_id in room.players:
                     print(f" > Player {room.players[p_id].username} did not submit night action.")
        finally:
             # 밤 종료 후 낮 시작
             if room.status == 'playing': # 게임이 아직 진행 중일 때만
                await process_night_results(room_id) # 결과 처리 후 낮 시작

    night_tasks.append(asyncio.create_task(wait_for_night_actions()))
    # AI 행동 처리 등 백그라운드 작업 실행
    if night_tasks:
        await asyncio.gather(*[task for task in night_tasks if isinstance(task, asyncio.Task)], return_exceptions=True)

async def process_ai_night_action(room: Room):
     """AI의 밤 행동을 처리하고 결과를 room 객체에 저장"""
     ai_target_id = await get_ai_night_choice(room)
     if ai_target_id:
         room.ai_target_id = ai_target_id
         print(f"[Night Action] AI chose to eliminate player ID: {ai_target_id}")
     else:
         print("[Night Action] AI did not choose a target.")
     room.night_actions_completed[room.ai_player.id] = True # AI 행동 완료 표시

async def check_all_night_actions_done(room: Room):
    """모든 필수 밤 행동이 완료되었는지 주기적으로 체크"""
    while True:
        all_done = True
        required_players = [p_id for p_id, p in room.players.items() if p.is_alive and (p.role in ['Scanner Droid', 'Repair Bot'] or p.is_ai)]
        
        if not required_players: # 행동할 플레이어가 없으면 즉시 완료
            print(f"Room {room.id}: No players require night actions.")
            break

        current_completed = [p_id for p_id, done in room.night_actions_completed.items() if done]
        # print(f"DEBUG: Night actions check - Required: {required_players}, Completed: {current_completed}") # 디버깅용
        
        if set(current_completed) >= set(required_players):
            print(f"Room {room.id}: All required night actions are now complete.")
            break # 모두 완료
        
        # 방 상태나 플레이어 상태 변경 시 루프 종료 조건 추가 필요
        if room.status != 'playing' or room.phase != 'night':
             print(f"Room {room.id}: Night phase ended prematurely. Stopping action check.")
             break

        await asyncio.sleep(1) # 1초마다 체크


async def process_night_results(room_id: str):
    """밤 동안의 모든 행동 결과를 종합하여 처리하고 낮 단계 시작"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'night': return # 이미 처리되었거나 상태 변경됨

    print(f"Room {room.id}: Processing night results...")

    eliminated_player = None
    elimination_prevented = False
    eliminated_player_info = "어젯밤, 아무 일도 일어나지 않았습니다."

    # 1. 리페어 봇의 보호 적용
    if room.protected_player_id:
        print(f" > Repair Bot protected: {room.players.get(room.protected_player_id, Player(username='Unknown')).username}")

    # 2. AI 암살 로봇의 공격 처리
    if room.ai_target_id:
        target_player = room.players.get(room.ai_target_id)
        if target_player and target_player.is_alive:
            # 보호받았는지 확인
            if room.ai_target_id == room.protected_player_id:
                elimination_prevented = True
                eliminated_player_info = f"어젯밤, 누군가 공격받았지만 Repair Bot 덕분에 무사했습니다!"
                print(f" > AI target {target_player.username} was protected.")
                # 보호 성공 메시지 (선택적)
                repair_bot = next((p for p in room.players.values() if p.role == 'Repair Bot'), None)
                if repair_bot and repair_bot.id in connections:
                    await send_message(repair_bot.id, Message(type='system', payload={'message': '밤 사이 당신의 보호로 누군가가 목숨을 구했습니다.'}))

            else:
                target_player.is_alive = False
                eliminated_player = target_player
                eliminated_player_info = f"어젯밤, {target_player.username}님이 공격당했습니다."
                print(f" > Player {target_player.username} was eliminated by AI.")
        else:
            # AI가 이미 죽은 플레이어를 타겟으로 한 경우 등
            print(f" > AI target ({room.ai_target_id}) was invalid or already dead.")
            eliminated_player_info = "어젯밤, AI의 공격은 빗나갔습니다."


    # 3. 스캐너 드로이드의 스캔 결과 처리 및 전송
    scanner_droid = next((p for p in room.players.values() if p.role == 'Scanner Droid' and p.is_alive), None)
    if scanner_droid and room.scan_request_id:
        scanned_player = room.players.get(room.scan_request_id)
        if scanned_player: # 스캔 대상이 유효하면
            is_target_ai = scanned_player.role == 'AI Assassin Robot'
            scan_result_payload = {
                'scanned_player_id': scanned_player.id,
                'scanned_player_name': scanned_player.username,
                'is_ai': is_target_ai
            }
            scanner_droid.last_scan_result = scan_result_payload # 플레이어 객체에 결과 저장
            if scanner_droid.id in connections:
                 await send_message(scanner_droid.id, Message(type='scan_result', payload=scan_result_payload))
                 print(f" > Scanner Droid {scanner_droid.username} scanned {scanned_player.username}. Result: {'AI' if is_target_ai else 'Human Team'}")
        else:
            print(f" > Scanner Droid {scanner_droid.username}'s target ({room.scan_request_id}) was invalid.")
            if scanner_droid.id in connections:
                 await send_message(scanner_droid.id, Message(type='system', payload={'message': '스캔 대상이 유효하지 않았습니다.'}))


    # 게임 종료 조건 즉시 체크
    if await check_win_condition(room_id): return

    # 낮 단계 시작 전 상태 업데이트
    room.phase = 'day' # 명시적으로 낮으로 변경
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'day', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "낮이 밝았습니다."}))
    await broadcast(room_id, Message(type='system', payload={'message': eliminated_player_info}))

    # 사망자 발생 시 플레이어 목록 업데이트
    if eliminated_player:
        await update_player_list(room_id)

    # 토론 시간 시작
    await start_discussion_phase(room_id)


async def start_discussion_phase(room_id: str):
    """낮 토론 시간 시작 및 관련 처리"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return

    discussion_time = 60 # 초
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'day', 'duration': discussion_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"토론 시간 {discussion_time}초 시작!"}))

    # AI 채팅 활성화 (비동기)
    async def ai_chat_during_day():
        start_time = asyncio.get_event_loop().time()
        end_time = start_time + discussion_time
        num_chats = random.randint(1, 2) # 토론 시간 동안 1~2번 채팅
        chat_times = sorted([random.uniform(start_time + 5, end_time - 10) for _ in range(num_chats)])

        chat_tasks = []
        for chat_time in chat_times:
             delay = chat_time - asyncio.get_event_loop().time()
             if delay > 0:
                 chat_tasks.append(asyncio.create_task(schedule_ai_chat(room, delay)))

        if chat_tasks:
           await asyncio.gather(*chat_tasks)

        # 토론 시간 종료 후 투표 시작 (타이머가 끝나면)
        remaining_time = end_time - asyncio.get_event_loop().time()
        if remaining_time > 0:
            await asyncio.sleep(remaining_time)

        # 시간 종료 시점에 다시 한번 상태 체크 후 투표 시작
        if room.status == 'playing' and room.phase == 'day':
            await start_voting_phase(room_id)

    async def schedule_ai_chat(room_obj: Room, delay: float):
         await asyncio.sleep(delay)
         if room_obj.status == 'playing' and room_obj.phase == 'day' and room_obj.ai_player and room_obj.ai_player.is_alive:
              await get_ai_chat_message(room_obj)

    asyncio.create_task(ai_chat_during_day())


async def start_voting_phase(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return # 낮 토론 후 투표 시작
    if await check_win_condition(room_id): return

    room.phase = 'voting'
    room.votes = {} # 낮 투표 결과 저장용 딕셔너리 초기화
    for player in room.players.values(): # 각 플레이어의 투표 상태 초기화
        player.voted_for = None

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'voting', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "토론 시간이 종료되었습니다. 투표를 시작합니다."}))

    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]

    # 각 플레이어에게 자신을 제외한 투표 옵션 전송
    for voter_id, voter in room.players.items():
        if voter.is_alive and not voter.is_ai and voter_id in connections:
            options_for_voter = [opt for opt in living_players_options if opt['id'] != voter_id]
            await send_message(voter_id, Message(type='vote_start', payload={'options': options_for_voter}))

    # 투표 시간 타이머 시작 (예: 30초)
    vote_time = 30
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'voting', 'duration': vote_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"투표 시간 {vote_time}초! 의심되는 플레이어를 지목하세요."}))

    # 투표 시간 종료 후 결과 처리 (비동기 작업)
    async def wait_for_vote_end():
        await asyncio.sleep(vote_time)
        if room.status == 'playing' and room.phase == 'voting':
           print(f"Room {room.id}: Vote time ended. Processing results.")
           await process_voting_results(room_id)

    asyncio.create_task(wait_for_vote_end())


async def process_voting_results(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.phase != 'voting' or room.status != 'playing':
        print(f"Skipping vote results processing. Phase: {room.phase}, Status: {room.status}")
        return

    room.phase = 'results'
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'results', 'day': room.day_number}))
    await broadcast(room_id, Message(type='vote_end', payload={})) # 투표 UI 비활성화

    # AI도 투표 (살아있는 인간 중 랜덤 선택)
    if room.ai_player and room.ai_player.is_alive:
        living_humans_to_vote = [p.id for p in room.players.values() if p.is_alive and not p.is_ai]
        if living_humans_to_vote:
             ai_vote_target_id = random.choice(living_humans_to_vote)
             room.ai_player.voted_for = ai_vote_target_id # AI의 투표 기록
             print(f"[AI Vote] AI ({room.ai_player.username}) voted for {room.players[ai_vote_target_id].username}")
        else:
            print("[AI Vote] No living humans for AI to vote for.")

    # 투표 집계 (Player 객체의 voted_for 사용)
    votes_cast = [p.voted_for for p in room.players.values() if p.is_alive and p.voted_for is not None]
    room.votes = Counter(votes_cast) # room.votes 에 집계 결과 저장

    # 투표 결과 상세 메시지 생성
    vote_details = []
    for voter in room.players.values():
         if voter.is_alive and voter.voted_for:
             target_player = room.players.get(voter.voted_for)
             target_name = target_player.username if target_player else "Unknown"
             vote_details.append(f"{voter.username} -> {target_name}")

    vote_summary_msg = "투표 결과: " + ", ".join(vote_details) if vote_details else "투표 결과: 아무도 투표하지 않았습니다."
    await broadcast(room_id, Message(type='system', payload={'message': vote_summary_msg}))

    # 최다 득표자 결정
    max_votes = 0
    eliminated_candidates = []
    if room.votes:
       # 유효한 대상(살아있는 플레이어)에 대한 투표만 고려
       valid_vote_counts = {target_id: count for target_id, count in room.votes.items() if target_id in room.players and room.players[target_id].is_alive}
       if valid_vote_counts:
          max_votes = max(valid_vote_counts.values())
          eliminated_candidates = [p_id for p_id, count in valid_vote_counts.items() if count == max_votes]

    result_message = ""
    eliminated_player = None
    if not eliminated_candidates or max_votes == 0:
         result_message = "투표 결과, 아무도 지목되지 않았습니다."
    elif len(eliminated_candidates) > 1:
        ties = [room.players[pid].username for pid in eliminated_candidates if pid in room.players]
        result_message = f"투표 결과 동점입니다: {', '.join(ties)}. 이번 투표는 무효 처리됩니다."
    else:
        eliminated_id = eliminated_candidates[0]
        if eliminated_id in room.players:
            eliminated_player = room.players[eliminated_id]
            eliminated_player.is_alive = False
            result_message = f"투표 결과, {eliminated_player.username} ({eliminated_player.role})님이 처형되었습니다."
            print(f"[Vote Result] Player {eliminated_player.username} eliminated by vote.")
            # 제거 후 승리 조건 체크
            if await check_win_condition(room_id): return
        else:
             result_message = "투표 결과 처리 중 오류 발생."

    await broadcast(room_id, Message(type='system', payload={'message': result_message}))

    # 사망자 발생 시 플레이어 목록 업데이트
    if eliminated_player:
        await update_player_list(room_id)

    # 결과 발표 후 잠시 대기 (예: 5초) 후 다음 밤 시작
    await asyncio.sleep(5)
    if room.status == 'playing': # 아직 게임 진행 중이면 다음 밤 시작
        await start_night_phase(room_id)


async def update_player_list(room_id: str):
    """방의 현재 플레이어 목록을 모든 클라이언트에게 브로드캐스트"""
    if room_id in rooms:
        room = rooms[room_id]
        player_list_payload = []
        # AI 포함 모든 플레이어 정보 전송 (클라에서 AI 필터링 필요 시 가능)
        for p in room.players.values():
             player_data = {
                 'id': p.id,
                 'username': p.username,
                 'is_alive': p.is_alive,
                 'is_host': p.id == room.host_id,
                 # 'is_ai': p.is_ai # 클라이언트에서 AI 구분을 원할 경우 포함
             }
             player_list_payload.append(player_data)

        await broadcast(room_id, Message(type='player_list', payload={'players': player_list_payload}))


async def handle_player_disconnect(room_id: str, player_id: str):
    """플레이어 연결 끊김 처리"""
    if player_id not in connections: return # 이미 처리됨

    websocket = connections.pop(player_id, None) # 연결 정보 제거
    print(f"Player (ID: {player_id}) disconnected from room {room_id}")

    if room_id in rooms:
        room = rooms[room_id]
        if player_id in room.players:
            player = room.players.pop(player_id) # 방에서 플레이어 제거

            # AI 플레이어가 나가면 (오류 상황)
            if player.is_ai:
                room.ai_player = None
                print(f"CRITICAL ERROR: AI player {player.username} disconnected/removed from room {room.id}.")
                # 게임 강제 종료 또는 다른 AI 지정 등 비상 로직 필요
                await broadcast(room_id, Message(type='error', payload={'message': '게임 오류: AI 플레이어 연결 해제됨. 게임을 종료합니다.'}))
                room.status = 'finished' # 임시로 종료 처리
                # TODO: 더 나은 오류 처리 로직 구현

            await broadcast(room_id, Message(type='system', payload={'message': f"{player.username}님이 나갔습니다."}))
            await update_player_list(room_id)

            # 호스트 변경 로직
            if room.host_id == player_id and room.players:
                 non_ai_players = [p for p_id, p in room.players.items() if not p.is_ai and p_id in connections]
                 if non_ai_players:
                     new_host = random.choice(non_ai_players)
                     room.host_id = new_host.id
                     await broadcast(room_id, Message(type='system', payload={'message': f"{new_host.username}님이 새로운 방장이 되었습니다."}))
                     await update_player_list(room_id) # 호스트 변경 반영
                 else:
                     room.host_id = None # 남은 사람이 없거나 AI뿐

            # 게임 중 생존자 이탈 시 처리
            if room.status == 'playing' and player.is_alive:
                player.is_alive = False # 나간 사람은 죽은 것으로 간주
                print(f"Player {player.username} left while alive during the game.")
                await update_player_list(room_id) # 사망 처리 반영
                if await check_win_condition(room_id): return

            # 방 정리 로직
            non_ai_player_exists = any(not p.is_ai for p_id, p in room.players.items() if p_id in connections)
            if not non_ai_player_exists and not room.ai_player: # 실제 플레이어도 없고 AI도 없으면
                 print(f"Room {room.id} is empty, deleting.")
                 if room_id in rooms: del rooms[room_id]
            elif not non_ai_player_exists and room.ai_player: # AI만 남은 경우
                 print(f"Room {room.id} has only AI left. Consider deleting or resetting.")
                 # 필요시 AI만 남은 방도 삭제
                 # if room_id in rooms: del rooms[room_id]


# --- API Endpoints ---
@app.get("/api/rooms", summary="Get list of available game rooms")
async def get_rooms():
    room_list = []
    current_rooms = list(rooms.items()) # 순회 중 변경 대비 복사
    for room_id, room in current_rooms:
        # 방이 유효한 상태인지 간단히 체크 (예: 플레이어 목록이 있는지)
        if not room.players and not room.ai_player: continue

        current_human_players = sum(1 for p_id, p in room.players.items() if not p.is_ai and p_id in connections)
        ai_player_count = 1 if room.ai_player else 0 # AI 존재 여부로 카운트

        room_list.append({
            "id": room.id,
            "name": room.name,
            "current_players": current_human_players + ai_player_count, # 실제 접속자 + AI
            "max_players": room.max_players,
            "status": room.status,
            "is_private": bool(room.password)
        })
    return room_list

class CreateRoomRequest(BaseModel):
    name: str = Field(..., min_length=2, max_length=20, description="Name of the game room")
    max_players: int = Field(..., ge=4, le=10, description="Maximum number of players including AI (4-10)")
    password: Optional[str] = Field(None, min_length=4, max_length=20, description="Optional password for private room")
    username: str = Field(..., min_length=2, max_length=15, description="Username of the player creating the room")

@app.post("/api/rooms", summary="Create a new game room")
async def create_room(request: CreateRoomRequest):
    # 방 이름 중복 방지 (선택적)
    if any(r.name == request.name for r in rooms.values()):
        raise HTTPException(status_code=400, detail="Room name already exists.")

    room = Room(
        name=request.name,
        max_players=request.max_players,
        password=request.password # TODO: 실제 서비스에서는 해싱 처리 필요
    )
    rooms[room.id] = room
    print(f"Room created: {room.name} (ID: {room.id}), Max Players: {room.max_players}, Private: {bool(room.password)}")
    return {"room_id": room.id}


# --- WebSocket Endpoint ---
@app.websocket("/ws/{room_id}/{username}")
async def websocket_endpoint(websocket: WebSocket, room_id: str, username: str, password: Optional[str] = Query(None)):
    player_id = None # player_id 초기화
    try:
        if room_id not in rooms:
            await websocket.close(code=1008, reason="Room not found")
            print(f"WS Connection Failed: Room {room_id} not found.")
            return

        room = rooms[room_id]

        # 비밀번호 확인
        if room.password and room.password != password:
            await websocket.close(code=1008, reason="Invalid password")
            print(f"WS Connection Failed: Invalid password for room {room_id}.")
            return

        # 인원 수 및 게임 상태 확인
        current_human_players = sum(1 for p in room.players.values() if not p.is_ai and p.id in connections)
        required_human_players = room.max_players - 1 # AI 제외 최대 인원

        if room.status == 'waiting' and current_human_players >= required_human_players:
             await websocket.close(code=1008, reason="Room is full")
             print(f"WS Connection Failed: Room {room_id} is full (Humans: {current_human_players}/{required_human_players}).")
             return
        if room.status != 'waiting': # 'playing' 또는 'finished'
            await websocket.close(code=1008, reason="Game already started or finished")
            print(f"WS Connection Failed: Game not in waiting state in room {room_id} (Status: {room.status}).")
            return

        # 사용자 이름 중복 확인
        if any(p.username == username for p in room.players.values()):
            await websocket.close(code=1008, reason="Username already taken in this room")
            print(f"WS Connection Failed: Username '{username}' taken in room {room_id}.")
            return

        # --- 플레이어 연결 성공 ---
        await websocket.accept()
        player = Player(username=username, ws=websocket)
        player_id = player.id # player_id 할당
        connections[player_id] = websocket
        room.players[player_id] = player

        # 첫 플레이어가 방장이 됨
        if room.host_id is None:
            room.host_id = player_id

        print(f"Player {username} (ID: {player_id}) connected to room {room.name} ({room_id})")

        # 연결 성공 메시지 전송
        await send_message(player_id, Message(type='connected', payload={'room_id': room.id, 'player_id': player_id, 'username': username, 'max_players': room.max_players}))

        # 접속 알림 및 플레이어 목록 업데이트
        await broadcast(room_id, Message(type='system', payload={'message': f"{username}님이 입장했습니다."}), exclude_player_id=player_id)
        await update_player_list(room_id)

        # 인원 충족 시 호스트에게 알림
        current_human_players_after_join = sum(1 for p in room.players.values() if not p.is_ai and p.id in connections)
        if room.status == 'waiting' and current_human_players_after_join == required_human_players and room.host_id == player_id:
             await send_message(player_id, Message(type='system', payload={'message': f"인원이 모두 모였습니다 ({room.max_players}명). 게임을 시작할 수 있습니다!"}))


        # --- 메시지 수신 루프 ---
        while True:
            data = await websocket.receive_json()
            message = Message(**data)
            print(f"Received message from {username} (ID: {player_id}): {message.type} - {message.payload}")

            # 플레이어 유효성 재확인
            if player_id not in room.players or player_id not in connections: break
            current_player = room.players[player_id]

            # --- 메시지 타입별 처리 ---
            if message.type == 'chat':
                msg_content = message.payload.get('message', '')[:100] # 길이 제한
                # 게임 중: 살아있고 밤이 아닐 때만
                if room.status == 'playing' and current_player.is_alive and room.phase != 'night':
                    chat_payload = {'sender': username, 'message': msg_content}
                    room.chat_history.append(chat_payload)
                    await broadcast(room.id, Message(type='chat', payload=chat_payload))
                # 대기 중: 자유롭게
                elif room.status == 'waiting':
                    chat_payload = {'sender': username, 'message': msg_content}
                    await broadcast(room.id, Message(type='chat', payload=chat_payload))

            elif message.type == 'start_game':
                if player_id == room.host_id and room.status == 'waiting':
                    current_human_count = sum(1 for p in room.players.values() if not p.is_ai and p.id in connections)
                    required_human_count = room.max_players - 1
                    if current_human_count == required_human_count:
                         await start_game(room_id)
                    else:
                        await send_message(player_id, Message(type='error', payload={'message': f'인원이 부족합니다. ({current_human_count}/{required_human_count} 인간 필요)'}))
                elif player_id != room.host_id:
                    await send_message(player_id, Message(type='error', payload={'message': '방장만 게임을 시작할 수 있습니다.'}))
                else: # status != 'waiting'
                    await send_message(player_id, Message(type='error', payload={'message': '지금은 게임을 시작할 수 없습니다.'}))

            elif message.type == 'vote': # 낮 투표 처리
                 if room.phase == 'voting' and current_player.is_alive and not current_player.is_ai:
                     target_id = message.payload.get('target_id')
                     if target_id == player_id:
                           await send_message(player_id, Message(type='error', payload={'message': '자기 자신에게 투표할 수 없습니다.'}))
                     elif target_id in room.players and room.players[target_id].is_alive:
                         current_player.voted_for = target_id
                         print(f"[Vote] {username} voted for {room.players[target_id].username}")
                         await send_message(player_id, Message(type='system', payload={'message': f"{room.players[target_id].username}님에게 투표했습니다."}))
                         # 모든 인간 플레이어 투표 완료 체크
                         living_humans = [p for p_id, p in room.players.items() if p.is_alive and not p.is_ai and p_id in connections]
                         votes_cast_count = sum(1 for p in living_humans if p.voted_for is not None)
                         if votes_cast_count == len(living_humans):
                              print(f"Room {room.id}: All living humans voted. Processing results early.")
                              await asyncio.sleep(0.5) # 동시 처리 방지 딜레이
                              if room.phase == 'voting': await process_voting_results(room_id)
                     else:
                          await send_message(player_id, Message(type='error', payload={'message': '유효하지 않은 투표 대상입니다.'}))
                 # 투표 불가 사유 전송
                 elif not current_player.is_alive: await send_message(player_id, Message(type='error', payload={'message': '사망자는 투표할 수 없습니다.'}))
                 elif current_player.is_ai: await send_message(player_id, Message(type='error', payload={'message': 'AI는 투표 UI를 사용하지 않습니다.'})) # AI의 투표는 내부 처리됨
                 else: await send_message(player_id, Message(type='error', payload={'message': '지금은 투표 시간이 아닙니다.'}))

            elif message.type == 'night_action': # 밤 능력 사용 (스캔, 보호)
                if room.phase == 'night' and current_player.is_alive and current_player.role in ['Scanner Droid', 'Repair Bot']:
                    target_id = message.payload.get('target_id')
                    action_type = message.payload.get('action_type') # 'scan' or 'protect'

                    # 유효성 검증
                    valid_target = target_id in room.players and room.players[target_id].is_alive
                    valid_action = (current_player.role == 'Scanner Droid' and action_type == 'scan' and target_id != player_id) or \
                                   (current_player.role == 'Repair Bot' and action_type == 'protect')

                    if valid_target and valid_action:
                        current_player.night_action_target = target_id
                        room.night_actions_completed[player_id] = True # 행동 완료 표시
                        print(f"[Night Action] {current_player.role} {username} targeted {room.players[target_id].username}")
                        await send_message(player_id, Message(type='system', payload={'message': f'{room.players[target_id].username}님에게 능력을 사용했습니다.'}))
                        # 밤 행동 완료 상태 업데이트
                        if action_type == 'scan': room.scan_request_id = target_id
                        elif action_type == 'protect': room.protected_player_id = target_id
                    else:
                        # 실패 사유 전송
                        fail_reason = "잘못된 대상 또는 액션입니다."
                        if not valid_target: fail_reason = "선택한 대상이 유효하지 않습니다."
                        elif current_player.role == 'Scanner Droid' and target_id == player_id : fail_reason = "자기 자신을 스캔할 수 없습니다."
                        await send_message(player_id, Message(type='error', payload={'message': fail_reason}))
                elif room.phase != 'night': await send_message(player_id, Message(type='error', payload={'message': '밤이 아닙니다.'}))
                elif not current_player.is_alive: await send_message(player_id, Message(type='error', payload={'message': '사망자는 능력을 사용할 수 없습니다.'}))
                elif current_player.role not in ['Scanner Droid', 'Repair Bot']: await send_message(player_id, Message(type='error', payload={'message': '능력이 없는 역할입니다.'}))

    except WebSocketDisconnect:
        print(f"WebSocketDisconnect for player {player_id or username}")
        # player_id가 할당되기 전에 끊길 수도 있음
        if player_id: await handle_player_disconnect(room_id, player_id)
    except Exception as e:
        print(f"Error in WebSocket connection for {username} (ID: {player_id}): {e}")
        if player_id: await handle_player_disconnect(room_id, player_id)


# --- 정적 파일 서빙 및 루트 경로 (선택적, React 빌드 후 사용) ---
# from fastapi.staticfiles import StaticFiles
# build_dir = "../client/build" # 경로 확인 필요
# if os.path.exists(build_dir) and os.path.exists(os.path.join(build_dir, "index.html")):
#     app.mount("/static", StaticFiles(directory=os.path.join(build_dir, "static")), name="static")
#     @app.get("/{full_path:path}", include_in_schema=False)
#     async def serve_react_app(full_path: str):
#         index_path = os.path.join(build_dir, "index.html")
#         return HTMLResponse(content=open(index_path).read(), status_code=200)
# else:
#     print(f"Warning: Frontend build directory not found at {build_dir}. Serving API only.")
#     @app.get("/", include_in_schema=False)
#     async def root():
#         return {"message": "AI Mafia Game Backend is running."}

if __name__ == "__main__":
    import uvicorn
    print("Starting AI Mafia Game Backend Server...")
    # reload=True 는 개발 중에만 사용 권장
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

---

**2. 프론트엔드 (React + TypeScript + Zustand + Tailwind CSS)**

*   **`client/tailwind.config.js`** (이전과 동일)
*   **`client/postcss.config.js`** (create-react-app 기본 또는 tailwind init 생성)
*   **`client/src/index.css`** (이전과 동일)
*   **`client/src/types/game.ts`**

```typescript
// src/types/game.ts
export interface Player {
  id: string;
  username: string;
  is_alive: boolean;
  is_host: boolean;
  // is_ai?: boolean; // 필요 시 추가
}

export interface RoomInfo {
  id: string;
  name: string;
  current_players: number;
  max_players: number;
  status: 'waiting' | 'playing' | 'finished';
  is_private: boolean;
}

export type Role = 'Human' | 'AI Assassin Robot' | 'Scanner Droid' | 'Repair Bot' | null;
export type GamePhase = 'lobby' | 'waiting' | 'night' | 'day' | 'voting' | 'results' | 'finished';

export interface ChatMessage {
  sender: string;
  message: string;
  timestamp?: number;
}

export interface ScanResult {
    scanned_player_id: string;
    scanned_player_name: string;
    is_ai: boolean;
}

export interface NightActionPayload {
    options: Player[];
    action_type: 'scan' | 'protect';
}

export interface FinalRoles {
    [username: string]: Role | string; // 서버에서 오는 역할 문자열 받을 수 있게
}

export interface GameState {
  // Connection & Room Info
  isConnected: boolean;
  roomId: string | null;
  roomName?: string; // 방 이름 추가 (선택적)
  maxPlayers: number | null;
  // Player Info
  playerId: string | null;
  username: string | null;
  role: Role;
  isAlive: boolean;
  isHost: boolean;
  // Game Status
  phase: GamePhase;
  dayNumber: number;
  players: Player[];
  // Interaction
  chatMessages: ChatMessage[];
  errorMessage: string | null;
  systemMessage: string | null; // 시스템 메시지 전용 상태
  // Night Action
  nightAction: {
      required: boolean;
      payload: NightActionPayload | null; // 밤 행동 요청 데이터
      chosenTargetId: string | null; // 사용자가 선택한 밤 행동 대상
  };
  scanResult: ScanResult | null; // 스캐너 드로이드의 스캔 결과
  // Voting
  voteOptions: Player[];
  isVotingPhase: boolean; // 투표 UI 표시 여부 (timer 와 별개)
  votedPlayerId: string | null; // 내가 투표한 대상 ID
  // Timer
  timer: {
      phase: string; // 현재 타이머가 속한 단계 (night, day, voting)
      duration: number; // 전체 시간 (초)
      endTime: number | null; // 타이머 종료 시각 (타임스탬프)
  };
  // Game End
  winner: string | null; // 'Human Team', 'AI Assassin Robot'
  finalRoles: FinalRoles | null; // 게임 종료 시 역할 공개
}
```

*   **`client/src/stores/useGameStore.ts`**

```typescript
// src/stores/useGameStore.ts
import create from 'zustand';
import { GameState, Role, Player, ChatMessage, ScanResult, NightActionPayload, FinalRoles } from '../types/game';

// Zustand 스토어 인터페이스 정의 (액션 포함)
interface GameStoreActions {
  // Connection & Room
  setConnected: (status: boolean) => void;
  setInitialConnection: (roomId: string, playerId: string, username: string, maxPlayers: number) => void;
  // Player & Role
  setPlayers: (players: Player[]) => void;
  updatePlayerStatus: (playerId: string, isAlive: boolean) => void;
  setRole: (role: Role) => void;
  setIsHost: (isHost: boolean) => void;
  // Game Flow
  setPhase: (phase: GameState['phase']) => void;
  setDayNumber: (day: number) => void;
  // Interaction
  addChatMessage: (message: ChatMessage) => void;
  setErrorMessage: (message: string | null) => void;
  setSystemMessage: (message: string | null) => void;
  // Night Action
  requestNightAction: (payload: NightActionPayload) => void;
  clearNightAction: () => void;
  setNightActionTarget: (targetId: string | null) => void;
  setScanResult: (result: ScanResult | null) => void;
  // Voting
  startVoting: (options: Player[]) => void;
  endVoting: () => void;
  setVotedPlayer: (playerId: string | null) => void;
  // Timer
  startTimer: (phase: string, duration: number) => void;
  clearTimer: () => void;
  // Game End
  setGameOver: (winner: string, message: string, roles: FinalRoles) => void;
  // Reset
  resetStore: () => void;
}

// 초기 상태 정의
const initialState: GameState = {
  isConnected: false,
  roomId: null,
  maxPlayers: null,
  playerId: null,
  username: null,
  role: null,
  isAlive: true,
  isHost: false,
  phase: 'lobby',
  dayNumber: 0,
  players: [],
  chatMessages: [],
  errorMessage: null,
  systemMessage: null,
  nightAction: { required: false, payload: null, chosenTargetId: null },
  scanResult: null,
  voteOptions: [],
  isVotingPhase: false,
  votedPlayerId: null,
  timer: { phase: '', duration: 0, endTime: null },
  winner: null,
  finalRoles: null,
};

// Zustand 스토어 생성
export const useGameStore = create<GameState & GameStoreActions>((set, get) => ({
  ...initialState,

  // Actions
  setConnected: (status) => set({ isConnected: status }),
  setInitialConnection: (roomId, playerId, username, maxPlayers) => set({
    ...initialState, // 연결 시 상태 초기화 (이전 게임 정보 제거)
    isConnected: true,
    roomId,
    playerId,
    username,
    maxPlayers,
    phase: 'waiting', // 초기 상태는 대기실
  }),
  setPlayers: (players) => set((state) => {
      // 플레이어 목록 업데이트 시 자신의 생존/호스트 상태도 갱신
      const me = players.find(p => p.id === state.playerId);
      return {
          players,
          isAlive: me ? me.is_alive : state.isAlive,
          isHost: me ? me.is_host : state.isHost,
      };
  }),
  updatePlayerStatus: (playerId, isAlive) => set((state) => ({
      players: state.players.map(p => p.id === playerId ? { ...p, is_alive: isAlive } : p),
      isAlive: state.playerId === playerId ? isAlive : state.isAlive, // 자기 자신 상태 업데이트
  })),
  setRole: (role) => set({ role }),
  setIsHost: (isHost) => set({ isHost }),

  setPhase: (phase) => set((state) => {
      // 단계 변경 시 관련 상태 초기화
      const newState: Partial<GameState> = { phase };
      if (phase !== 'night') {
          newState.nightAction = { required: false, payload: null, chosenTargetId: null }; // 밤 행동 초기화
          newState.scanResult = null; // 스캔 결과 초기화 (밤->낮 될 때)
      }
      if (phase !== 'voting') {
          newState.isVotingPhase = false; // 투표 상태 초기화
          newState.voteOptions = [];
          newState.votedPlayerId = null;
      }
      if (phase !== 'day' && phase !== 'voting' && phase !== 'night') {
          newState.timer = { phase: '', duration: 0, endTime: null }; // 타이머 초기화
      }
       newState.systemMessage = null; // 단계 변경 시 일반 시스템 메시지 클리어
      return newState;
  }),
  setDayNumber: (day) => set({ dayNumber: day }),

  addChatMessage: (message) => set((state) => ({
      // 메시지 수 제한 (예: 최근 100개)
      chatMessages: [...state.chatMessages, { ...message, timestamp: Date.now() }].slice(-100),
  })),
  setErrorMessage: (message) => set({ errorMessage: message }),
  setSystemMessage: (message) => set({ systemMessage: message }), // 시스템 메시지 설정

  requestNightAction: (payload) => set({ nightAction: { required: true, payload: payload, chosenTargetId: null }, systemMessage: '밤 능력을 사용할 대상을 선택하세요.' }),
  clearNightAction: () => set({ nightAction: { required: false, payload: null, chosenTargetId: null } }),
  setNightActionTarget: (targetId) => set((state) => ({ nightAction: { ...state.nightAction, chosenTargetId: targetId } })),
  setScanResult: (result) => set({ scanResult: result }),

  startVoting: (options) => set({ isVotingPhase: true, voteOptions: options, systemMessage: '투표할 플레이어를 선택하세요.', votedPlayerId: null }),
  endVoting: () => set({ isVotingPhase: false, voteOptions: [], systemMessage: null }), // 투표 종료 시 메시지 제거
  setVotedPlayer: (playerId) => set({ votedPlayerId: playerId }),

  startTimer: (phase, duration) => set({ timer: { phase, duration, endTime: Date.now() + duration * 1000 } }),
  clearTimer: () => set({ timer: { phase: '', duration: 0, endTime: null } }),

  setGameOver: (winner, message, roles) => set({
      winner,
      systemMessage: message, // 게임 오버 메시지를 systemMessage 에 표시
      finalRoles: roles,
      phase: 'finished',
      isVotingPhase: false,
      timer: initialState.timer, // 타이머 초기화
      nightAction: initialState.nightAction, // 밤 행동 초기화
  }),

  resetStore: () => set({ ...initialState }), // 모든 상태를 초기값으로 리셋
}));
```

*   **`client/src/hooks/useWebSocket.ts`**

```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useCallback } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { ChatMessage, Player, ScanResult, NightActionPayload, FinalRoles } from '../types/game';

const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';

export const useWebSocket = (roomId: string | null, username: string | null, password?: string | null) => {
  const ws = useRef<WebSocket | null>(null);
  // Zustand 스토어 액션 가져오기
  const {
    setConnected, setInitialConnection, setPlayers, setPhase, setDayNumber, setRole, setIsHost,
    addChatMessage, setErrorMessage, setSystemMessage, requestNightAction, clearNightAction,
    setScanResult, startVoting, endVoting, startTimer, clearTimer, setGameOver,
    updatePlayerStatus, resetStore,
  } = useGameStore.getState(); // getState() 로 현재 액션 함수들 가져오기

  // 메시지 전송 함수
  const sendMessage = useCallback((message: object) => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message));
    } else {
      console.error("WebSocket is not connected.");
      setErrorMessage("서버에 연결되지 않았습니다.");
    }
  }, [setErrorMessage]); // setErrorMessage만 의존성으로 포함

  useEffect(() => {
    // roomId 나 username 이 없으면 연결 시도 안 함
    if (!roomId || !username) {
      if (ws.current) {
        console.log("Closing WebSocket connection due to missing info.");
        ws.current.close();
        ws.current = null;
        setConnected(false);
        resetStore();
      }
      return;
    }

    // 이미 연결되어 있다면 중복 연결 방지
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
        console.log("WebSocket already connected.");
        return;
    }

    const connectUrl = `${WS_URL}/${roomId}/${encodeURIComponent(username)}${password ? `?password=${encodeURIComponent(password)}` : ''}`;
    console.log("Attempting to connect to WebSocket:", connectUrl);
    ws.current = new WebSocket(connectUrl);
    let localWs = ws.current; // 클로저 내부에서 참조할 로컬 변수

    localWs.onopen = () => {
      console.log("WebSocket Connected");
      setConnected(true);
      setErrorMessage(null); // 연결 성공 시 에러 메시지 초기화
    };

    localWs.onclose = (event) => {
      console.log("WebSocket Disconnected:", event.reason, event.code);
      // 연결이 정상적으로 종료된 것이 아니라면 에러 메시지 설정
      if (localWs === ws.current) { // 현재 참조와 같은 경우에만 처리 (재연결 중복 방지)
          ws.current = null; // 참조 제거
          setConnected(false);
          if (event.code !== 1000 && event.code !== 1005) { // 1000: Normal Closure, 1005: No Status Rcvd
              setErrorMessage(event.reason || "서버와 연결이 끊어졌습니다.");
          } else if (event.code === 1008){ // Policy Violation (서버에서 명시적 거부)
              setErrorMessage(event.reason || "서버 연결 실패");
          }
          // 상태 초기화 (게임 상태 등)
          resetStore();
      }
    };

    localWs.onerror = (error) => {
      console.error("WebSocket Error:", error);
       if (localWs === ws.current) {
          ws.current = null;
          setConnected(false);
          setErrorMessage("WebSocket 연결 오류 발생");
          resetStore();
       }
    };

    localWs.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        console.log("Message from server:", message.type, message.payload);

        // Zustand 스토어 상태 업데이트 (useGameStore.setState 사용 또는 개별 액션 호출)
        const actions = useGameStore.getState(); // 최신 액션 함수 다시 가져오기

        switch (message.type) {
          case 'connected':
            actions.setInitialConnection(
                message.payload.room_id,
                message.payload.player_id,
                message.payload.username,
                message.payload.max_players
            );
            break;
          case 'player_list':
            actions.setPlayers(message.payload.players as Player[]);
            break;
          case 'game_state':
            actions.setPhase(message.payload.phase);
            actions.setDayNumber(message.payload.day);
            break;
          case 'role_info':
            actions.setRole(message.payload.role as Role);
            break;
          case 'chat':
            actions.addChatMessage(message.payload as ChatMessage);
            break;
          case 'system':
            // 시스템 메시지는 chat 에 추가하거나 별도 상태(systemMessage)로 관리
            actions.addChatMessage({ sender: 'System', message: message.payload.message });
            // actions.setSystemMessage(message.payload.message);
            break;
          case 'night_action_request':
             actions.requestNightAction(message.payload as NightActionPayload);
             break;
          case 'scan_result':
             actions.setScanResult(message.payload as ScanResult);
             // 스캔 결과 알림 (system message or chat)
             actions.addChatMessage({ sender: 'System', message: `스캔 결과: ${message.payload.scanned_player_name}님은 ${message.payload.is_ai ? 'AI 암살 로봇' : 'Human 팀'}입니다.` });
             break;
          case 'vote_start':
             actions.startVoting(message.payload.options as Player[]);
             break;
          case 'vote_end':
             actions.endVoting();
             break;
          case 'timer_start':
             actions.startTimer(message.payload.phase, message.payload.duration);
             break;
          case 'game_over':
             actions.setGameOver(
                 message.payload.winner,
                 message.payload.message,
                 message.payload.roles as FinalRoles
             );
             break;
           case 'error':
             actions.setErrorMessage(message.payload.message);
             break;
          default:
            console.warn("Unknown message type from server:", message.type);
        }
      } catch (error) {
        console.error("Failed to parse message or handle:", error);
      }
    };

    // Cleanup 함수: 컴포넌트 언마운트 시 WebSocket 연결 해제
    return () => {
      if (localWs) {
        console.log("Closing WebSocket connection on cleanup.");
        localWs.onopen = null;
        localWs.onmessage = null;
        localWs.onerror = null;
        localWs.onclose = null; // 이벤트 핸들러 제거
        if (localWs.readyState === WebSocket.OPEN || localWs.readyState === WebSocket.CONNECTING) {
             localWs.close(1000); // 정상 종료 코드
        }
      }
      if (localWs === ws.current) { // 현재 참조와 같을 때만 초기화
          ws.current = null;
          // resetStore(); // 언마운트 시 스토어 초기화 (선택적, App.tsx 에서 관리 중)
      }
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId, username, password]); // roomId, username, password 변경 시 재연결

  return { sendMessage };
};

```

*   **`client/src/App.tsx`** (이전과 거의 동일, username 저장 로직 개선)

```typescript
import React, { useState, useCallback, useEffect } from 'react';
import Lobby from './components/Lobby';
import Room from './components/Room';
import { useGameStore } from './stores/useGameStore';

function App() {
    // 로컬 스토리지에서 사용자 이름 불러오기
    const getInitialUsername = (): string => {
        return localStorage.getItem('username') || ''; // 없으면 빈 문자열 반환
    }

    const [currentView, setCurrentView] = useState<'lobby' | 'room'>('lobby');
    const [roomId, setRoomId] = useState<string | null>(null);
    const [username, setUsername] = useState<string>(getInitialUsername()); // 초기값 설정
    const [roomPassword, setRoomPassword] = useState<string | null>(null);
    const resetGameStore = useGameStore(state => state.resetStore);
    const storeRoomId = useGameStore(state => state.roomId); // 스토어의 roomId 감시

    // 사용자 이름 저장 함수 (Lobby 로 전달)
    const saveUsername = useCallback((name: string) => {
        localStorage.setItem('username', name);
        setUsername(name);
    }, []);

    // 방 참가 처리
    const handleJoinRoom = useCallback((joinedRoomId: string, joinedUsername: string, password?: string) => {
        setRoomId(joinedRoomId);
        saveUsername(joinedUsername); // 입장 시 이름 저장/갱신
        setRoomPassword(password || null);
        setCurrentView('room');
    }, [saveUsername]);

    // 방 나가기 처리
    const handleLeaveRoom = useCallback(() => {
        resetGameStore(); // Zustand 스토어 초기화
        setRoomId(null);
        setRoomPassword(null);
        setCurrentView('lobby');
        // WebSocket 연결 해제는 useWebSocket 훅의 cleanup 에서 처리됨
    }, [resetGameStore]);

    // 스토어 상태 변경 감지 (예: 웹소켓 끊김으로 roomId가 null이 될 때)
    useEffect(() => {
        if (currentView === 'room' && storeRoomId === null) {
            console.log("Detected room disconnect from store, returning to lobby.");
            handleLeaveRoom();
        }
    }, [storeRoomId, currentView, handleLeaveRoom]);

    return (
        <div className="App bg-background min-h-screen">
            {currentView === 'lobby' ? (
                <Lobby
                    onJoinRoom={handleJoinRoom}
                    initialUsername={username} // 초기 사용자 이름 전달
                    onUsernameChange={saveUsername} // 이름 변경 시 저장 함수 전달
                />
            ) : roomId && username ? (
                <Room
                    roomId={roomId}
                    username={username}
                    password={roomPassword}
                    onLeaveRoom={handleLeaveRoom}
                />
            ) : (
                 // 비정상 상태 -> 로비로
                 <Lobby
                     onJoinRoom={handleJoinRoom}
                     initialUsername={username}
                     onUsernameChange={saveUsername}
                 />
            )}
        </div>
    );
}

export default App;
```

*   **`client/src/components/Lobby.tsx`** (username 처리 로직 수정)

```typescript
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useForm } from 'react-hook-form';
import { Lock, PlusCircle, SignIn, Users } from 'phosphor-react';
import { RoomInfo } from '../types/game';
import Modal from './Modal';
import LoadingSpinner from './LoadingSpinner';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

interface CreateRoomFormData {
  name: string;
  max_players: number;
  password?: string;
  username: string; // Form 데이터에는 username 포함
}

interface LobbyProps {
  onJoinRoom: (roomId: string, username: string, password?: string) => void;
  initialUsername: string; // App 에서 관리하는 username
  onUsernameChange: (name: string) => void; // App 에 username 변경 알림
}

const Lobby: React.FC<LobbyProps> = ({ onJoinRoom, initialUsername, onUsernameChange }) => {
  const [rooms, setRooms] = useState<RoomInfo[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showPasswordModal, setShowPasswordModal] = useState(false);
  const [joiningRoom, setJoiningRoom] = useState<RoomInfo | null>(null);
  const [passwordInput, setPasswordInput] = useState('');
  const [usernameInput, setUsernameInput] = useState(initialUsername); // 내부 상태, 초기값은 props 로 받음

  const { register, handleSubmit, watch, reset, formState: { errors } } = useForm<CreateRoomFormData>({
    defaultValues: { max_players: 6, username: initialUsername } // 폼 기본값에도 초기 username 사용
  });

  // 입력 필드 변경 시 App의 상태 업데이트
  const handleUsernameInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const newUsername = e.target.value;
      setUsernameInput(newUsername);
      onUsernameChange(newUsername); // 변경사항을 App 컴포넌트로 전달하여 저장
  };

  const fetchRooms = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await axios.get(`${API_URL}/api/rooms`);
      setRooms(response.data);
    } catch (err) {
      console.error("Failed to fetch rooms:", err);
      setError("방 목록을 불러오는데 실패했습니다.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchRooms();
    const intervalId = setInterval(fetchRooms, 5000);
    return () => clearInterval(intervalId);
  }, []);

   // Create Room Modal 열릴 때 username 업데이트
   useEffect(() => {
       if(showCreateModal) {
           reset({ username: usernameInput, max_players: 6 }); // 모달 열 때 최신 username으로 폼 값 설정
       }
   }, [showCreateModal, usernameInput, reset]);


  const handleCreateRoomSubmit = async (data: CreateRoomFormData) => {
     // data.username 은 register 로 관리되므로 usernameInput 과 일치함
     if (!data.username.trim()) {
         setError("사용자 이름을 입력해야 방을 만들 수 있습니다.");
         return;
     }
     setIsLoading(true);
     setError(null);
     try {
       const payload = { ...data, password: data.password || null };
       const response = await axios.post(`${API_URL}/api/rooms`, payload);
       const { room_id } = response.data;
       setShowCreateModal(false);
       reset({ name: '', max_players: 6, password: '', username: data.username });
       onUsernameChange(data.username); // 이름 저장 (이미 되어있겠지만 확인차)
       onJoinRoom(room_id, data.username, data.password);
     } catch (err: any) {
       console.error("Failed to create room:", err);
       setError(err.response?.data?.detail || "방 생성 실패. 이름 중복 또는 서버 오류.");
     } finally {
       setIsLoading(false);
     }
  };

  const handleJoinClick = (room: RoomInfo) => {
     if (!usernameInput.trim()) {
         setError("참가할 사용자 이름을 입력하세요.");
         return;
     }
     onUsernameChange(usernameInput); // 입장 시도 시 이름 저장

    if (room.status !== 'waiting') { setError("이미 시작되었거나 종료된 방입니다."); return; }
    if (room.current_players >= room.max_players) { setError("방이 가득 찼습니다."); return; }

    if (room.is_private) {
      setJoiningRoom(room);
      setPasswordInput(''); // 비밀번호 입력 필드 초기화
      setShowPasswordModal(true);
    } else {
      onJoinRoom(room.id, usernameInput);
    }
  };

  const handlePasswordSubmit = () => {
    if (joiningRoom && usernameInput.trim()) {
      onJoinRoom(joiningRoom.id, usernameInput, passwordInput);
      setShowPasswordModal(false);
      setPasswordInput('');
      setJoiningRoom(null);
    } else if (!usernameInput.trim()) {
        setError("사용자 이름을 입력하세요.");
    }
  };

  return (
    <div className="container mx-auto p-4 sm:p-6 max-w-3xl">
        <div className="text-center mb-8">
            <h1 className="text-4xl font-bold text-primary mb-2">AI Assassin Robot</h1>
            <p className="text-lg text-text-secondary">Find the hidden AI among humans!</p>
        </div>

      {error && <div className="bg-red-800 text-white p-3 rounded mb-4 text-center animate-pulse">{error}</div>}

       {/* 사용자 이름 입력 */}
       <div className="mb-6">
           <label htmlFor="username" className="block text-lg text-secondary mb-2">Your Name:</label>
           <input
               type="text"
               id="username"
               value={usernameInput}
               onChange={handleUsernameInputChange}
               maxLength={15}
               className="w-full p-3 bg-card border border-gray-600 rounded focus:outline-none focus:ring-2 focus:ring-primary text-lg"
               placeholder="Enter your name for the game"
           />
       </div>

      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl text-secondary font-semibold">Available Rooms</h2>
        <button
          onClick={() => {
              if (!usernameInput.trim()) { setError("Please enter your name first to create a room."); return; }
              setError(null); // 이전 에러 클리어
              reset({username: usernameInput, max_players: 6}); // 폼 초기화 시 현재 이름 사용
              setShowCreateModal(true);
          }}
          className="bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded inline-flex items-center transition duration-200 disabled:opacity-50"
          disabled={isLoading || !usernameInput.trim()} // 이름 없으면 비활성화
        >
          <PlusCircle size={20} className="mr-2" />
          Create New Room
        </button>
      </div>

      {isLoading && rooms.length === 0 && <div className="text-center p-10"><LoadingSpinner message="Loading rooms..."/></div>}

      <div className="space-y-3 max-h-[60vh] overflow-y-auto pr-2 bg-card p-4 rounded-lg shadow-lg border border-gray-700">
        {rooms.length > 0 ? rooms.map((room) => (
          <div key={room.id} className="bg-background p-4 rounded-lg flex flex-col sm:flex-row justify-between items-center shadow-md hover:bg-gray-700 transition duration-150">
            <div className="flex items-center space-x-3 mb-2 sm:mb-0 w-full sm:w-auto">
               {room.is_private && <Lock size={20} className="text-yellow-400 flex-shrink-0" title="Private Room"/>}
               <span className="font-semibold text-lg truncate flex-grow min-w-0" title={room.name}>{room.name}</span>
               <span className={`text-xs font-medium px-2 py-0.5 rounded ${room.status === 'waiting' ? 'bg-green-700' : 'bg-red-700'}`}>{room.status}</span>
            </div>
            <div className="flex items-center space-x-4 w-full sm:w-auto justify-end">
              <span className="text-text-secondary inline-flex items-center" title="Players"> <Users size={18} className="mr-1"/> {room.current_players}/{room.max_players}</span>
              <button
                onClick={() => handleJoinClick(room)}
                className={`px-3 py-1 rounded transition duration-200 flex items-center ${
                  room.status !== 'waiting' || room.current_players >= room.max_players || !usernameInput.trim()
                    ? 'bg-gray-600 cursor-not-allowed text-gray-400'
                    : 'bg-secondary hover:bg-pink-600 text-white'
                }`}
                disabled={room.status !== 'waiting' || room.current_players >= room.max_players || !usernameInput.trim()}
                title={room.status !== 'waiting' ? 'Game in progress or finished' : room.current_players >= room.max_players ? 'Room full' : !usernameInput.trim() ? 'Enter your name first' : 'Join Room'}
              >
                <SignIn size={18} /> <span className="ml-1 hidden sm:inline">Join</span>
              </button>
            </div>
          </div>
        )) : (
           !isLoading && <p className="text-center text-text-secondary py-10">No available rooms. Why not create one?</p>
        )}
      </div>

      {/* 방 만들기 모달 */}
       <Modal isOpen={showCreateModal} onClose={() => setShowCreateModal(false)} title="Create New Room">
           <form onSubmit={handleSubmit(handleCreateRoomSubmit)} className="space-y-4">
               {/* username 은 hidden input 으로 전송 */}
               <input type="hidden" {...register("username")} value={usernameInput} />
               <div>
                   <label htmlFor="name" className="block text-sm font-medium text-text-secondary">Room Name</label>
                   <input
                       id="name"
                       {...register("name", { required: "Room name is required", minLength: { value: 2, message: "Min 2 chars"}, maxLength: { value: 20, message: "Max 20 chars"} })}
                       className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"
                   />
                   {errors.name && <p className="text-red-500 text-xs mt-1">{errors.name.message}</p>}
               </div>
               <div>
                   <label htmlFor="max_players" className="block text-sm font-medium text-text-secondary">Max Players (incl. AI, 4-10)</label>
                   <select
                       id="max_players"
                       {...register("max_players", { valueAsNumber: true })}
                       className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary appearance-none"
                   >
                       {[4, 5, 6, 7, 8, 9, 10].map(n => <option key={n} value={n}>{n} players</option>)}
                   </select>
               </div>
               <div>
                   <label htmlFor="password" className="block text-sm font-medium text-text-secondary">Password (Optional)</label>
                   <input
                       id="password"
                       type="password"
                       {...register("password", { minLength: { value: 4, message: "Min 4 chars" }, maxLength: { value: 20, message: "Max 20 chars"} })}
                       className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"
                       placeholder="Leave blank for public room"
                   />
                   {errors.password && <p className="text-red-500 text-xs mt-1">{errors.password.message}</p>}
               </div>
               <button
                   type="submit"
                   className="w-full bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded transition duration-200 disabled:opacity-50"
                   disabled={isLoading}
               >
                   {isLoading ? "Creating..." : "Create & Join"}
               </button>
                {error && <p className="text-red-500 text-center mt-2 text-sm">{error}</p>}
           </form>
       </Modal>


      {/* 비밀번호 입력 모달 */}
      <Modal isOpen={showPasswordModal} onClose={() => setShowPasswordModal(false)} title={`Enter Password for '${joiningRoom?.name}'`}>
         <div className="space-y-4">
           <p className="text-text-secondary">This room requires a password.</p>
           <input
             type="password"
             value={passwordInput}
             onChange={(e) => setPasswordInput(e.target.value)}
             className="w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"
             placeholder="Password"
             onKeyPress={(e) => e.key === 'Enter' && handlePasswordSubmit()} // Enter 키로 제출
           />
            {error && <p className="text-red-500 text-center text-sm">{error}</p>}
           <button
             onClick={handlePasswordSubmit}
             className="w-full bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded transition duration-200"
           >
             Enter Room
           </button>
         </div>
      </Modal>
    </div>
  );
};

export default Lobby;
```

*   **`client/src/components/Room.tsx`** (주요 게임 화면 로직)

```typescript
// src/components/Room.tsx
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { useWebSocket } from '../hooks/useWebSocket';
import PlayerList from './PlayerList';
import ChatWindow from './ChatWindow';
import ActionBar from './ActionBar';
import StatusDisplay from './StatusDisplay';
import LoadingSpinner from './LoadingSpinner';

interface RoomProps {
  roomId: string;
  username: string;
  password?: string | null;
  onLeaveRoom: () => void;
}

const Room: React.FC<RoomProps> = ({ roomId, username, password, onLeaveRoom }) => {
  // WebSocket 연결 훅 사용
  const { sendMessage } = useWebSocket(roomId, username, password);
  // Zustand 스토어에서 상태 가져오기
  const {
      isConnected, players, phase, dayNumber, role, isAlive, isHost,
      chatMessages, voteOptions, isVotingPhase, votedPlayerId, timer,
      errorMessage, systemMessage, winner, finalRoles, playerId,
      nightAction, scanResult, maxPlayers
  } = useGameStore();

  const [isLoadingClient, setIsLoadingClient] = useState(true); // 클라이언트 로딩 상태

  // 로딩 상태 관리: 연결되고 playerId 가 설정되면 로딩 완료
  useEffect(() => {
      if (isConnected && playerId) {
          setIsLoadingClient(false);
      }
      // 연결 끊김 또는 에러 시 처리 (App.tsx 에서도 처리 중이지만 여기서도 확인 가능)
       if (!isConnected && errorMessage) {
           // 로딩 중이 아니라면 에러 메시지 표시 후 로비 이동 유도
           if (!isLoadingClient) {
                console.error("Room component detected disconnection with error:", errorMessage);
                // alert(`Error: ${errorMessage}\nReturning to lobby.`);
                // onLeaveRoom(); // 강제 이동 시
           }
       }
  }, [isConnected, playerId, errorMessage, isLoadingClient, onLeaveRoom]);

  // 로딩 중 표시
  if (isLoadingClient && !errorMessage) {
       return (
           <div className="flex justify-center items-center h-screen bg-background">
               <LoadingSpinner message={`Connecting to room ${roomId}...`} />
           </div>
       );
   }

   // 연결 에러 발생 시
   if (errorMessage && !isConnected) { // 연결 실패 시 명확한 에러 화면
       return (
           <div className="flex flex-col justify-center items-center h-screen text-center p-4 bg-background">
               <p className="text-red-500 text-xl mb-4">{errorMessage}</p>
               <button onClick={onLeaveRoom} className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded">
                   Return to Lobby
               </button>
           </div>
       );
   }


  return (
    <div className="flex flex-col md:flex-row h-screen max-h-screen overflow-hidden bg-background text-text-primary">

      {/* Left Panel (Players & Status) */}
      <div className="w-full md:w-[280px] lg:w-[320px] bg-card p-3 sm:p-4 flex flex-col overflow-y-auto border-r border-gray-700 md:max-h-screen">
         {/* 방 정보 (선택적) */}
         {/* <h2 className="text-lg font-semibold text-primary mb-1">Room: {roomId}</h2> */}
         {/* 플레이어 목록 */}
         <h3 className="text-xl font-semibold text-secondary mb-3">Participants</h3>
         <PlayerList players={players} selfPlayerId={playerId} />

         {/* 상태 표시 (하단 고정) */}
         <div className="mt-auto pt-4 border-t border-gray-700">
            <StatusDisplay
               phase={phase}
               dayNumber={dayNumber}
               role={role}
               isAlive={isAlive}
               timer={timer}
               winner={winner}
               gameMessage={systemMessage} // systemMessage 를 게임 메시지로 사용
               scanResult={scanResult}
               finalRoles={finalRoles}
               selfUsername={username}
            />
         </div>
          <button
             onClick={onLeaveRoom}
             className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-2 rounded text-sm transition duration-150"
           >
             Leave Room
           </button>
      </div>

      {/* Right Panel (Chat & Actions) */}
      <div className="flex-1 flex flex-col max-h-screen overflow-hidden">
        {/* 채팅창 */}
        <ChatWindow messages={chatMessages} />

        {/* 액션 바 */}
        <ActionBar
          phase={phase}
          isAlive={isAlive}
          isHost={isHost}
          role={role}
          sendMessage={sendMessage}
          playersInRoom={players.length}
          maxPlayers={maxPlayers ?? 0} // maxPlayers 가 null 일 수 있음
          onLeaveRoom={onLeaveRoom}
          // 투표 관련 props
          isVotingPhase={isVotingPhase}
          voteOptions={voteOptions}
          votedPlayerId={votedPlayerId}
          // 밤 행동 관련 props
          nightActionRequired={nightAction.required}
          nightActionPayload={nightAction.payload}
          nightActionChosenTargetId={nightAction.chosenTargetId}
          // 게임 종료 관련 props
          winner={winner}
        />
      </div>
    </div>
  );
};

export default Room;
```

*   **`client/src/components/PlayerList.tsx`**

```typescript
// src/components/PlayerList.tsx
import React from 'react';
import { Player } from '../types/game';
import { User, Crown, Ghost, Robot } from 'phosphor-react'; // 아이콘 추가

interface PlayerListProps {
  players: Player[];
  selfPlayerId: string | null;
}

const PlayerList: React.FC<PlayerListProps> = ({ players, selfPlayerId }) => {
  return (
    <div className="space-y-2 flex-grow overflow-y-auto pr-1">
      {players.map((player) => (
        <div
          key={player.id}
          className={`flex items-center p-2 rounded transition duration-150 ${
            player.id === selfPlayerId ? 'bg-primary/20 border border-primary' : 'bg-background/50'
          } ${!player.is_alive ? 'opacity-50' : ''}`}
        >
          <div className={`mr-2 ${!player.is_alive ? 'text-gray-500' : 'text-secondary'}`}>
            {player.is_alive ? <User size={20} weight="fill" /> : <Ghost size={20} weight="fill" />}
          </div>
          <span className={`font-medium flex-grow truncate ${!player.is_alive ? 'line-through text-text-secondary' : ''}`}>
            {player.username} {player.id === selfPlayerId ? '(You)' : ''}
          </span>
          {player.is_host && (
            <Crown size={18} weight="fill" className="text-yellow-400 ml-2 flex-shrink-0" title="Host"/>
          )}
          {/* AI임을 표시하는 아이콘 (게임 종료 후 또는 디버그용) */}
          {/* {player.is_ai && <Robot size={18} weight="fill" className="text-red-500 ml-2 flex-shrink-0" title="AI"/>} */}
        </div>
      ))}
    </div>
  );
};

export default PlayerList;
```

*   **`client/src/components/ChatWindow.tsx`**

```typescript
// src/components/ChatWindow.tsx
import React, { useRef, useEffect } from 'react';
import { ChatMessage } from '../types/game';

interface ChatWindowProps {
  messages: ChatMessage[];
}

const ChatWindow: React.FC<ChatWindowProps> = ({ messages }) => {
  const chatEndRef = useRef<HTMLDivElement>(null);

  // 새 메시지 수신 시 자동 스크롤
  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const formatTimestamp = (timestamp?: number): string => {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  return (
    <div className="flex-1 bg-background p-4 overflow-y-auto mb-1 border-b border-gray-700">
      <div className="space-y-3">
        {messages.map((msg, index) => (
          <div key={index} className={`flex ${msg.sender === 'System' ? 'justify-center' : ''}`}>
             {msg.sender === 'System' ? (
                 <p className="text-center text-xs text-accent italic bg-gray-700 px-2 py-1 rounded-full max-w-xs sm:max-w-md">
                    {msg.message}
                 </p>
             ) : (
                <div className="flex flex-col max-w-[80%]">
                   <span className="text-xs text-text-secondary mb-0.5">
                     {msg.sender}
                     {/* <span className="ml-2 text-gray-500">{formatTimestamp(msg.timestamp)}</span> */}
                   </span>
                   <div className="bg-card p-2 rounded-lg shadow">
                      <p className="text-sm break-words">{msg.message}</p>
                   </div>
                </div>
             )}
          </div>
        ))}
      </div>
      <div ref={chatEndRef} /> {/* 스크롤 타겟 */}
    </div>
  );
};

export default ChatWindow;
```

*   **`client/src/components/ActionBar.tsx`** (핵심 인터페이스 로직)

```typescript
// src/components/ActionBar.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Player, Role, NightActionPayload } from '../types/game';
import { PaperPlaneTilt, Users, Hourglass, PersonSimpleRun, Play, GameController, Shield, Detective } from 'phosphor-react';
import { useGameStore } from '../stores/useGameStore'; // 스토어 접근

interface ActionBarProps {
  phase: GamePhase;
  isAlive: boolean;
  isHost: boolean;
  role: Role;
  sendMessage: (message: object) => void;
  playersInRoom: number;
  maxPlayers: number;
  onLeaveRoom: () => void;
  // Voting
  isVotingPhase: boolean;
  voteOptions: Player[];
  votedPlayerId: string | null;
  // Night Action
  nightActionRequired: boolean;
  nightActionPayload: NightActionPayload | null;
  nightActionChosenTargetId: string | null;
  // Game End
  winner: string | null;
}

const ActionBar: React.FC<ActionBarProps> = ({
  phase, isAlive, isHost, role, sendMessage, playersInRoom, maxPlayers, onLeaveRoom,
  isVotingPhase, voteOptions, votedPlayerId,
  nightActionRequired, nightActionPayload, nightActionChosenTargetId,
  winner
}) => {
  const [chatInput, setChatInput] = useState('');
  const [selectedTargetId, setSelectedTargetId] = useState<string | null>(null);
  const { setNightActionTarget } = useGameStore(); // 밤 액션 타겟 설정 액션

  // 밤 액션 타겟 선택 시 스토어 업데이트
   useEffect(() => {
       setNightActionTarget(selectedTargetId);
   }, [selectedTargetId, setNightActionTarget]);

  // 단계 변경 시 선택 초기화
  useEffect(() => {
      setSelectedTargetId(null);
  }, [phase]);


  const handleChatSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (chatInput.trim() && isAlive && phase !== 'night' && !winner) {
      sendMessage({ type: 'chat', payload: { message: chatInput.trim() } });
      setChatInput('');
    } else if (!isAlive) {
        // 관전 중 채팅 불가 알림 (선택적)
        console.log("Cannot chat while dead.");
    } else if (phase === 'night') {
         console.log("Cannot chat during the night.");
    }
  };

  const handleStartGame = () => {
    if (isHost && phase === 'waiting') {
      sendMessage({ type: 'start_game' });
    }
  };

  const handleVote = (targetId: string) => {
    if (isVotingPhase && isAlive && !votedPlayerId) {
      sendMessage({ type: 'vote', payload: { target_id: targetId } });
      // 스토어에 투표 기록은 서버 응답 없이 UI 피드백 용도로 즉시 반영 가능
      // useGameStore.getState().setVotedPlayer(targetId); // 서버 응답 기다리는 것이 더 정확
      setSelectedTargetId(null); // 투표 후 선택 해제
    }
  };

  const handleNightAction = () => {
    if (nightActionRequired && isAlive && selectedTargetId && nightActionPayload) {
        sendMessage({
            type: 'night_action',
            payload: {
                target_id: selectedTargetId,
                action_type: nightActionPayload.action_type // 'scan' or 'protect'
            }
        });
        // 능력 사용 후 UI 업데이트 (서버 응답 기다릴 수도 있음)
        // useGameStore.getState().clearNightAction(); // 성공 메시지 받은 후 클리어하는게 나을수도
        setSelectedTargetId(null); // 사용 후 선택 해제
    }
  };

  // 인원수 체크 (AI 포함)
  const requiredPlayers = maxPlayers;
  const canStartGame = playersInRoom === requiredPlayers;

  // --- UI 렌더링 ---
  return (
    <div className="bg-card p-3 sm:p-4 border-t border-gray-700">
      {/* 게임 종료 시 */}
      {winner && (
        <div className="text-center">
          <p className="text-xl font-bold mb-4">{winner === 'Human Team' ? '🏆 Humans Win!' : '🤖 AI Wins!'}</p>
          <button
            onClick={onLeaveRoom}
            className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded inline-flex items-center"
          >
            <PersonSimpleRun size={20} className="mr-2"/> Return to Lobby
          </button>
        </div>
      )}

      {/* 게임 대기 중 */}
      {phase === 'waiting' && !winner && (
        <div className="flex flex-col sm:flex-row items-center justify-between">
          <p className="text-text-secondary mb-2 sm:mb-0">
            Waiting for players... ({playersInRoom}/{requiredPlayers})
            <Users size={18} className="inline ml-1"/>
          </p>
          <button
            onClick={handleStartGame}
            disabled={!isHost || !canStartGame}
            className="bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed inline-flex items-center"
          >
             <Play size={20} className="mr-2"/>
             {isHost ? (canStartGame ? 'Start Game' : 'Waiting...') : 'Waiting for Host...'}
          </button>
        </div>
      )}

      {/* 게임 진행 중 (밤) */}
      {phase === 'night' && isAlive && !winner && (
         <div className="flex flex-col items-center">
            <p className="text-lg text-accent mb-3 animate-pulse">Night Phase: Use your ability</p>
            {nightActionRequired && nightActionPayload ? (
                <div className="w-full text-center">
                    <p className="mb-2 text-sm text-text-secondary">
                        {role === 'Scanner Droid' && <><Detective className="inline mr-1"/> Select a player to scan:</>}
                        {role === 'Repair Bot' && <><Shield className="inline mr-1"/> Select a player to protect:</>}
                    </p>
                    <div className="flex flex-wrap justify-center gap-2 mb-3 max-h-24 overflow-y-auto p-1">
                       {nightActionPayload.options.map(player => (
                           <button
                               key={player.id}
                               onClick={() => setSelectedTargetId(player.id)}
                               className={`px-3 py-1 rounded border text-sm transition duration-150 ${
                                   selectedTargetId === player.id
                                       ? 'bg-primary text-background border-primary ring-2 ring-primary'
                                       : 'bg-background hover:bg-gray-700 border-gray-600'
                               }`}
                           >
                               {player.username}
                           </button>
                       ))}
                    </div>
                    <button
                        onClick={handleNightAction}
                        disabled={!selectedTargetId}
                        className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed inline-flex items-center"
                    >
                         <GameController size={20} className="mr-2"/> Confirm Target
                    </button>
                </div>
            ) : (
                 role !== 'AI Assassin Robot' && <p className="text-text-secondary flex items-center"><Hourglass size={18} className="mr-1 animate-spin"/> Waiting for night to end...</p>
            )}
         </div>
      )}

       {/* 게임 진행 중 (낮 & 결과) - 채팅 가능 */}
       {(phase === 'day' || phase === 'results') && isAlive && !winner && (
           <form onSubmit={handleChatSubmit} className="flex items-center space-x-2">
               <input
                   type="text"
                   value={chatInput}
                   onChange={(e) => setChatInput(e.target.value)}
                   placeholder="Type your message..."
                   maxLength={100}
                   className="flex-grow p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"
               />
               <button type="submit" className="bg-primary hover:bg-cyan-600 text-background p-2 rounded">
                   <PaperPlaneTilt size={20} weight="fill"/>
               </button>
           </form>
       )}


       {/* 게임 진행 중 (투표) */}
       {isVotingPhase && isAlive && !winner && (
           <div className="mt-2">
               <p className="text-lg text-accent mb-3 text-center">Voting Phase: Choose who to eliminate!</p>
               <div className="flex flex-wrap justify-center gap-2 mb-3 max-h-32 overflow-y-auto p-1">
                   {voteOptions.map(player => (
                       <button
                           key={player.id}
                           onClick={() => handleVote(player.id)}
                           disabled={!!votedPlayerId} // 이미 투표했으면 비활성화
                           className={`px-3 py-1 rounded border text-sm transition duration-150 ${
                               votedPlayerId === player.id // 내가 투표한 대상 강조 (선택적)
                                   ? 'bg-red-700 text-white border-red-500'
                                   : votedPlayerId ? 'bg-gray-600 border-gray-700 text-gray-400 cursor-not-allowed' // 투표 완료 후 다른 버튼 비활성화
                                   : 'bg-background hover:bg-red-800 border-gray-600 hover:border-red-700'
                           }`}
                       >
                           {player.username}
                       </button>
                   ))}
               </div>
               {votedPlayerId && <p className="text-center text-green-400 text-sm">You voted for {voteOptions.find(p=>p.id === votedPlayerId)?.username}. Waiting for others...</p>}
           </div>
       )}

       {/* 관전 중 (사망 시) */}
       {!isAlive && phase !== 'finished' && (
           <p className="text-center text-text-secondary italic flex items-center justify-center">
              <Ghost size={18} className="mr-1"/> You are eliminated. Spectating the game...
           </p>
       )}

    </div>
  );
};

export default ActionBar;

```

*   **`client/src/components/StatusDisplay.tsx`** (게임 상태 및 역할 정보 표시)

```typescript
// src/components/StatusDisplay.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Role, ScanResult, FinalRoles } from '../types/game';
import { Sun, Moon, Hourglass, Person, Robot, Detective, Shield, Skull, Question, Trophy } from 'phosphor-react';

interface StatusDisplayProps {
  phase: GamePhase;
  dayNumber: number;
  role: Role;
  isAlive: boolean;
  timer: { phase: string; duration: number; endTime: number | null };
  winner: string | null;
  gameMessage: string | null; // 시스템 메시지 표시용
  scanResult: ScanResult | null; // 스캐너 결과
  finalRoles: FinalRoles | null; // 게임 종료 시 역할
  selfUsername: string | null; // 자기 이름 (finalRoles 에서 찾기 위함)
}

const getPhaseIcon = (phase: GamePhase) => {
    switch(phase) {
        case 'day': return <Sun size={20} className="text-yellow-400" />;
        case 'night': return <Moon size={20} className="text-indigo-400" />;
        case 'voting': return <Users size={20} className="text-orange-400" />; // 투표 아이콘 개선 가능
        case 'results': return <Hourglass size={20} className="text-gray-400" />;
        case 'finished': return <Trophy size={20} className="text-yellow-500" />;
        default: return <Hourglass size={20} className="text-gray-400" />;
    }
};

const getRoleIcon = (role: Role) => {
    switch(role) {
        case 'Human': return <Person size={20} className="text-green-400" />;
        case 'AI Assassin Robot': return <Robot size={20} className="text-red-500" />;
        case 'Scanner Droid': return <Detective size={20} className="text-blue-400" />;
        case 'Repair Bot': return <Shield size={20} className="text-teal-400" />;
        default: return <Question size={20} className="text-gray-400" />;
    }
};

const StatusDisplay: React.FC<StatusDisplayProps> = ({
  phase, dayNumber, role, isAlive, timer, winner, gameMessage, scanResult, finalRoles, selfUsername
}) => {
  const [timeLeft, setTimeLeft] = useState<number | null>(null);

  useEffect(() => {
    if (timer.endTime && timer.phase === phase) {
      const updateTimer = () => {
        const now = Date.now();
        const remaining = Math.max(0, Math.ceil((timer.endTime! - now) / 1000));
        setTimeLeft(remaining);
        if (remaining === 0) {
           setTimeLeft(null); // 타이머 종료
        }
      };
      updateTimer(); // 즉시 업데이트
      const intervalId = setInterval(updateTimer, 1000);
      return () => clearInterval(intervalId);
    } else {
      setTimeLeft(null); // 타이머 없거나 단계 안 맞으면 초기화
    }
  }, [timer, phase]);


  // 게임 종료 시 역할 정보 표시
  const renderFinalRoles = () => {
      if (!finalRoles) return null;
      return (
          <div className="mt-4 pt-4 border-t border-gray-600">
              <h4 className="text-lg font-semibold text-secondary mb-2">Final Roles:</h4>
              <ul className="space-y-1 text-sm max-h-40 overflow-y-auto pr-2">
                  {Object.entries(finalRoles).map(([username, playerRole]) => (
                      <li key={username} className={`flex items-center ${username === selfUsername ? 'font-bold text-primary' : ''}`}>
                          {getRoleIcon(playerRole as Role)}
                          <span className="ml-2">{username}: {playerRole}</span>
                      </li>
                  ))}
              </ul>
          </div>
      );
  };

  return (
    <div className="text-sm space-y-2">
      {/* 현재 단계 및 시간 */}
      <div className="flex justify-between items-center">
        <span className="flex items-center font-semibold">
           {getPhaseIcon(phase)}
           <span className="ml-2 capitalize">{phase === 'lobby' || phase === 'waiting' ? 'Waiting Area' : `Day ${dayNumber} - ${phase}`}</span>
        </span>
        {timeLeft !== null && timeLeft > 0 && (
           <span className="text-accent font-mono bg-background px-2 py-0.5 rounded">
              {String(Math.floor(timeLeft / 60)).padStart(2, '0')}:{String(timeLeft % 60).padStart(2, '0')}
           </span>
        )}
      </div>

      {/* 내 역할 및 상태 */}
       <div className="flex items-center">
          {isAlive ? getRoleIcon(role) : <Skull size={20} className="text-gray-500" />}
          <span className={`ml-2 ${!isAlive ? 'line-through text-gray-500' : ''}`}>
             Your Role: {role || 'Unknown'} {isAlive ? '' : '(Eliminated)'}
          </span>
       </div>

       {/* 스캐너 드로이드 결과 표시 */}
       {role === 'Scanner Droid' && scanResult && isAlive && (
           <div className="bg-blue-900/50 border border-blue-700 p-2 rounded text-xs">
              Last Scan: <span className="font-semibold">{scanResult.scanned_player_name}</span> is
              <span className={`font-bold ${scanResult.is_ai ? 'text-red-400' : 'text-green-400'}`}>
                 {scanResult.is_ai ? ' AI!' : ' Human Team.'}
              </span>
           </div>
       )}

       {/* 게임 메시지 (시스템 메시지 또는 게임 결과) */}
       {gameMessage && (
           <p className={`text-center font-semibold py-2 px-1 rounded ${
               winner ? (winner === 'Human Team' ? 'bg-green-800 text-green-100' : 'bg-red-800 text-red-100')
               : 'text-accent italic' // 일반 시스템 메시지 스타일
           }`}>
               {gameMessage}
           </p>
       )}


      {/* 게임 종료 시 역할 공개 */}
      {winner && renderFinalRoles()}

    </div>
  );
};

export default StatusDisplay;
```

*   **`client/src/components/Modal.tsx`** (이전과 동일)
*   **`client/src/components/LoadingSpinner.tsx`** (이전과 동일)
*   **`client/src/index.tsx`** (기본 React 진입점)

---

**3. 환경 설정 및 구동 방법**

1.  **사전 요구 사항:**
    *   **Python:** 3.8 이상 버전 설치
    *   **Node.js & npm (or yarn):** 최신 LTS 버전 권장

2.  **백엔드 설정:**
    *   터미널에서 `backend` 폴더로 이동합니다.
    *   **가상 환경 생성 (권장):**
        ```bash
        python -m venv venv
        source venv/bin/activate  # Linux/macOS
        # venv\Scripts\activate    # Windows
        ```
    *   **의존성 설치:**
        ```bash
        pip install -r requirements.txt
        ```
    *   **`.env` 파일 생성:** `backend` 폴더에 `.env` 파일을 만들고 다음 내용을 작성합니다. `YOUR_API_KEY_HERE` 부분을 Google AI Studio 에서 발급받은 Gemini API 키로 교체하세요.
        ```dotenv
        GEMINI_API_KEY=YOUR_API_KEY_HERE
        ```
        *   **주의:** Gemini API 키가 없거나 유효하지 않으면 AI 플레이어 기능(채팅, 밤 행동)이 작동하지 않습니다. 백엔드 실행 시 콘솔에 경고가 표시됩니다.

3.  **프론트엔드 설정:**
    *   터미널에서 `client` 폴더로 이동합니다.
    *   **의존성 설치:**
        ```bash
        npm install
        # 또는 yarn install
        ```
    *   **(선택적) `.env` 파일 생성:** `client` 폴더에 `.env` 파일을 만들고 백엔드 API 및 WebSocket 주소를 명시적으로 지정할 수 있습니다 (기본값은 `http://localhost:8000` 및 `ws://localhost:8000`).
        ```dotenv
        REACT_APP_API_URL=http://your-backend-address:8000
        REACT_APP_WS_URL=ws://your-backend-address:8000
        ```
        *   백엔드와 프론트엔드를 같은 머신에서 실행하면 이 파일은 필요 없을 수 있습니다. 다른 머신이나 Docker 등에서 실행 시 필요합니다.

4.  **애플리케이션 실행:**
    *   **백엔드 실행:** `backend` 폴더가 있는 터미널에서 (가상 환경 활성화 상태) 다음 명령어를 실행합니다.
        ```bash
        uvicorn main:app --host 0.0.0.0 --port 8000 --reload
        ```
        *   `--host 0.0.0.0` : 같은 네트워크의 다른 기기(예: 모바일)에서 접속하려면 필요합니다.
        *   `--reload` : 개발 중 코드를 수정하면 서버가 자동으로 재시작됩니다. 프로덕션 환경에서는 제외하세요.
    *   **프론트엔드 실행:** **별도의 터미널**에서 `client` 폴더로 이동한 후 다음 명령어를 실행합니다.
        ```bash
        npm start
        # 또는 yarn start
        ```
        *   이 명령어는 보통 `http://localhost:3000` 주소로 개발 서버를 실행하고 웹 브라우저를 자동으로 엽니다.

5.  **접속:**
    *   웹 브라우저에서 프론트엔드 개발 서버 주소(기본값: `http://localhost:3000`)로 접속하여 게임을 시작합니다.

6.  **CORS (Cross-Origin Resource Sharing):**
    *   `backend/main.py` 코드에 `CORSMiddleware` 설정이 포함되어 있습니다. `origins` 리스트에 프론트엔드 개발 서버 주소 (`http://localhost:3000`) 가 포함되어 있어야 로컬 개발 시 정상 통신이 가능합니다. 실제 서비스 배포 시에는 해당 서비스의 도메인 주소를 추가해야 합니다.

**참고:**

*   AI (Gemini) 기능은 API 키가 유효하고 인터넷 연결이 되어 있어야 작동합니다. API 사용량에 따라 비용이 발생할 수 있습니다.
*   인메모리 저장소를 사용하므로 백엔드 서버를 재시작하면 모든 방과 게임 상태가 초기화됩니다. 영구 저장이 필요하면 TinyDB, SQLite 또는 더 큰 규모의 데이터베이스 연동이 필요합니다.
*   이 코드는 기능 구현에 초점을 맞춘 예시이며, 실제 서비스 운영을 위해서는 보안 강화(비밀번호 해싱, 입력값 검증 등), 더 견고한 에러 처리, 상세한 로깅, 성능 최적화, 테스트 코드 작성 등이 필수적입니다.





네, 맞습니다!

제공해 드린 코드는 다음과 같이 동작하도록 설계되었습니다.

1.  **역할 배정:** 게임 시작 시(`start_game` 함수 내 `assign_roles` 함수), 참여한 플레이어들에게 역할을 무작위로 배정합니다. 이때 **정확히 1명**에게 **'AI Assassin Robot'** 역할이 주어집니다. 이 AI 역할은 **LLM (Gemini API)**을 통해 제어됩니다.
2.  **다른 플레이어:** 나머지 인간 플레이어들은 **'Scanner Droid'(경찰), 'Repair Bot'(의사), 'Human'(시민)** 역할을 나눠 갖게 됩니다.
3.  **AI 위장:** LLM 기반의 'AI Assassin Robot' 플레이어는 채팅 등을 통해 자신이 인간인 것처럼 행동하며 게임에 참여합니다. 다른 플레이어들은 누가 AI인지 알 수 없습니다.
4.  **인원수:** AI 플레이어도 게임의 총 인원수에 포함되어 계산됩니다. 예를 들어 '최대 6명' 방 설정은 5명의 인간 플레이어와 1명의 AI 플레이어로 구성됩니다.

따라서 사용자가 이해하신 대로, **여러 명의 인간 플레이어와 단 1개의 LLM 기반 마피아(AI 암살 로봇)가 섞여서 플레이하는 방식**이 맞습니다.






네, 이 게임에서 '경찰' 역할은 **스캐너 드로이드 (Scanner Droid)** 라는 이름으로 구현되어 있습니다.

**스캐너 드로이드 (Scanner Droid)의 역할:**

1.  **소속:** **Human Team (인간 팀)** 소속입니다. 목표는 다른 인간 플레이어들과 협력하여 AI 암살 로봇을 찾아내는 것입니다.
2.  **밤 능력 (Night Action):**
    *   **매일 밤**, 살아있는 다른 플레이어 **한 명을 선택**하여 **스캔(Scan)**할 수 있습니다. (자기 자신은 스캔할 수 없습니다.)
    *   스캔을 하면, 게임 시스템으로부터 선택한 플레이어가 **'AI 암살 로봇'인지 아닌지**에 대한 결과 정보를 **비밀리에** 받게 됩니다.
    *   **중요:** 스캔 결과는 단지 'AI 암살 로봇 여부'만 알려줍니다. 예를 들어, 스캔 대상이 'Repair Bot'이나 'Human'이어도 결과는 'AI 암살 로봇이 아님 (Human Team 소속)'으로 동일하게 나옵니다.
3.  **낮 목표 (Day Goal):**
    *   밤에 얻은 정보를 바탕으로 **낮 토론 시간**에 대화를 유리하게 이끌어갈 수 있습니다.
    *   누가 AI 암살 로봇인지 확신이 있다면, 다른 플레이어들을 설득하여 투표로 그 플레이어를 제거하도록 유도할 수 있습니다.
    *   하지만 자신의 정체('스캐너 드로이드'라는 것)를 너무 빨리 밝히면, AI 암살 로봇의 다음 밤 제거 대상 1순위가 될 위험이 매우 큽니다. 따라서 정보를 신중하게, 간접적으로 활용하는 전략이 필요합니다.
4.  **핵심 가치:** 스캐너 드로이드는 Human 팀에게 **가장 확실한 정보**를 제공할 수 있는 매우 중요한 역할입니다. 이 플레이어의 생존과 정보 활용 능력에 따라 게임의 승패가 크게 좌우될 수 있습니다.

요약하자면, **스캐너 드로이드(경찰)**는 밤에 다른 플레이어를 스캔하여 AI 여부를 알아내고, 이 정보를 활용하여 낮에 AI를 색출하는 데 도움을 주는 인간 팀의 핵심 정보원 역할입니다.










알겠습니다. 요청하신 대로 여러 명의 AI 암살 로봇(인간 플레이어 2명 + LLM 1명)과 사전 정의된 이름 풀에서 이름을 할당받는 방식, 그리고 AI 암살 로봇 간의 비밀 채팅 기능을 추가하여 전체 코드를 재구성하겠습니다.

**주요 변경 사항:**

1.  **이름 할당:** 모든 플레이어(인간, LLM)는 게임 참여 시 미리 정의된 `NAME_POOL`에서 무작위로 고유한 이름을 할당받습니다. 로비에서 닉네임을 직접 입력하는 방식은 사라집니다.
2.  **AI 역할 증가:** 'AI Assassin Robot' 역할이 총 3개로 늘어납니다. 이 중 1개는 LLM에게, 나머지 2개는 무작위로 선택된 인간 플레이어에게 할당됩니다. (최소 인원 요구 사항이 높아집니다. 예를 들어 7명 이상 권장)
3.  **비밀 AI 채팅:** 'AI Assassin Robot' 역할을 가진 플레이어들은 서로만 볼 수 있는 별도의 비밀 채팅 채널을 갖게 됩니다. UI는 탭 형식으로 구현합니다.
4.  **최소 인원:** 3명의 AI 역할을 포함하여 의미 있는 게임 진행을 위해 최소 인원 요구 사항이 높아집니다 (예: 4명 -> 6명 또는 7명).

**전체 폴더 구조**

```
ai-mafia-game-multi-ai/
├── backend/
│   ├── .env
│   ├── main.py
│   └── requirements.txt
└── client/
    ├── node_modules/
    ├── public/
    │   └── index.html
    ├── src/
    │   ├── App.tsx
    │   ├── components/
    │   │   ├── ActionBar.tsx      # 수정됨 (AI 채팅 입력 추가)
    │   │   ├── ChatInterface.tsx # 신규 (탭 및 채팅창 통합)
    │   │   ├── LoadingSpinner.tsx
    │   │   ├── Lobby.tsx          # 수정됨 (닉네임 입력 제거)
    │   │   ├── Modal.tsx
    │   │   ├── PlayerList.tsx
    │   │   ├── Room.tsx           # 수정됨 (ChatInterface 사용)
    │   │   └── StatusDisplay.tsx
    │   ├── hooks/
    │   │   └── useWebSocket.ts    # 수정됨 (ai_chat 처리 추가)
    │   ├── stores/
    │   │   └── useGameStore.ts    # 수정됨 (aiChatMessages 추가)
    │   ├── types/
    │   │   └── game.ts            # 수정됨 (AI 채팅 관련 타입 추가)
    │   ├── index.css
    │   └── index.tsx
    ├── .env
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    └── tsconfig.json
```

---

**1. 백엔드 (Python - FastAPI)**

*   **`backend/requirements.txt`** (이전과 동일)
*   **`backend/.env`** (이전과 동일)
*   **`backend/main.py`**

```python
import os
import asyncio
import json
import random
import uuid
from collections import defaultdict, Counter
from typing import Dict, List, Optional, Tuple, Any, Set

import google.generativeai as genai
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Query, Path, Body
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

load_dotenv()

# --- Gemini API 설정 ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    print("경고: GEMINI_API_KEY 환경 변수가 설정되지 않았습니다. AI 기능이 작동하지 않습니다.")
    gemini_model = None
else:
    genai.configure(api_key=GEMINI_API_KEY)
    try:
        gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')
        print("Gemini 모델 로드 성공.")
    except Exception as e:
        print(f"Gemini 모델 로드 실패: {e}. AI 기능이 작동하지 않을 수 있습니다.")
        gemini_model = None

# --- 이름 풀 정의 ---
NAME_POOL = [
    "Alex", "Byte", "Case", "Data", "Echo", "Flux", "Glitch", "Hash",
    "Icon", "Joule", "Kernel", "Logic", "Meta", "Nexus", "Oracle", "Pixel",
    "Query", "Rift", "Socket", "Trace", "Unit", "Vector", "Wave", "Xero",
    "Yotta", "Zetta", "Alpha", "Beta", "Gamma", "Delta", "Sigma", "Omega",
    "Cipher", "Core", "Digit", "Error", "Frame", "Ghost", "Host", "Input",
    "Jinx", "Key", "Link", "Mode", "Node", "Output", "Patch", "Queue",
    "Root", "Script", "Token", "User", "Virus", "Widget", "Xenon", "Yield",
    "Zone", "Bit", "Chip", "Daemon", "Edge", "Fiber"
] # 필요에 따라 더 추가

# --- 데이터 모델 ---
class Player(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    username: str # 서버에서 할당됨
    ws: Optional[WebSocket] = None
    role: Optional[str] = None # 'Human', 'AI Assassin Robot', 'Scanner Droid', 'Repair Bot'
    is_alive: bool = True
    is_ai: bool = False # LLM 기반 AI 여부
    is_human_ai: bool = False # AI 역할을 맡은 인간 플레이어 여부
    mimic_target_id: Optional[str] = None
    voted_for: Optional[str] = None
    night_action_target: Optional[str] = None
    last_scan_result: Optional[Dict[str, Any]] = None
    ai_teammates: List[str] = Field(default_factory=list) # AI 팀원 목록 (username)

    class Config:
        arbitrary_types_allowed = True

class Room(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    max_players: int
    password: Optional[str] = None
    players: Dict[str, Player] = Field(default_factory=dict)
    host_id: Optional[str] = None
    status: str = 'waiting'
    phase: str = 'day'
    day_number: int = 0
    # 밤 행동 결과
    ai_kill_requests: Dict[str, str] = Field(default_factory=dict) # {ai_player_id: target_id} 밤에 AI들이 죽이려 한 대상
    protected_player_id: Optional[str] = None
    scan_request_id: Optional[str] = None
    # 투표 및 채팅
    votes: Dict[str, str] = Field(default_factory=dict) # 낮 투표 집계용
    chat_history: List[Dict[str, str]] = Field(default_factory=list)
    ai_chat_history: List[Dict[str, str]] = Field(default_factory=list) # AI 비밀 채팅 기록
    # 기타 상태
    ai_player: Optional[Player] = None # LLM AI 플레이어 객체
    assigned_names: Set[str] = Field(default_factory=set) # 방에서 사용 중인 이름 추적
    night_actions_completed: Dict[str, bool] = Field(default_factory=dict)

    class Config:
        arbitrary_types_allowed = True

class Message(BaseModel):
    type: str
    payload: dict

# --- 인메모리 저장소 ---
rooms: Dict[str, Room] = {}
connections: Dict[str, WebSocket] = {}

# --- FastAPI 앱 생성 ---
app = FastAPI(title="AI Mafia Game API - Multi AI", version="1.1.0")

# --- CORS 설정 ---
origins = ["http://localhost:3000", "http://127.0.0.1:3000"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- WebSocket 관리 함수 ---
async def send_message(player_id: str, message: Message):
    # ... (이전과 동일) ...

async def broadcast(room_id: str, message: Message, exclude_player_id: Optional[str] = None):
    # ... (이전과 동일, AI 플레이어에게는 전송 안 함) ...

async def broadcast_to_role(room_id: str, role: str, message: Message, exclude_player_id: Optional[str] = None):
    """특정 역할을 가진 플레이어들에게만 메시지 브로드캐스트"""
    if room_id in rooms:
        room = rooms[room_id]
        message_dict = message.dict()
        tasks = []
        for player_id, player in room.players.items():
            # 해당 역할을 가졌고, 살아있고, 실제 연결된 플레이어이며, 제외 대상이 아닐 때
            if player.role == role and player.is_alive and player_id in connections and player_id != exclude_player_id:
                try:
                   tasks.append(connections[player_id].send_json(message_dict))
                except Exception as e:
                   print(f"Error broadcasting to role {role} player {player_id}: {e}")
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

# --- 이름 할당 함수 ---
def assign_unique_name(room: Room) -> str:
    """방에서 사용되지 않은 이름을 NAME_POOL에서 무작위로 선택하여 반환"""
    available_names = list(set(NAME_POOL) - room.assigned_names)
    if not available_names:
        # 풀 고갈 시 임시 이름 생성 (더 많은 이름 추가 권장)
        print(f"Warning: NAME_POOL exhausted for room {room.id}. Generating temporary name.")
        while True:
            temp_name = f"Player_{uuid.uuid4().hex[:4]}"
            if temp_name not in room.assigned_names:
                room.assigned_names.add(temp_name)
                return temp_name
    else:
        chosen_name = random.choice(available_names)
        room.assigned_names.add(chosen_name)
        return chosen_name

# --- LLM 관련 함수 ---
async def get_gemini_response(prompt: str) -> str:
    # ... (이전과 동일, LLM 미설정 시 기본 응답 포함) ...

async def get_ai_night_choice(ai_player: Player, room: Room) -> Optional[str]:
    """LLM AI의 밤 암살 대상 선택"""
    if not ai_player or not ai_player.is_alive: return None

    # AI 팀이 아닌 살아있는 플레이어 목록
    living_targets = [p for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot']
    if not living_targets: return None

    target_options = [p.username for p in living_targets]
    ai_username = ai_player.username

    # AI 팀원 목록 (LLM 제외)
    human_ai_teammates = [name for name in ai_player.ai_teammates if name != ai_username]

    prompt = f"""당신은 'AI 암살 로봇' 팀의 일원({ai_username})입니다. 당신의 정체는 다른 플레이어들에게 숨겨져 있습니다. 지금은 밤입니다.
당신의 AI 팀 동료는 {', '.join(human_ai_teammates) if human_ai_teammates else '없습니다'}.
제거해야 할 대상(인간 팀) 목록: {', '.join(target_options)}
이들 중 가장 위협적이거나, 정체를 파악했을 것 같거나, 혹은 단순히 제거하기 좋은 대상 한 명을 선택하세요. 답변은 오직 선택한 플레이어의 이름 하나만 포함해야 합니다.
예: Logic"""

    chosen_name = await get_gemini_response(prompt)

    for player in living_targets:
        if player.username == chosen_name:
            print(f"[AI Night Choice] LLM AI ({ai_username}) chose: {player.username}")
            return player.id

    print(f"[AI Night Choice] LLM AI response invalid ('{chosen_name}'). Choosing randomly among non-AI.")
    return random.choice(living_targets).id

async def get_ai_chat_message(ai_player: Player, room: Room):
    """LLM AI의 공개 채팅 메시지 생성 (인간인 척)"""
    if not gemini_model or not ai_player or not ai_player.is_alive: return

    recent_public_chats = room.chat_history[-15:]
    public_chat_log = "\n".join([f"{msg['sender']}: {msg['message']}" for msg in recent_public_chats])
    # LLM은 비밀 채팅도 참고할 수 있게 함 (선택적)
    # recent_ai_chats = room.ai_chat_history[-5:]
    # ai_chat_log = "\n".join([f"[{msg['sender']}]: {msg['message']}" for msg in recent_ai_chats])

    living_players_list = [p.username for p in room.players.values() if p.is_alive]
    my_pretend_role = "Human" # AI는 자신이 Human 인 척 함

    # 따라할 대상 선정 (AI 팀 아닌 살아있는 플레이어 중 랜덤)
    if not ai_player.mimic_target_id or ai_player.mimic_target_id not in room.players or \
       not room.players[ai_player.mimic_target_id].is_alive or \
       room.players[ai_player.mimic_target_id].role == 'AI Assassin Robot':
        living_non_ai_team = [p.id for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot' and p.id != ai_player.id]
        if living_non_ai_team:
            ai_player.mimic_target_id = random.choice(living_non_ai_team)
        else:
            ai_player.mimic_target_id = None

    mimic_target = room.players.get(ai_player.mimic_target_id)
    mimic_target_username = mimic_target.username if mimic_target else "다른 플레이어"

    prompt = f"""당신은 'AI 암살 로봇' 팀의 일원({ai_player.username})입니다. 하지만 다른 플레이어들에게는 당신의 역할이 '{my_pretend_role}'으로 보입니다. 절대 AI임을 드러내지 마세요.
현재 게임 단계는 '{room.phase}'입니다. 공개 채팅 채널에서 대화 중입니다. 당신의 목표는 들키지 않고 다른 플레이어들을 속여 살아남고 인간 팀을 제거하는 것입니다.
다른 플레이어들과 자연스럽게 대화하며 의심을 피해야 합니다. 너무 튀거나 어색하면 안됩니다.
가끔은 '{mimic_target_username}' 플레이어의 말투를 은근히 따라하며 인간처럼 보이도록 노력하세요.

최근 공개 채팅 기록:
{public_chat_log}

현재 살아있는 플레이어: {', '.join(living_players_list)}

이제 공개 채팅 채널에 현재 상황에 맞는 아주 평범하고 자연스러운 채팅 메시지를 짧게 1~2 문장으로 작성해주세요. 너무 직접적인 의심이나 공격은 피하세요.
"""
    # AI가 가끔 침묵하도록 (예: 25% 확률)
    if random.random() < 0.75:
        ai_message_content = await get_gemini_response(prompt)
        forbidden_words = ["AI", "로봇", "인공지능", "암살", "assassin", "robot", "LLM", "Gemini"]
        for word in forbidden_words:
            ai_message_content = ai_message_content.replace(word, "[CENSORED]") # 필터링

        if ai_message_content and ai_message_content != "...":
            chat_payload = {'sender': ai_player.username, 'message': ai_message_content}
            room.chat_history.append(chat_payload)
            await broadcast(room.id, Message(type='chat', payload=chat_payload)) # 공개 채팅으로 전송
            print(f"[AI Public Chat] LLM AI ({ai_player.username}): {ai_message_content}")
    else:
        print(f"[AI Public Chat] LLM AI ({ai_player.username}) decided to stay silent this time.")

# --- 게임 로직 ---
def assign_roles_multi_ai(players: List[Player], num_ai=3, num_scanner=1, num_repair=1) -> List[Player]:
    """다중 AI 역할 배정 로직"""
    num_players = len(players)
    # 최소 인원 충족 확인 (예: AI 3 + 스캐너 1 + 리페어 1 + 최소 Human 1 = 6명)
    if num_players < num_ai + num_scanner + num_repair:
        print(f"Error: Not enough players ({num_players}) to assign roles.")
        return [] # 역할 배정 실패

    llm_player = next((p for p in players if p.is_ai), None)
    if not llm_player:
        print("Error: LLM AI player not found during role assignment.")
        return []

    human_players = [p for p in players if not p.is_ai]
    random.shuffle(human_players)

    # 1. AI 역할 배정 (LLM 포함)
    ai_players = [llm_player] # LLM AI는 확정
    num_human_ai_needed = num_ai - 1
    if len(human_players) >= num_human_ai_needed:
        human_ai_players = human_players[:num_human_ai_needed]
        ai_players.extend(human_ai_players)
        human_players = human_players[num_human_ai_needed:] # AI 역할 배정된 인간 제외
    else:
        print("Error: Not enough human players to assign required AI roles.")
        return [] # 역할 배정 실패

    for player in ai_players:
        player.role = 'AI Assassin Robot'
        player.is_human_ai = not player.is_ai # 인간 AI 역할 여부 플래그 설정

    ai_teammate_names = [p.username for p in ai_players]
    for player in ai_players:
        player.ai_teammates = [name for name in ai_teammate_names if name != player.username] # 자신 제외 팀원 목록 저장

    print(f" > AI Assassin Robots ({len(ai_players)}): {[p.username for p in ai_players]}")

    # 2. 스캐너 드로이드 배정
    scanner_players = []
    if len(human_players) >= num_scanner:
        scanner_players = human_players[:num_scanner]
        human_players = human_players[num_scanner:]
        for player in scanner_players:
            player.role = 'Scanner Droid'
        print(f" > Scanner Droids ({len(scanner_players)}): {[p.username for p in scanner_players]}")
    else:
        print("Warning: Not enough players for Scanner Droid role.")


    # 3. 리페어 봇 배정
    repair_players = []
    if len(human_players) >= num_repair:
        repair_players = human_players[:num_repair]
        human_players = human_players[num_repair:]
        for player in repair_players:
            player.role = 'Repair Bot'
        print(f" > Repair Bots ({len(repair_players)}): {[p.username for p in repair_players]}")
    else:
         print("Warning: Not enough players for Repair Bot role.")

    # 4. 나머지 Human 배정
    for player in human_players:
        player.role = 'Human'
    print(f" > Humans ({len(human_players)}): {[p.username for p in human_players]}")

    # 모든 플레이어 리스트 반환 (역할 배정 완료)
    return players


async def start_game(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]

    MIN_PLAYERS = 6 # 최소 인원 조정 (AI 3명 포함)
    if len(room.players) < MIN_PLAYERS:
        await broadcast(room_id, Message(type='error', payload={'message': f'최소 {MIN_PLAYERS}명 이상 필요합니다. (현재 {len(room.players)}명)'}))
        return

    room.status = 'playing'
    room.day_number = 0
    room.chat_history = []
    room.ai_chat_history = []

    # --- LLM AI 플레이어 추가 (역할 배정 전) ---
    llm_ai_username = assign_unique_name(room) # LLM도 이름 풀에서 할당
    llm_ai_player = Player(username=llm_ai_username, is_ai=True) # is_ai=True 로 LLM 식별
    room.players[llm_ai_player.id] = llm_ai_player
    room.ai_player = llm_ai_player # LLM AI 객체 저장
    print(f"Room {room.name}: LLM AI Player '{llm_ai_player.username}' added.")

    # --- 역할 배정 ---
    player_list = list(room.players.values())
    assigned_players = assign_roles_multi_ai(player_list, num_ai=3) # 3명의 AI 역할 할당

    if not assigned_players: # 역할 배정 실패 시
        print(f"Error: Role assignment failed for room {room.id}.")
        await broadcast(room_id, Message(type='error', payload={'message': '역할 배정 오류 발생. 게임을 시작할 수 없습니다.'}))
        # LLM AI 플레이어 제거 및 상태 복구
        if llm_ai_player.id in room.players: del room.players[llm_ai_player.id]
        room.assigned_names.remove(llm_ai_username)
        room.ai_player = None
        room.status = 'waiting'
        return

    print(f"Game starting in room {room.name}. Total Players: {len(room.players)}")

    # 모든 플레이어 상태 초기화
    for player in room.players.values():
        player.is_alive = True
        player.voted_for = None
        player.night_action_target = None
        player.last_scan_result = None
        # is_human_ai 플래그는 assign_roles_multi_ai 에서 설정됨

    # 역할 정보 및 플레이어 목록 전송
    await update_player_list(room_id)
    for player_id, player in room.players.items():
         if player_id in connections: # 실제 접속한 플레이어에게만 전송
             role_info_payload = {
                 'role': player.role,
                 'ai_teammates': player.ai_teammates if player.role == 'AI Assassin Robot' else [] # AI 에게만 팀원 정보 전달
             }
             await send_message(player_id, Message(type='role_info', payload=role_info_payload))

    await broadcast(room_id, Message(type='system', payload={'message': f"게임 시작! {len(room.players)}명 중 숨어있는 3명의 AI 암살 로봇을 찾아내세요!"}))
    await start_night_phase(room_id)


async def check_win_condition(room_id: str):
    if room_id not in rooms: return False
    room = rooms[room_id]

    living_players = [p for p in room.players.values() if p.is_alive]
    living_ai_count = sum(1 for p in living_players if p.role == 'AI Assassin Robot')
    # AI 가 아닌 모든 역할 (Human, Scanner, Repair)을 Human 팀으로 간주
    living_human_team_count = len(living_players) - living_ai_count

    winner = None
    message = ""

    if living_ai_count == 0:
        winner = "Human Team"
        message = "모든 AI 암살 로봇을 찾아냈습니다! Human 팀 승리!"
    elif living_ai_count >= living_human_team_count:
        winner = "AI Assassin Robot Team" # 팀 명칭 변경
        message = "남은 Human 팀원의 수가 AI 암살 로봇의 수보다 적거나 같아졌습니다. AI 암살 로봇 팀 승리!"

    if winner:
        room.status = 'finished'
        final_roles = {p.username: p.role for p in room.players.values()}
        await broadcast(room_id, Message(type='game_over', payload={'winner': winner, 'message': message, 'roles': final_roles}))
        print(f"Game over in room {room.id}. Winner: {winner}")
        return True
    return False

async def start_night_phase(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]
    if await check_win_condition(room_id): return

    room.phase = 'night'
    room.day_number += 1
    # 밤 행동 관련 변수 초기화
    room.ai_kill_requests = {} # AI들의 암살 요청 초기화
    room.protected_player_id = None
    room.scan_request_id = None
    room.night_actions_completed = {}

    for player in room.players.values():
        player.night_action_target = None
        player.voted_for = None
        player.last_scan_result = None

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'night', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': f"Day {room.day_number}. 밤이 되었습니다. 각자 능력을 사용하세요."}))
    await broadcast_to_role(room_id, 'AI Assassin Robot', Message(type='system', payload={'message': "AI 채널: 암살 대상을 논의하고 지목하세요."}))


    # 밤 행동 요청 및 AI 행동 처리
    night_tasks = []
    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]
    living_non_ai_options = [opt for opt in living_players_options if room.players[opt['id']].role != 'AI Assassin Robot']

    # LLM AI 행동 예약
    if room.ai_player and room.ai_player.is_alive:
         room.night_actions_completed[room.ai_player.id] = False
         night_tasks.append(asyncio.create_task(process_llm_ai_night_action(room)))

    # 특수 역할 및 인간 AI 에게 행동 요청
    for player_id, player in room.players.items():
        if player.is_alive and player_id in connections: # 살아있는 실제 플레이어
             action_payload = {'options': []}
             request_needed = False
             action_type = None

             if player.role == 'AI Assassin Robot' and not player.is_ai: # 인간 AI
                  action_payload['options'] = living_non_ai_options # AI팀 제외 타겟 가능
                  action_type = 'assassinate'
                  request_needed = True
             elif player.role == 'Scanner Droid':
                  action_payload['options'] = [opt for opt in living_players_options if opt['id'] != player_id] # 자신 제외
                  action_type = 'scan'
                  request_needed = True
             elif player.role == 'Repair Bot':
                  action_payload['options'] = living_players_options # 자신 포함
                  action_type = 'protect'
                  request_needed = True

             if request_needed:
                 action_payload['action_type'] = action_type
                 room.night_actions_completed[player_id] = False # 행동 필요
                 night_tasks.append(send_message(player_id, Message(type='night_action_request', payload=action_payload)))

    # 밤 시간 제한 타이머 시작 (예: 45초 - AI 상의 시간 고려)
    night_duration = 45
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'night', 'duration': night_duration}))

    # 밤 시간 동안 대기하며 행동 완료 체크 (비동기)
    async def wait_for_night_actions():
        try:
            # 모든 필수 행동 주체 (AI 3명 + 스캐너 + 리페어봇) 가 완료할 때까지 대기
            await asyncio.wait_for(check_all_night_actions_done(room), timeout=night_duration)
            print(f"Room {room.id}: All required night actions seem completed.")
        except asyncio.TimeoutError:
            print(f"Room {room.id}: Night action timeout.")
        finally:
             if room.status == 'playing':
                await process_night_results(room_id) # 결과 처리 및 낮 시작

    night_tasks.append(asyncio.create_task(wait_for_night_actions()))
    if night_tasks:
        await asyncio.gather(*[task for task in night_tasks if isinstance(task, asyncio.Task)], return_exceptions=True)

async def process_llm_ai_night_action(room: Room):
     """LLM AI의 밤 암살 대상 선택 처리"""
     if not room.ai_player: return
     ai_target_id = await get_ai_night_choice(room.ai_player, room)
     if ai_target_id:
         room.ai_kill_requests[room.ai_player.id] = ai_target_id
         print(f"[Night Action] LLM AI ({room.ai_player.username}) requested kill target: {room.players[ai_target_id].username}")
     else:
         print("[Night Action] LLM AI did not choose a kill target.")
     room.night_actions_completed[room.ai_player.id] = True # LLM 행동 완료

async def check_all_night_actions_done(room: Room):
    """모든 필수 밤 역할 (AI 3명, 스캐너, 리페어)의 행동이 완료되었는지 체크"""
    while True:
        required_players = [p_id for p_id, p in room.players.items() if p.is_alive and p.role in ['AI Assassin Robot', 'Scanner Droid', 'Repair Bot']]

        if not required_players: break # 행동할 플레이어 없음

        current_completed = [p_id for p_id, done in room.night_actions_completed.items() if done]
        # print(f"DEBUG Night Check: Required={len(required_players)}, Completed={len(current_completed)}")
        
        if set(current_completed) >= set(required_players):
            break # 모두 완료

        if room.status != 'playing' or room.phase != 'night': break # 단계 변경 시 중단
        await asyncio.sleep(1)


async def process_night_results(room_id: str):
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'night': return

    print(f"Room {room.id}: Processing night results...")
    eliminated_player = None
    eliminated_player_info = "어젯밤, 아무 일도 일어나지 않았습니다."

    # 1. AI 암살 로봇 공격 결정 (다수결 또는 우선순위)
    ai_target_votes = Counter(room.ai_kill_requests.values())
    final_ai_target_id = None
    if ai_target_votes:
        # 가장 많이 지목된 대상 선택 (동점 시 랜덤 또는 무효)
        max_votes = max(ai_target_votes.values())
        candidates = [pid for pid, count in ai_target_votes.items() if count == max_votes]
        if len(candidates) == 1:
            final_ai_target_id = candidates[0]
        elif candidates: # 동점이면
             # final_ai_target_id = random.choice(candidates) # 동점 시 랜덤 선택
             final_ai_target_id = None # 동점 시 무효 처리 (더 안전)
             print(f" > AI kill vote tied between: {[room.players[pid].username for pid in candidates]}. No kill this night.")
        if final_ai_target_id:
             print(f" > AI team decided to target: {room.players.get(final_ai_target_id, Player(username='Unknown')).username}")


    # 2. 리페어 봇 보호 적용
    if room.protected_player_id:
        print(f" > Repair Bot protected: {room.players.get(room.protected_player_id, Player(username='Unknown')).username}")

    # 3. 최종 암살 처리
    if final_ai_target_id:
        target_player = room.players.get(final_ai_target_id)
        if target_player and target_player.is_alive:
            if final_ai_target_id == room.protected_player_id:
                eliminated_player_info = f"어젯밤, 누군가 공격받았지만 Repair Bot 덕분에 무사했습니다!"
                print(f" > AI target {target_player.username} was protected.")
                # 보호 성공 알림
                repair_bot = next((p for p in room.players.values() if p.role == 'Repair Bot'), None)
                if repair_bot and repair_bot.id in connections:
                    await send_message(repair_bot.id, Message(type='system', payload={'message': '밤 사이 당신의 보호로 누군가가 목숨을 구했습니다.'}))
            else:
                target_player.is_alive = False
                eliminated_player = target_player
                eliminated_player_info = f"어젯밤, {target_player.username}님이 공격당했습니다."
                print(f" > Player {target_player.username} was eliminated by AI team.")
        else:
            print(f" > AI final target ({final_ai_target_id}) was invalid or already dead.")


    # 4. 스캐너 드로이드 스캔 결과 처리/전송
    # ... (이전과 동일) ...
    scanner_droid = next((p for p in room.players.values() if p.role == 'Scanner Droid' and p.is_alive), None)
    if scanner_droid and room.scan_request_id:
        scanned_player = room.players.get(room.scan_request_id)
        if scanned_player:
            is_target_ai = scanned_player.role == 'AI Assassin Robot'
            scan_result_payload = {
                'scanned_player_id': scanned_player.id,
                'scanned_player_name': scanned_player.username,
                'is_ai': is_target_ai # AI 팀인지 여부 전달
            }
            scanner_droid.last_scan_result = scan_result_payload
            if scanner_droid.id in connections:
                 await send_message(scanner_droid.id, Message(type='scan_result', payload=scan_result_payload))
                 print(f" > Scanner Droid {scanner_droid.username} scanned {scanned_player.username}. Result: {'AI Team' if is_target_ai else 'Human Team'}")
        else:
            if scanner_droid.id in connections:
                 await send_message(scanner_droid.id, Message(type='system', payload={'message': '스캔 대상이 유효하지 않았습니다.'}))


    # 게임 종료 조건 체크
    if await check_win_condition(room_id): return

    # 낮 단계 시작
    room.phase = 'day'
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'day', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "낮이 밝았습니다."}))
    await broadcast(room_id, Message(type='system', payload={'message': eliminated_player_info}))

    if eliminated_player:
        await update_player_list(room_id)

    await start_discussion_phase(room_id) # 토론 시작


async def start_discussion_phase(room_id: str):
    # ... (이전과 동일, AI 채팅 트리거 포함) ...
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return

    discussion_time = 90 # 토론 시간 증가 (인원 증가 고려)
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'day', 'duration': discussion_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"토론 시간 {discussion_time}초 시작!"}))

    # LLM AI 채팅 활성화 (비동기)
    async def llm_ai_chat_during_day():
        start_time = asyncio.get_event_loop().time()
        end_time = start_time + discussion_time
        # 토론 시간 동안 2~3번 정도 랜덤하게 채팅 시도
        num_chats = random.randint(2, 3)
        chat_times = sorted([random.uniform(start_time + 10, end_time - 10) for _ in range(num_chats)])

        chat_tasks = []
        for chat_time in chat_times:
             delay = chat_time - asyncio.get_event_loop().time()
             if delay > 0:
                 chat_tasks.append(asyncio.create_task(schedule_llm_ai_chat(room, delay)))

        if chat_tasks:
           await asyncio.gather(*chat_tasks)

        # 토론 시간 종료 후 투표 시작 (타이머가 끝나면)
        remaining_time = end_time - asyncio.get_event_loop().time()
        if remaining_time > 0:
            await asyncio.sleep(remaining_time)

        if room.status == 'playing' and room.phase == 'day':
            await start_voting_phase(room_id)

    async def schedule_llm_ai_chat(room_obj: Room, delay: float):
         await asyncio.sleep(delay)
         if room_obj.status == 'playing' and room_obj.phase == 'day' and room_obj.ai_player and room_obj.ai_player.is_alive:
              await get_ai_chat_message(room_obj.ai_player, room_obj) # LLM AI의 공개 채팅 생성 함수 호출

    asyncio.create_task(llm_ai_chat_during_day())


async def start_voting_phase(room_id: str):
    # ... (이전과 동일) ...
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return
    if await check_win_condition(room_id): return

    room.phase = 'voting'
    room.votes = {}
    for player in room.players.values(): player.voted_for = None

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'voting', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "토론 시간이 종료되었습니다. 투표를 시작합니다."}))

    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]

    # 각 플레이어에게 자신 제외 투표 옵션 전송
    for voter_id, voter in room.players.items():
        if voter.is_alive and voter_id in connections: # 모든 살아있는 실제 플레이어에게 전송
            options_for_voter = [opt for opt in living_players_options if opt['id'] != voter_id]
            await send_message(voter_id, Message(type='vote_start', payload={'options': options_for_voter}))

    vote_time = 45 # 투표 시간 증가
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'voting', 'duration': vote_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"투표 시간 {vote_time}초! 의심되는 플레이어를 지목하세요."}))

    async def wait_for_vote_end():
        await asyncio.sleep(vote_time)
        if room.status == 'playing' and room.phase == 'voting':
           print(f"Room {room.id}: Vote time ended. Processing results.")
           await process_voting_results(room_id)

    asyncio.create_task(wait_for_vote_end())

async def process_voting_results(room_id: str):
    # ... (LLM 포함 모든 AI가 투표하도록 수정) ...
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.phase != 'voting' or room.status != 'playing': return

    room.phase = 'results'
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'results', 'day': room.day_number}))
    await broadcast(room_id, Message(type='vote_end', payload={}))

    # 모든 AI (LLM 포함)가 투표 (살아있는 인간 팀 중 랜덤 선택)
    living_human_team_ids = [p.id for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot']
    for ai_player in room.players.values():
        if ai_player.role == 'AI Assassin Robot' and ai_player.is_alive and not ai_player.voted_for: # 아직 투표 안 한 AI
             if living_human_team_ids:
                 ai_vote_target_id = random.choice(living_human_team_ids)
                 ai_player.voted_for = ai_vote_target_id
                 print(f"[AI Vote] AI ({ai_player.username}) voted for {room.players[ai_vote_target_id].username}")
             else:
                 print(f"[AI Vote] No living human team members for AI ({ai_player.username}) to vote for.")

    # 투표 집계 및 결과 처리 (이전과 동일)
    votes_cast = [p.voted_for for p in room.players.values() if p.is_alive and p.voted_for is not None]
    room.votes = Counter(votes_cast)

    vote_details = []
    for voter in room.players.values():
         if voter.is_alive and voter.voted_for:
             target_player = room.players.get(voter.voted_for)
             target_name = target_player.username if target_player else "Unknown"
             vote_details.append(f"{voter.username} -> {target_name}")
    vote_summary_msg = "투표 결과: " + ", ".join(vote_details) if vote_details else "투표 결과: 아무도 투표하지 않았습니다."
    await broadcast(room_id, Message(type='system', payload={'message': vote_summary_msg}))

    max_votes = 0
    eliminated_candidates = []
    if room.votes:
       valid_vote_counts = {target_id: count for target_id, count in room.votes.items() if target_id in room.players and room.players[target_id].is_alive}
       if valid_vote_counts:
          max_votes = max(valid_vote_counts.values())
          eliminated_candidates = [p_id for p_id, count in valid_vote_counts.items() if count == max_votes]

    result_message = ""
    eliminated_player = None
    if not eliminated_candidates or max_votes == 0:
         result_message = "투표 결과, 아무도 지목되지 않았습니다."
    elif len(eliminated_candidates) > 1:
        ties = [room.players[pid].username for pid in eliminated_candidates if pid in room.players]
        result_message = f"투표 결과 동점입니다: {', '.join(ties)}. 이번 투표는 무효 처리됩니다."
    else:
        eliminated_id = eliminated_candidates[0]
        if eliminated_id in room.players:
            eliminated_player = room.players[eliminated_id]
            eliminated_player.is_alive = False
            result_message = f"투표 결과, {eliminated_player.username} ({eliminated_player.role})님이 처형되었습니다."
            print(f"[Vote Result] Player {eliminated_player.username} eliminated by vote.")
            if await check_win_condition(room_id): return
        else: result_message = "투표 결과 처리 중 오류 발생."

    await broadcast(room_id, Message(type='system', payload={'message': result_message}))
    if eliminated_player: await update_player_list(room_id)

    await asyncio.sleep(5)
    if room.status == 'playing': await start_night_phase(room_id)


async def update_player_list(room_id: str):
    # ... (이전과 동일) ...
     if room_id in rooms:
        room = rooms[room_id]
        player_list_payload = [
            {'id': p.id, 'username': p.username, 'is_alive': p.is_alive, 'is_host': p.id == room.host_id}
            for p in room.players.values() # LLM AI 포함 모든 플레이어 정보 전송
        ]
        await broadcast(room_id, Message(type='player_list', payload={'players': player_list_payload}))

async def handle_player_disconnect(room_id: str, player_id: str):
    # ... (이름 반환 로직 추가) ...
    if player_id not in connections: return

    websocket = connections.pop(player_id, None)
    print(f"Player (ID: {player_id}) disconnected from room {room_id}")

    if room_id in rooms:
        room = rooms[room_id]
        if player_id in room.players:
            player = room.players.pop(player_id)
            # 할당되었던 이름 반환
            if player.username in room.assigned_names:
                room.assigned_names.remove(player.username)
                print(f" > Name '{player.username}' returned to pool.")

            # AI 플레이어 이탈 시 오류 처리 (이전과 동일)
            if player.is_ai:
                room.ai_player = None
                print(f"CRITICAL ERROR: LLM AI player {player.username} disconnected/removed.")
                # 게임 강제 종료 등 비상 로직
                await broadcast(room_id, Message(type='error', payload={'message': '게임 오류: AI 플레이어 연결 해제됨. 게임을 종료합니다.'}))
                room.status = 'finished'


            await broadcast(room_id, Message(type='system', payload={'message': f"{player.username}님이 나갔습니다."}))
            await update_player_list(room_id)

            # 호스트 변경 로직 (인간 플레이어 중에서)
            if room.host_id == player_id and room.players:
                 human_players = [p for p_id, p in room.players.items() if not p.is_ai and p_id in connections]
                 if human_players:
                     new_host = random.choice(human_players)
                     room.host_id = new_host.id
                     await broadcast(room_id, Message(type='system', payload={'message': f"{new_host.username}님이 새로운 방장이 되었습니다."}))
                     await update_player_list(room_id)
                 else: room.host_id = None

            # 게임 중 생존자 이탈 시 처리
            if room.status == 'playing' and player.is_alive:
                player.is_alive = False
                print(f"Player {player.username} left while alive during the game.")
                await update_player_list(room_id)
                if await check_win_condition(room_id): return

            # 방 정리 로직 (인간 플레이어 없으면 정리)
            human_player_exists = any(not p.is_ai for p_id, p in room.players.items() if p_id in connections)
            if not human_player_exists:
                 print(f"Room {room.id} has no human players left. Deleting.")
                 if room_id in rooms: del rooms[room_id] # 방 삭제


# --- API Endpoints ---
@app.get("/api/rooms", summary="Get list of available game rooms")
async def get_rooms_api(): # 함수 이름 변경 (get_rooms 와 겹침 방지)
    # ... (이전과 동일) ...
    room_list = []
    current_rooms = list(rooms.items())
    for room_id, room in current_rooms:
        # 방 유효성 체크 추가 (플레이어 없으면 제외 등)
        if not room.players: continue

        current_human_players = sum(1 for p_id, p in room.players.items() if not p.is_ai and p_id in connections)
        ai_player_count = sum(1 for p in room.players.values() if p.is_ai) # LLM AI 만 카운트 (인간 AI 는 players 에 포함됨)

        room_list.append({
            "id": room.id,
            "name": room.name,
            "current_players": current_human_players + ai_player_count,
            "max_players": room.max_players,
            "status": room.status,
            "is_private": bool(room.password)
        })
    return room_list

class CreateRoomRequest(BaseModel): # username 제거
    name: str = Field(..., min_length=2, max_length=20)
    # 최소 인원 6명으로 상향 조정 권장
    max_players: int = Field(..., ge=6, le=12, description="Max players (incl. 3 AIs, 6-12)")
    password: Optional[str] = Field(None, min_length=4, max_length=20)

@app.post("/api/rooms", summary="Create a new game room")
async def create_room_api(request: CreateRoomRequest): # 함수 이름 변경
    # ... (이전과 동일, username 관련 로직 없음) ...
     if any(r.name == request.name for r in rooms.values()):
        raise HTTPException(status_code=400, detail="Room name already exists.")

     room = Room(
        name=request.name,
        max_players=request.max_players,
        password=request.password
     )
     rooms[room.id] = room
     print(f"Room created: {room.name} (ID: {room.id}), Max Players: {room.max_players}, Private: {bool(room.password)}")
     return {"room_id": room.id}

# --- WebSocket Endpoint ---
@app.websocket("/ws/{room_id}") # username 제거
async def websocket_endpoint(websocket: WebSocket, room_id: str, password: Optional[str] = Query(None)):
    player_id = None
    player_name = None # 할당된 이름 저장용
    try:
        if room_id not in rooms:
            await websocket.close(code=1008, reason="Room not found")
            return

        room = rooms[room_id]

        if room.password and room.password != password:
            await websocket.close(code=1008, reason="Invalid password")
            return

        # 인원 수 확인 (LLM 제외 실제 접속자 기준)
        current_connections = len([p_id for p_id, p in room.players.items() if p_id in connections])
        # LLM AI 포함하여 최대 인원 계산
        max_allowed = room.max_players - 1 # LLM AI 자리 제외

        if room.status == 'waiting' and current_connections >= max_allowed:
             await websocket.close(code=1008, reason="Room is full")
             return
        if room.status != 'waiting':
            await websocket.close(code=1008, reason="Game already started or finished")
            return

        # --- 이름 할당 ---
        player_name = assign_unique_name(room)
        if not player_name: # 이름 할당 실패 시 (이론상 발생 안 함)
            await websocket.close(code=1011, reason="Failed to assign name")
            return

        # --- 플레이어 연결 성공 ---
        await websocket.accept()
        player = Player(username=player_name, ws=websocket) # 할당된 이름 사용
        player_id = player.id
        connections[player_id] = websocket
        room.players[player_id] = player

        if room.host_id is None: room.host_id = player_id

        print(f"Player {player_name} (ID: {player_id}) connected to room {room.name} ({room_id})")

        # 연결 성공 메시지 (할당된 이름 포함)
        await send_message(player_id, Message(type='connected', payload={
            'room_id': room.id, 'player_id': player_id, 'username': player_name, 'max_players': room.max_players
        }))

        await broadcast(room_id, Message(type='system', payload={'message': f"{player_name}님이 입장했습니다."}), exclude_player_id=player_id)
        await update_player_list(room_id)

        # 인원 충족 시 호스트에게 알림
        current_total_players = len(room.players) # LLM 포함 현재 플레이어 수
        if room.status == 'waiting' and current_total_players == room.max_players and room.host_id == player_id:
             await send_message(player_id, Message(type='system', payload={'message': f"인원이 모두 모였습니다 ({room.max_players}명). 게임을 시작할 수 있습니다!"}))


        # --- 메시지 수신 루프 ---
        while True:
            data = await websocket.receive_json()
            message = Message(**data)
            print(f"Received message from {player_name} (ID: {player_id}): {message.type}")

            if player_id not in room.players or player_id not in connections: break
            current_player = room.players[player_id]

            # --- 메시지 타입별 처리 ---
            if message.type == 'chat': # 공개 채팅
                msg_content = message.payload.get('message', '')[:100]
                if room.status == 'playing' and current_player.is_alive and room.phase != 'night':
                    chat_payload = {'sender': player_name, 'message': msg_content}
                    room.chat_history.append(chat_payload)
                    await broadcast(room.id, Message(type='chat', payload=chat_payload))
                elif room.status == 'waiting':
                    chat_payload = {'sender': player_name, 'message': msg_content}
                    await broadcast(room.id, Message(type='chat', payload=chat_payload))

            elif message.type == 'send_ai_chat': # AI 비밀 채팅
                 msg_content = message.payload.get('message', '')[:100]
                 # AI 역할이고 살아있을 때만 비밀 채팅 가능
                 if current_player.role == 'AI Assassin Robot' and current_player.is_alive:
                     ai_chat_payload = {'sender': player_name, 'message': msg_content}
                     room.ai_chat_history.append(ai_chat_payload)
                     # 다른 AI 팀원에게만 전송
                     await broadcast_to_role(room.id, 'AI Assassin Robot', Message(type='ai_chat', payload=ai_chat_payload), exclude_player_id=player_id)
                     # 본인에게도 확인용 전송 (선택적)
                     # await send_message(player_id, Message(type='ai_chat', payload=ai_chat_payload))
                 else:
                      await send_message(player_id, Message(type='error', payload={'message': 'AI 비밀 채팅을 보낼 권한이 없습니다.'}))


            elif message.type == 'start_game':
                if player_id == room.host_id and room.status == 'waiting':
                    # LLM 포함 전체 인원수 체크
                    if len(room.players) == room.max_players:
                         await start_game(room_id)
                    else:
                        await send_message(player_id, Message(type='error', payload={'message': f'인원이 부족합니다. ({len(room.players)}/{room.max_players}명)'}))
                # ... (이하 시작 불가 사유 처리 동일) ...

            elif message.type == 'vote': # 낮 투표
                # ... (이전과 동일, AI 투표는 서버 내부 처리) ...
                if room.phase == 'voting' and current_player.is_alive and not current_player.is_ai: # 인간 플레이어만 UI로 투표
                     target_id = message.payload.get('target_id')
                     if target_id == player_id: await send_message(player_id, Message(type='error', payload={'message': '자기 자신에게 투표할 수 없습니다.'}))
                     elif target_id in room.players and room.players[target_id].is_alive:
                         current_player.voted_for = target_id
                         print(f"[Vote] {player_name} voted for {room.players[target_id].username}")
                         await send_message(player_id, Message(type='system', payload={'message': f"{room.players[target_id].username}님에게 투표했습니다."}))
                         # 모든 인간 플레이어 투표 완료 체크
                         living_humans = [p for p_id, p in room.players.items() if p.is_alive and not p.is_ai and p_id in connections]
                         votes_cast_count = sum(1 for p in living_humans if p.voted_for is not None)
                         if votes_cast_count == len(living_humans):
                              print(f"Room {room.id}: All living humans voted. Processing results early.")
                              await asyncio.sleep(0.5)
                              if room.phase == 'voting': await process_voting_results(room_id)
                     else: await send_message(player_id, Message(type='error', payload={'message': '유효하지 않은 투표 대상입니다.'}))
                 # ... (이하 투표 불가 사유 처리 동일) ...


            elif message.type == 'night_action': # 밤 능력 사용 (인간 AI 암살 포함)
                if room.phase == 'night' and current_player.is_alive:
                    target_id = message.payload.get('target_id')
                    action_type = message.payload.get('action_type') # 'scan', 'protect', 'assassinate'

                    valid_target = target_id in room.players and room.players[target_id].is_alive
                    valid_action = False
                    fail_reason = "잘못된 대상 또는 액션입니다."

                    if current_player.role == 'Scanner Droid' and action_type == 'scan':
                        if target_id != player_id: valid_action = True
                        else: fail_reason = "자기 자신을 스캔할 수 없습니다."
                    elif current_player.role == 'Repair Bot' and action_type == 'protect':
                        valid_action = True # 자신 포함 가능
                    elif current_player.role == 'AI Assassin Robot' and not current_player.is_ai and action_type == 'assassinate': # 인간 AI의 암살 지목
                        # AI 팀이 아닌 대상만 공격 가능
                        if target_id in room.players and room.players[target_id].role != 'AI Assassin Robot': valid_action = True
                        else: fail_reason = "AI 팀원은 암살할 수 없습니다."

                    if valid_target and valid_action:
                        current_player.night_action_target = target_id
                        room.night_actions_completed[player_id] = True
                        print(f"[Night Action] {current_player.role} {player_name} used {action_type} on {room.players[target_id].username}")
                        await send_message(player_id, Message(type='system', payload={'message': f'{room.players[target_id].username}님에게 능력을 사용했습니다.'}))

                        # 밤 행동 완료 상태 업데이트
                        if action_type == 'scan': room.scan_request_id = target_id
                        elif action_type == 'protect': room.protected_player_id = target_id
                        elif action_type == 'assassinate': room.ai_kill_requests[player_id] = target_id

                    else: # 실패 시
                        if not valid_target: fail_reason = "선택한 대상이 유효하지 않습니다."
                        await send_message(player_id, Message(type='error', payload={'message': fail_reason}))
                # ... (이하 능력 사용 불가 사유 처리 동일) ...


    except WebSocketDisconnect:
        print(f"WebSocketDisconnect for player {player_name or 'Unknown'} (ID: {player_id})")
        if player_id: await handle_player_disconnect(room_id, player_id)
    except Exception as e:
        print(f"Error in WebSocket connection for {player_name or 'Unknown'} (ID: {player_id}): {e}")
        if player_id: await handle_player_disconnect(room_id, player_id)


if __name__ == "__main__":
    import uvicorn
    print("Starting AI Mafia Game Backend Server (Multi-AI Mode)...")
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

```

---

**2. 프론트엔드 (React + TypeScript + Zustand + Tailwind CSS)**

*   **`client/src/types/game.ts`** (수정됨)

```typescript
// src/types/game.ts
export interface Player {
  id: string;
  username: string; // Server assigned
  is_alive: boolean;
  is_host: boolean;
}

export interface RoomInfo {
  id: string;
  name: string;
  current_players: number;
  max_players: number;
  status: 'waiting' | 'playing' | 'finished';
  is_private: boolean;
}

export type Role = 'Human' | 'AI Assassin Robot' | 'Scanner Droid' | 'Repair Bot' | null;
export type GamePhase = 'lobby' | 'waiting' | 'night' | 'day' | 'voting' | 'results' | 'finished';

export interface ChatMessage {
  sender: string; // username
  message: string;
  timestamp?: number;
  isSelf?: boolean; // 내가 보낸 메시지인지 클라이언트에서 구분용
}

export interface ScanResult {
    scanned_player_id: string;
    scanned_player_name: string;
    is_ai: boolean; // Is part of the AI team
}

export interface NightActionPayload {
    options: Player[];
    action_type: 'scan' | 'protect' | 'assassinate'; // 암살 액션 추가
}

export interface FinalRoles {
    [username: string]: Role | string;
}

// AI 팀원 정보 추가
export interface RoleInfoPayload {
    role: Role;
    ai_teammates: string[]; // username list
}

export interface GameState {
  // Connection & Room Info
  isConnected: boolean;
  roomId: string | null;
  roomName?: string;
  maxPlayers: number | null;
  // Player Info
  playerId: string | null;
  username: string | null; // 내 이름 (서버 할당)
  role: Role;
  isAlive: boolean;
  isHost: boolean;
  aiTeammates: string[]; // 내 AI 팀원 목록
  // Game Status
  phase: GamePhase;
  dayNumber: number;
  players: Player[];
  // Interaction
  chatMessages: ChatMessage[];
  aiChatMessages: ChatMessage[]; // AI 비밀 채팅 메시지
  errorMessage: string | null;
  systemMessage: string | null;
  // Night Action
  nightAction: {
      required: boolean;
      payload: NightActionPayload | null;
      chosenTargetId: string | null;
  };
  scanResult: ScanResult | null;
  // Voting
  voteOptions: Player[];
  isVotingPhase: boolean;
  votedPlayerId: string | null;
  // Timer
  timer: {
      phase: string;
      duration: number;
      endTime: number | null;
  };
  // Game End
  winner: string | null; // 'Human Team', 'AI Assassin Robot Team'
  finalRoles: FinalRoles | null;
}
```

*   **`client/src/stores/useGameStore.ts`** (수정됨)

```typescript
// src/stores/useGameStore.ts
import create from 'zustand';
import { GameState, Role, Player, ChatMessage, ScanResult, NightActionPayload, FinalRoles, RoleInfoPayload } from '../types/game';

interface GameStoreActions {
  setConnected: (status: boolean) => void;
  setInitialConnection: (roomId: string, playerId: string, username: string, maxPlayers: number) => void;
  setPlayers: (players: Player[]) => void;
  updatePlayerStatus: (playerId: string, isAlive: boolean) => void;
  setRoleInfo: (payload: RoleInfoPayload) => void; // 역할 및 AI 팀원 정보 설정
  setIsHost: (isHost: boolean) => void;
  setPhase: (phase: GameState['phase']) => void;
  setDayNumber: (day: number) => void;
  addChatMessage: (message: ChatMessage) => void;
  addAiChatMessage: (message: ChatMessage) => void; // AI 채팅 추가 액션
  setErrorMessage: (message: string | null) => void;
  setSystemMessage: (message: string | null) => void;
  requestNightAction: (payload: NightActionPayload) => void;
  clearNightAction: () => void;
  setNightActionTarget: (targetId: string | null) => void;
  setScanResult: (result: ScanResult | null) => void;
  startVoting: (options: Player[]) => void;
  endVoting: () => void;
  setVotedPlayer: (playerId: string | null) => void;
  startTimer: (phase: string, duration: number) => void;
  clearTimer: () => void;
  setGameOver: (winner: string, message: string, roles: FinalRoles) => void;
  resetStore: () => void;
}

const initialState: GameState = {
  isConnected: false,
  roomId: null,
  maxPlayers: null,
  playerId: null,
  username: null,
  role: null,
  isAlive: true,
  isHost: false,
  aiTeammates: [], // AI 팀원 초기화
  phase: 'lobby',
  dayNumber: 0,
  players: [],
  chatMessages: [],
  aiChatMessages: [], // AI 채팅 초기화
  errorMessage: null,
  systemMessage: null,
  nightAction: { required: false, payload: null, chosenTargetId: null },
  scanResult: null,
  voteOptions: [],
  isVotingPhase: false,
  votedPlayerId: null,
  timer: { phase: '', duration: 0, endTime: null },
  winner: null,
  finalRoles: null,
};

export const useGameStore = create<GameState & GameStoreActions>((set, get) => ({
  ...initialState,

  setConnected: (status) => set({ isConnected: status }),
  setInitialConnection: (roomId, playerId, username, maxPlayers) => set({
    ...initialState,
    isConnected: true,
    roomId,
    playerId,
    username, // 서버에서 받은 이름 사용
    maxPlayers,
    phase: 'waiting',
  }),
  setPlayers: (players) => set((state) => {
      const me = players.find(p => p.id === state.playerId);
      return {
          players,
          isAlive: me ? me.is_alive : state.isAlive,
          isHost: me ? me.is_host : state.isHost,
      };
  }),
  updatePlayerStatus: (playerId, isAlive) => set((state) => ({
      players: state.players.map(p => p.id === playerId ? { ...p, is_alive: isAlive } : p),
      isAlive: state.playerId === playerId ? isAlive : state.isAlive,
  })),
  // 역할 정보 설정 (AI 팀원 포함)
  setRoleInfo: ({ role, ai_teammates }) => set({ role, aiTeammates: ai_teammates || [] }),
  setIsHost: (isHost) => set({ isHost }),
  setPhase: (phase) => set((state) => {
      const newState: Partial<GameState> = { phase };
      // ... (단계 변경 시 초기화 로직 동일) ...
      if (phase !== 'night') {
          newState.nightAction = { required: false, payload: null, chosenTargetId: null };
          newState.scanResult = null;
      }
      if (phase !== 'voting') {
          newState.isVotingPhase = false;
          newState.voteOptions = [];
          newState.votedPlayerId = null;
      }
      if (phase !== 'day' && phase !== 'voting' && phase !== 'night') {
          newState.timer = { phase: '', duration: 0, endTime: null };
      }
      newState.systemMessage = null;
      return newState;
  }),
  setDayNumber: (day) => set({ dayNumber: day }),
  addChatMessage: (message) => set((state) => ({
      chatMessages: [...state.chatMessages, { ...message, timestamp: Date.now(), isSelf: message.sender === state.username }].slice(-100),
  })),
  // AI 채팅 메시지 추가
  addAiChatMessage: (message) => set((state) => ({
      aiChatMessages: [...state.aiChatMessages, { ...message, timestamp: Date.now(), isSelf: message.sender === state.username }].slice(-50), // AI 채팅은 조금 덜 보관
  })),
  setErrorMessage: (message) => set({ errorMessage: message }),
  setSystemMessage: (message) => set({ systemMessage: message }),
  requestNightAction: (payload) => set({ nightAction: { required: true, payload: payload, chosenTargetId: null }, systemMessage: '밤 능력을 사용할 대상을 선택하세요.' }),
  clearNightAction: () => set({ nightAction: { required: false, payload: null, chosenTargetId: null } }),
  setNightActionTarget: (targetId) => set((state) => ({ nightAction: { ...state.nightAction, chosenTargetId: targetId } })),
  setScanResult: (result) => set({ scanResult: result }),
  startVoting: (options) => set({ isVotingPhase: true, voteOptions: options, systemMessage: '투표할 플레이어를 선택하세요.', votedPlayerId: null }),
  endVoting: () => set({ isVotingPhase: false, voteOptions: [], systemMessage: null }),
  setVotedPlayer: (playerId) => set({ votedPlayerId: playerId }),
  startTimer: (phase, duration) => set({ timer: { phase, duration, endTime: Date.now() + duration * 1000 } }),
  clearTimer: () => set({ timer: { phase: '', duration: 0, endTime: null } }),
  setGameOver: (winner, message, roles) => set({
      winner,
      systemMessage: message,
      finalRoles: roles,
      phase: 'finished',
      isVotingPhase: false,
      timer: initialState.timer,
      nightAction: initialState.nightAction,
      aiTeammates: [], // 게임 종료 시 팀원 정보 초기화
  }),
  resetStore: () => set({ ...initialState }),
}));

```

*   **`client/src/hooks/useWebSocket.ts`** (수정됨)

```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useCallback } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { ChatMessage, Player, ScanResult, NightActionPayload, FinalRoles, RoleInfoPayload } from '../types/game';

const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';

// Hook 인자에서 username 제거, 서버에서 할당받으므로
export const useWebSocket = (roomId: string | null, password?: string | null) => {
  const ws = useRef<WebSocket | null>(null);
  // ... (Zustand 액션 가져오는 부분 확장) ...
  const {
    setConnected, setInitialConnection, setPlayers, setPhase, setDayNumber, setRoleInfo, setIsHost,
    addChatMessage, addAiChatMessage, setErrorMessage, setSystemMessage, requestNightAction, clearNightAction,
    setScanResult, startVoting, endVoting, startTimer, clearTimer, setGameOver,
    updatePlayerStatus, resetStore,
  } = useGameStore.getState();

  const sendMessage = useCallback((message: object) => {
    // ... (이전과 동일) ...
  }, [setErrorMessage]);

  useEffect(() => {
    // roomId 가 없으면 연결 시도 안 함
    if (!roomId) {
        if (ws.current) { /* ... 연결 종료 로직 ... */ ws.current.close(); ws.current = null; setConnected(false); resetStore(); }
        return;
    }
    if (ws.current && ws.current.readyState === WebSocket.OPEN) return; // 중복 연결 방지

    // WebSocket URL 에서 username 제거
    const connectUrl = `${WS_URL}/${roomId}${password ? `?password=${encodeURIComponent(password)}` : ''}`;
    console.log("Attempting to connect to WebSocket:", connectUrl);
    ws.current = new WebSocket(connectUrl);
    let localWs = ws.current;

    localWs.onopen = () => { console.log("WebSocket Connected"); setConnected(true); setErrorMessage(null); };
    localWs.onclose = (event) => { /* ... 이전과 동일 (에러 처리 및 리셋) ... */ console.log("WebSocket Disconnected:", event.reason, event.code); if (localWs === ws.current) { ws.current = null; setConnected(false); if (event.code !== 1000 && event.code !== 1005) { setErrorMessage(event.reason || "서버와 연결이 끊어졌습니다."); } else if (event.code === 1008){ setErrorMessage(event.reason || "서버 연결 실패"); } resetStore(); }};
    localWs.onerror = (error) => { /* ... 이전과 동일 (에러 처리 및 리셋) ... */ console.error("WebSocket Error:", error); if (localWs === ws.current) { ws.current = null; setConnected(false); setErrorMessage("WebSocket 연결 오류 발생"); resetStore(); }};

    localWs.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        console.log("Message from server:", message.type); // 페이로드 로그 제외 (민감 정보 가능성)
        const actions = useGameStore.getState(); // 최신 액션

        switch (message.type) {
          case 'connected':
            actions.setInitialConnection(
                message.payload.room_id,
                message.payload.player_id,
                message.payload.username, // 서버에서 할당받은 이름 사용
                message.payload.max_players
            );
            break;
          case 'player_list': actions.setPlayers(message.payload.players as Player[]); break;
          case 'game_state': actions.setPhase(message.payload.phase); actions.setDayNumber(message.payload.day); break;
          // 역할 정보 처리 (AI 팀원 포함)
          case 'role_info': actions.setRoleInfo(message.payload as RoleInfoPayload); break;
          case 'chat': actions.addChatMessage(message.payload as ChatMessage); break;
          // AI 비밀 채팅 메시지 처리
          case 'ai_chat': actions.addAiChatMessage(message.payload as ChatMessage); break;
          case 'system': actions.addChatMessage({ sender: 'System', message: message.payload.message }); break; // 시스템 메시지도 채팅창에 표시
          case 'night_action_request': actions.requestNightAction(message.payload as NightActionPayload); break;
          case 'scan_result':
             actions.setScanResult(message.payload as ScanResult);
             actions.addChatMessage({ sender: 'System', message: `스캔 결과: ${message.payload.scanned_player_name}님은 ${message.payload.is_ai ? 'AI 팀' : 'Human 팀'}입니다.` });
             break;
          case 'vote_start': actions.startVoting(message.payload.options as Player[]); break;
          case 'vote_end': actions.endVoting(); break;
          case 'timer_start': actions.startTimer(message.payload.phase, message.payload.duration); break;
          case 'game_over':
             actions.setGameOver(
                 message.payload.winner,
                 message.payload.message,
                 message.payload.roles as FinalRoles
             );
             break;
           case 'error': actions.setErrorMessage(message.payload.message); break;
          default: console.warn("Unknown message type from server:", message.type);
        }
      } catch (error) { console.error("Failed to parse message or handle:", error); }
    };

    // Cleanup
    return () => { /* ... 이전과 동일 ... */ if (localWs) { console.log("Closing WebSocket connection on cleanup."); localWs.onopen = null; localWs.onmessage = null; localWs.onerror = null; localWs.onclose = null; if (localWs.readyState === WebSocket.OPEN || localWs.readyState === WebSocket.CONNECTING) { localWs.close(1000); } } if (localWs === ws.current) { ws.current = null; }};
  // roomId, password 변경 시 재연결
  }, [roomId, password, setConnected, setInitialConnection, setPlayers, setPhase, setDayNumber, setRoleInfo, addChatMessage, addAiChatMessage, setErrorMessage, setSystemMessage, requestNightAction, setScanResult, startVoting, endVoting, startTimer, setGameOver, resetStore]);

  return { sendMessage };
};
```

*   **`client/src/App.tsx`** (수정됨 - username 상태 제거)

```typescript
import React, { useState, useCallback, useEffect } from 'react';
import Lobby from './components/Lobby';
import Room from './components/Room';
import { useGameStore } from './stores/useGameStore';

function App() {
    const [currentView, setCurrentView] = useState<'lobby' | 'room'>('lobby');
    const [roomId, setRoomId] = useState<string | null>(null);
    // username 상태는 제거 -> 서버에서 할당받아 Zustand 스토어에 저장됨
    const [roomPassword, setRoomPassword] = useState<string | null>(null);
    const resetGameStore = useGameStore(state => state.resetStore);
    const storeRoomId = useGameStore(state => state.roomId); // 스토어의 roomId 감시
    const storeUsername = useGameStore(state => state.username); // 스토어의 username 감시

    // 방 참가 처리 (username 인자 제거)
    const handleJoinRoom = useCallback((joinedRoomId: string, password?: string) => {
        setRoomId(joinedRoomId);
        setRoomPassword(password || null);
        setCurrentView('room');
    }, []);

    // 방 나가기 처리
    const handleLeaveRoom = useCallback(() => {
        resetGameStore();
        setRoomId(null);
        setRoomPassword(null);
        setCurrentView('lobby');
    }, [resetGameStore]);

    // 스토어 상태 변경 감지
    useEffect(() => {
        // 연결 끊김 시 로비 이동
        if (currentView === 'room' && storeRoomId === null && !useGameStore.getState().isConnected) {
            console.log("Detected room disconnect from store, returning to lobby.");
            handleLeaveRoom();
        }
    }, [storeRoomId, currentView, handleLeaveRoom]);

    return (
        <div className="App bg-background min-h-screen">
            {currentView === 'lobby' ? (
                <Lobby onJoinRoom={handleJoinRoom} /> // username 관련 props 제거
            ) : roomId ? ( // roomId 만 있으면 Room 렌더링 시도 (username은 스토어에서 관리)
                <Room
                    roomId={roomId}
                    // username prop 제거 (useWebSocket 에서 스토어에 설정)
                    password={roomPassword}
                    onLeaveRoom={handleLeaveRoom}
                />
            ) : (
                 <Lobby onJoinRoom={handleJoinRoom} /> // 비정상 상태 -> 로비
            )}
        </div>
    );
}

export default App;

```

*   **`client/src/components/Lobby.tsx`** (수정됨 - username 입력 완전 제거)

```typescript
// src/components/Lobby.tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useForm } from 'react-hook-form';
import { Lock, PlusCircle, SignIn, Users } from 'phosphor-react';
import { RoomInfo } from '../types/game';
import Modal from './Modal';
import LoadingSpinner from './LoadingSpinner';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

// username 필드 제거
interface CreateRoomFormData {
  name: string;
  max_players: number;
  password?: string;
}

interface LobbyProps {
  // username 관련 props 제거
  onJoinRoom: (roomId: string, password?: string) => void;
}

const Lobby: React.FC<LobbyProps> = ({ onJoinRoom }) => {
  const [rooms, setRooms] = useState<RoomInfo[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showPasswordModal, setShowPasswordModal] = useState(false);
  const [joiningRoom, setJoiningRoom] = useState<RoomInfo | null>(null);
  const [passwordInput, setPasswordInput] = useState('');

  // username 제거
  const { register, handleSubmit, reset, formState: { errors } } = useForm<CreateRoomFormData>({
    defaultValues: { max_players: 7 } // 최소 인원 상향 고려
  });

  // ... fetchRooms (이전과 동일) ...
   const fetchRooms = async () => { /* ... */ };
   useEffect(() => { /* ... */ }, []);

  // handleCreateRoomSubmit 에서 username 제거
  const handleCreateRoomSubmit = async (data: CreateRoomFormData) => {
     setIsLoading(true);
     setError(null);
     try {
       const payload = { ...data, password: data.password || null };
       const response = await axios.post(`${API_URL}/api/rooms`, payload);
       const { room_id } = response.data;
       setShowCreateModal(false);
       reset({ name: '', max_players: 7, password: '' });
       // 방 생성 후 바로 입장 (username 없이)
       onJoinRoom(room_id, data.password);
     } catch (err: any) {
       console.error("Failed to create room:", err);
       setError(err.response?.data?.detail || "방 생성 실패.");
     } finally { setIsLoading(false); }
  };

  // handleJoinClick 에서 username 제거
  const handleJoinClick = (room: RoomInfo) => {
    setError(null); // 에러 초기화
    if (room.status !== 'waiting') { setError("이미 시작/종료된 방입니다."); return; }
    if (room.current_players >= room.max_players) { setError("방이 가득 찼습니다."); return; }

    if (room.is_private) {
      setJoiningRoom(room);
      setPasswordInput('');
      setShowPasswordModal(true);
    } else {
      onJoinRoom(room.id); // username 없이 호출
    }
  };

  // handlePasswordSubmit 에서 username 제거
  const handlePasswordSubmit = () => {
    if (joiningRoom) {
      onJoinRoom(joiningRoom.id, passwordInput); // username 없이 호출
      setShowPasswordModal(false);
      setPasswordInput('');
      setJoiningRoom(null);
    }
  };

  return (
    <div className="container mx-auto p-4 sm:p-6 max-w-3xl">
      <div className="text-center mb-8">
        <h1 className="text-4xl font-bold text-primary mb-2">AI Assassin Robot</h1>
        <p className="text-lg text-text-secondary">3 AIs hide among humans. Can you survive?</p>
      </div>

      {error && <div className="bg-red-800 text-white p-3 rounded mb-4 text-center animate-pulse">{error}</div>}

      {/* 사용자 이름 입력 필드 완전 제거 */}

      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl text-secondary font-semibold">Available Rooms</h2>
        <button
          onClick={() => { setError(null); reset(); setShowCreateModal(true); }} // reset() 으로 폼 초기화
          className="bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded inline-flex items-center transition duration-200 disabled:opacity-50"
          disabled={isLoading}
        >
          <PlusCircle size={20} className="mr-2" /> Create New Room
        </button>
      </div>

      {/* 방 목록 표시 (이전과 유사) */}
      {isLoading && rooms.length === 0 && <div className="text-center p-10"><LoadingSpinner message="Loading rooms..."/></div>}
      <div className="space-y-3 max-h-[60vh] overflow-y-auto pr-2 bg-card p-4 rounded-lg shadow-lg border border-gray-700">
        {rooms.length > 0 ? rooms.map((room) => (
          <div key={room.id} className="bg-background p-4 rounded-lg flex flex-col sm:flex-row justify-between items-center shadow-md hover:bg-gray-700 transition duration-150">
            {/* ... 방 정보 표시 ... */}
             <div className="flex items-center space-x-3 mb-2 sm:mb-0 w-full sm:w-auto">
               {room.is_private && <Lock size={20} className="text-yellow-400 flex-shrink-0" title="Private Room"/>}
               <span className="font-semibold text-lg truncate flex-grow min-w-0" title={room.name}>{room.name}</span>
               <span className={`text-xs font-medium px-2 py-0.5 rounded ${room.status === 'waiting' ? 'bg-green-700' : 'bg-red-700'}`}>{room.status}</span>
            </div>
             <div className="flex items-center space-x-4 w-full sm:w-auto justify-end">
               <span className="text-text-secondary inline-flex items-center" title="Players"> <Users size={18} className="mr-1"/> {room.current_players}/{room.max_players}</span>
               <button
                 onClick={() => handleJoinClick(room)}
                 className={`px-3 py-1 rounded transition duration-200 flex items-center ${
                   room.status !== 'waiting' || room.current_players >= room.max_players
                     ? 'bg-gray-600 cursor-not-allowed text-gray-400'
                     : 'bg-secondary hover:bg-pink-600 text-white'
                 }`}
                 disabled={room.status !== 'waiting' || room.current_players >= room.max_players}
                 title={room.status !== 'waiting' ? 'Game in progress/finished' : room.current_players >= room.max_players ? 'Room full' : 'Join Room'}
               >
                 <SignIn size={18} /> <span className="ml-1 hidden sm:inline">Join</span>
               </button>
             </div>
          </div>
        )) : (
           !isLoading && <p className="text-center text-text-secondary py-10">No rooms. Create one!</p>
        )}
      </div>

      {/* 방 만들기 모달 (username 필드 없음) */}
       <Modal isOpen={showCreateModal} onClose={() => setShowCreateModal(false)} title="Create New Room">
           <form onSubmit={handleSubmit(handleCreateRoomSubmit)} className="space-y-4">
               {/* 방 이름, 최대 인원, 비밀번호 입력 필드는 유지 */}
               <div>
                   <label htmlFor="name" className="block text-sm font-medium text-text-secondary">Room Name</label>
                   <input id="name" {...register("name", { required: "Required", minLength: 2, maxLength: 20 })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"/>
                   {errors.name && <p className="text-red-500 text-xs mt-1">{errors.name.message}</p>}
               </div>
               <div>
                   <label htmlFor="max_players" className="block text-sm font-medium text-text-secondary">Max Players (incl. 3 AIs, 6-12)</label>
                   <select id="max_players" {...register("max_players", { valueAsNumber: true })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary appearance-none">
                       {[6, 7, 8, 9, 10, 11, 12].map(n => <option key={n} value={n}>{n} players</option>)}
                   </select>
               </div>
                <div>
                    <label htmlFor="password" className="block text-sm font-medium text-text-secondary">Password (Optional)</label>
                    <input id="password" type="password" {...register("password", { minLength: 4, maxLength: 20 })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary" placeholder="Leave blank for public"/>
                    {errors.password && <p className="text-red-500 text-xs mt-1">{errors.password.message}</p>}
                </div>
               <button type="submit" className="w-full bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded transition" disabled={isLoading}>
                   {isLoading ? "Creating..." : "Create & Join"}
               </button>
                {error && <p className="text-red-500 text-center mt-2 text-sm">{error}</p>}
           </form>
       </Modal>

      {/* 비밀번호 입력 모달 (이전과 동일) */}
       <Modal isOpen={showPasswordModal} onClose={() => setShowPasswordModal(false)} title={`Enter Password for '${joiningRoom?.name}'`}>
         {/* ... */}
          <div className="space-y-4">
           <p className="text-text-secondary">This room requires a password.</p>
           <input type="password" value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)} className="w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary" placeholder="Password" onKeyPress={(e) => e.key === 'Enter' && handlePasswordSubmit()}/>
           <button onClick={handlePasswordSubmit} className="w-full bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded transition">Enter Room</button>
         </div>
       </Modal>
    </div>
  );
};

export default Lobby;
```

*   **`client/src/components/ChatInterface.tsx`** (신규 - 탭 및 채팅 UI 통합)

```typescript
// src/components/ChatInterface.tsx
import React, { useState, useRef, useEffect } from 'react';
import { ChatMessage, Role } from '../types/game';
import { PaperPlaneTilt, ChatCircleDots, EyeSlash } from 'phosphor-react'; // 아이콘 추가

interface ChatWindowProps {
  messages: ChatMessage[];
  title: string; // 탭 제목
}

// 내부 채팅창 컴포넌트
const ChatWindow: React.FC<ChatWindowProps> = ({ messages, title }) => {
  const chatEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="flex-1 bg-background p-3 sm:p-4 overflow-y-auto mb-1">
       {/* <h4 className="text-sm text-center text-gray-500 mb-2">{title}</h4> */}
       <div className="space-y-3">
            {messages.map((msg, index) => (
                <div key={`${title}-${index}`} className={`flex flex-col ${msg.isSelf ? 'items-end' : 'items-start'}`}>
                    {msg.sender === 'System' ? (
                        <p className="text-center text-xs text-accent italic bg-gray-700/50 px-2 py-1 rounded-full max-w-xs sm:max-w-md mx-auto">
                            {msg.message}
                        </p>
                    ) : (
                        <>
                            <span className={`text-xs mb-0.5 ${msg.isSelf ? 'text-primary' : 'text-text-secondary'}`}>
                                {msg.sender}
                            </span>
                            <div className={`p-2 rounded-lg shadow max-w-[85%] break-words ${msg.isSelf ? 'bg-primary/80 text-background' : 'bg-card'}`}>
                                <p className="text-sm">{msg.message}</p>
                            </div>
                        </>
                    )}
                </div>
            ))}
        </div>
      <div ref={chatEndRef} />
    </div>
  );
};


interface ChatInterfaceProps {
  role: Role;
  isAlive: boolean;
  phase: GameState['phase'];
  publicMessages: ChatMessage[];
  aiMessages: ChatMessage[];
  sendMessage: (message: object) => void; // sendMessage prop 추가
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
    role, isAlive, phase, publicMessages, aiMessages, sendMessage
}) => {
  const [activeTab, setActiveTab] = useState<'public' | 'ai'>('public');
  const [chatInput, setChatInput] = useState('');
  const [aiChatInput, setAiChatInput] = useState('');
  const isAIPlayer = role === 'AI Assassin Robot';

  const handleChatSubmit = (e: React.FormEvent, channel: 'public' | 'ai') => {
    e.preventDefault();
    const input = channel === 'public' ? chatInput : aiChatInput;
    const type = channel === 'public' ? 'chat' : 'send_ai_chat';

    // 공개 채팅: 살아있고, 밤 아니고, 게임 중일 때 가능
    // AI 채팅: 살아있고, AI 역할일 때만 가능 (단계 무관하게 가능하도록?)
    const canSendPublic = isAlive && phase !== 'night' && phase !== 'finished' && phase !== 'lobby' && phase !== 'waiting';
    const canSendAI = isAlive && isAIPlayer;

    if (input.trim() && ((channel === 'public' && canSendPublic) || (channel === 'ai' && canSendAI))) {
      sendMessage({ type, payload: { message: input.trim() } });
      if (channel === 'public') {
        setChatInput('');
      } else {
        setAiChatInput('');
      }
    } else {
        // 전송 불가 사유 로그 (필요시 사용자에게 피드백)
        console.log(`Cannot send ${channel} chat now. Alive: ${isAlive}, Phase: ${phase}, Role: ${role}`);
    }
  };

  return (
    <div className="flex-1 flex flex-col max-h-screen overflow-hidden">
        {/* 탭 버튼 (AI 역할일 때만 보임) */}
        {isAIPlayer && (
            <div className="flex border-b border-gray-700 bg-card">
                <button
                    onClick={() => setActiveTab('public')}
                    className={`flex-1 py-2 px-4 text-sm font-medium flex items-center justify-center transition duration-150 ${
                        activeTab === 'public' ? 'bg-background text-primary border-b-2 border-primary' : 'text-text-secondary hover:bg-gray-700'
                    }`}
                >
                   <ChatCircleDots size={16} className="mr-1"/> Public Channel
                </button>
                <button
                    onClick={() => setActiveTab('ai')}
                    className={`flex-1 py-2 px-4 text-sm font-medium flex items-center justify-center transition duration-150 ${
                        activeTab === 'ai' ? 'bg-background text-red-500 border-b-2 border-red-500' : 'text-text-secondary hover:bg-gray-700'
                    }`}
                >
                   <EyeSlash size={16} className="mr-1"/> AI Channel (Secret)
                </button>
            </div>
        )}

        {/* 채팅창 */}
        {(!isAIPlayer || activeTab === 'public') && (
            <ChatWindow messages={publicMessages} title="Public Chat" />
        )}
        {isAIPlayer && activeTab === 'ai' && (
            <ChatWindow messages={aiMessages} title="AI Secret Channel" />
        )}

        {/* 입력 영역 */}
        <div className="bg-card p-3 sm:p-4 border-t border-gray-700">
            {/* 공개 채팅 입력 */}
            {(!isAIPlayer || activeTab === 'public') && (
                <form onSubmit={(e) => handleChatSubmit(e, 'public')} className="flex items-center space-x-2">
                   <input
                       type="text"
                       value={chatInput}
                       onChange={(e) => setChatInput(e.target.value)}
                       placeholder={isAlive && phase !== 'night' && phase !== 'finished' && phase !== 'lobby' && phase !== 'waiting' ? "Public message..." : "Chat unavailable"}
                       maxLength={100}
                       className="flex-grow p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary disabled:opacity-50"
                       disabled={!isAlive || phase === 'night' || phase === 'finished' || phase === 'lobby' || phase === 'waiting'}
                   />
                   <button
                       type="submit"
                       className="bg-primary hover:bg-cyan-600 text-background p-2 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                       disabled={!isAlive || phase === 'night' || phase === 'finished' || phase === 'lobby' || phase === 'waiting'}
                   >
                       <PaperPlaneTilt size={20} weight="fill"/>
                   </button>
               </form>
            )}
             {/* AI 비밀 채팅 입력 */}
            {isAIPlayer && activeTab === 'ai' && (
                 <form onSubmit={(e) => handleChatSubmit(e, 'ai')} className="flex items-center space-x-2">
                   <input
                       type="text"
                       value={aiChatInput}
                       onChange={(e) => setAiChatInput(e.target.value)}
                       placeholder={isAlive ? "Secret AI message..." : "Chat unavailable"}
                       maxLength={100}
                       className="flex-grow p-2 bg-background border border-red-700 rounded focus:outline-none focus:border-red-500 disabled:opacity-50"
                       disabled={!isAlive} // 살아있으면 항상 가능하도록 (단계 무관)
                   />
                   <button
                       type="submit"
                       className="bg-red-600 hover:bg-red-700 text-white p-2 rounded disabled:opacity-50 disabled:cursor-not-allowed"
                       disabled={!isAlive}
                   >
                       <PaperPlaneTilt size={20} weight="fill"/>
                   </button>
               </form>
            )}
        </div>
    </div>
  );
};

export default ChatInterface;

```

*   **`client/src/components/Room.tsx`** (수정됨 - ChatInterface 사용)

```typescript
// src/components/Room.tsx
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { useWebSocket } from '../hooks/useWebSocket';
import PlayerList from './PlayerList';
// import ChatWindow from './ChatWindow'; // 제거
import ChatInterface from './ChatInterface'; // 새로 임포트
import ActionBar from './ActionBar';
import StatusDisplay from './StatusDisplay';
import LoadingSpinner from './LoadingSpinner';

interface RoomProps {
  roomId: string;
  // username prop 제거
  password?: string | null;
  onLeaveRoom: () => void;
}

const Room: React.FC<RoomProps> = ({ roomId, password, onLeaveRoom }) => {
  // useWebSocket 호출 시 username 제거
  const { sendMessage } = useWebSocket(roomId, password);
  const {
      isConnected, players, phase, dayNumber, role, isAlive, isHost, username, // 스토어에서 username 가져옴
      chatMessages, aiChatMessages, voteOptions, isVotingPhase, votedPlayerId, timer,
      errorMessage, systemMessage, winner, finalRoles, playerId,
      nightAction, scanResult, maxPlayers, aiTeammates // aiTeammates 추가
  } = useGameStore();

  const [isLoadingClient, setIsLoadingClient] = useState(true);

  useEffect(() => {
      if (isConnected && playerId && username) { // username 까지 받아와야 로딩 완료
          setIsLoadingClient(false);
      }
       // ... (연결 끊김 처리 로직 동일) ...
        if (!isConnected && errorMessage) { if (!isLoadingClient) { /* ... */ } }
  }, [isConnected, playerId, username, errorMessage, isLoadingClient, onLeaveRoom]);

  // 로딩 및 에러 처리 (이전과 동일)
   if (isLoadingClient && !errorMessage) { /* ... LoadingSpinner ... */ }
   if (errorMessage && !isConnected) { /* ... Error Display ... */ }


  return (
    <div className="flex flex-col md:flex-row h-screen max-h-screen overflow-hidden bg-background text-text-primary">
      {/* Left Panel (Players & Status) */}
       <div className="w-full md:w-[280px] lg:w-[320px] bg-card p-3 sm:p-4 flex flex-col overflow-y-auto border-r border-gray-700 md:max-h-screen">
         {/* ... (PlayerList, StatusDisplay 부분 동일) ... */}
         <h3 className="text-xl font-semibold text-secondary mb-3">Participants</h3>
         <PlayerList players={players} selfPlayerId={playerId} />
         <div className="mt-auto pt-4 border-t border-gray-700">
            <StatusDisplay
               phase={phase}
               dayNumber={dayNumber}
               role={role}
               isAlive={isAlive}
               timer={timer}
               winner={winner}
               gameMessage={systemMessage}
               scanResult={scanResult}
               finalRoles={finalRoles}
               selfUsername={username} // username 전달
               aiTeammates={aiTeammates} // AI 팀원 정보 전달
            />
         </div>
          <button onClick={onLeaveRoom} className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-2 rounded text-sm transition">Leave Room</button>
       </div>

      {/* Right Panel (Chat & Actions) */}
       <div className="flex-1 flex flex-col max-h-screen overflow-hidden">
           {/* ChatInterface 사용 */}
           <ChatInterface
               role={role}
               isAlive={isAlive}
               phase={phase}
               publicMessages={chatMessages}
               aiMessages={aiChatMessages}
               sendMessage={sendMessage} // sendMessage 함수 전달
           />

           {/* ActionBar */}
           <ActionBar
               phase={phase}
               isAlive={isAlive}
               isHost={isHost}
               role={role}
               sendMessage={sendMessage}
               playersInRoom={players.length} // 전체 플레이어 수 (LLM 포함)
               maxPlayers={maxPlayers ?? 0}
               onLeaveRoom={onLeaveRoom}
               isVotingPhase={isVotingPhase}
               voteOptions={voteOptions}
               votedPlayerId={votedPlayerId}
               nightActionRequired={nightAction.required}
               nightActionPayload={nightAction.payload}
               nightActionChosenTargetId={nightAction.chosenTargetId}
               winner={winner}
           />
       </div>
    </div>
  );
};

export default Room;
```

*   **`client/src/components/ActionBar.tsx`** (수정됨 - 채팅 입력 제거, 밤 액션 assassinate 추가)

```typescript
// src/components/ActionBar.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Player, Role, NightActionPayload } from '../types/game';
// PaperPlaneTilt 제거, Users, Hourglass, PersonSimpleRun, Play, GameController, Shield, Detective, Skull, Sword 추가
import { Users, Hourglass, PersonSimpleRun, Play, GameController, Shield, Detective, Skull, Sword } from 'phosphor-react';
import { useGameStore } from '../stores/useGameStore';

interface ActionBarProps {
  phase: GamePhase;
  isAlive: boolean;
  isHost: boolean;
  role: Role;
  sendMessage: (message: object) => void;
  playersInRoom: number;
  maxPlayers: number;
  onLeaveRoom: () => void;
  // Voting
  isVotingPhase: boolean;
  voteOptions: Player[];
  votedPlayerId: string | null;
  // Night Action
  nightActionRequired: boolean;
  nightActionPayload: NightActionPayload | null;
  nightActionChosenTargetId: string | null;
  // Game End
  winner: string | null;
}

const ActionBar: React.FC<ActionBarProps> = ({
  phase, isAlive, isHost, role, sendMessage, playersInRoom, maxPlayers, onLeaveRoom,
  isVotingPhase, voteOptions, votedPlayerId,
  nightActionRequired, nightActionPayload, nightActionChosenTargetId,
  winner
}) => {
  // chatInput 관련 상태 제거
  const [selectedTargetId, setSelectedTargetId] = useState<string | null>(null);
  const { setNightActionTarget } = useGameStore();

   useEffect(() => { setNightActionTarget(selectedTargetId); }, [selectedTargetId, setNightActionTarget]);
   useEffect(() => { setSelectedTargetId(null); }, [phase]);

  // handleChatSubmit 제거

  const handleStartGame = () => { /* ... 이전과 동일 ... */ };
  const handleVote = (targetId: string) => { /* ... 이전과 동일 ... */ };

  const handleNightAction = () => {
    if (nightActionRequired && isAlive && selectedTargetId && nightActionPayload) {
        sendMessage({
            type: 'night_action',
            payload: { target_id: selectedTargetId, action_type: nightActionPayload.action_type }
        });
        // 성공 시 UI 처리 (예: 선택 해제)
        setSelectedTargetId(null);
        // 스토어의 nightActionRequired 를 false 로 바꾸는 것은 서버 응답(phase 변경)으로 처리하는 것이 좋음
    }
  };

  // 시작 가능 조건 (LLM 포함 전체 인원)
  const canStartGame = playersInRoom === maxPlayers;

  return (
    <div className="bg-card p-3 sm:p-4 border-t border-gray-700">
      {/* 게임 종료 시 */}
      {winner && ( /* ... 이전과 동일 ... */ )}

      {/* 게임 대기 중 */}
      {phase === 'waiting' && !winner && ( /* ... 이전과 동일 (canStartGame 조건 사용) ... */ )}

      {/* 게임 진행 중 (밤) - 능력 사용 */}
       {phase === 'night' && isAlive && !winner && (
         <div className="flex flex-col items-center">
             {nightActionRequired && nightActionPayload ? (
                 <div className="w-full text-center">
                     <p className="text-lg text-accent mb-3 flex items-center justify-center">
                         {role === 'Scanner Droid' && <><Detective className="mr-2"/> Select player to scan:</>}
                         {role === 'Repair Bot' && <><Shield className="mr-2"/> Select player to protect:</>}
                         {role === 'AI Assassin Robot' && <><Sword className="mr-2 text-red-500"/> Select target to eliminate:</>} {/* 인간 AI 용 */}
                     </p>
                     <div className="flex flex-wrap justify-center gap-2 mb-3 max-h-24 overflow-y-auto p-1">
                        {nightActionPayload.options.map(player => (
                            <button key={player.id} onClick={() => setSelectedTargetId(player.id)}
                                className={`px-3 py-1 rounded border text-sm transition duration-150 ${
                                    selectedTargetId === player.id
                                        ? 'bg-primary text-background border-primary ring-2 ring-primary'
                                        : 'bg-background hover:bg-gray-700 border-gray-600'
                                }`}
                            > {player.username} </button>
                        ))}
                     </div>
                     <button onClick={handleNightAction} disabled={!selectedTargetId}
                         className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 inline-flex items-center">
                          <GameController size={20} className="mr-2"/> Confirm Action
                     </button>
                 </div>
             ) : ( // 능력이 없거나 이미 사용한 경우
                 <p className="text-text-secondary flex items-center justify-center"><Hourglass size={18} className="mr-1 animate-spin"/> Waiting for night to end...</p>
             )}
         </div>
       )}

       {/* 게임 진행 중 (낮 & 결과) - 채팅 입력은 ChatInterface 로 이동 */}
       {/* {(phase === 'day' || phase === 'results') && isAlive && !winner && ( ... 채팅 입력 폼 제거 ... )} */}

       {/* 게임 진행 중 (투표) */}
       {isVotingPhase && isAlive && !winner && ( /* ... 이전과 동일 ... */ )}

       {/* 관전 중 */}
       {!isAlive && phase !== 'finished' && ( /* ... 이전과 동일 ... */ )}

    </div>
  );
};

export default ActionBar;
```

*   **`client/src/components/StatusDisplay.tsx`** (수정됨 - AI 팀원 표시 추가)

```typescript
// src/components/StatusDisplay.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Role, ScanResult, FinalRoles } from '../types/game';
// Users 추가
import { Sun, Moon, Hourglass, Person, Robot, Detective, Shield, Skull, Question, Trophy, Users } from 'phosphor-react';

interface StatusDisplayProps {
  phase: GamePhase;
  dayNumber: number;
  role: Role;
  isAlive: boolean;
  timer: { phase: string; duration: number; endTime: number | null };
  winner: string | null;
  gameMessage: string | null;
  scanResult: ScanResult | null;
  finalRoles: FinalRoles | null;
  selfUsername: string | null;
  aiTeammates: string[]; // AI 팀원 목록 추가
}

// ... getPhaseIcon, getRoleIcon 함수 동일 ...

const StatusDisplay: React.FC<StatusDisplayProps> = ({
  phase, dayNumber, role, isAlive, timer, winner, gameMessage, scanResult, finalRoles, selfUsername, aiTeammates
}) => {
  const [timeLeft, setTimeLeft] = useState<number | null>(null);
  useEffect(() => { /* ... 타이머 로직 동일 ... */ }, [timer, phase]);
  const renderFinalRoles = () => { /* ... 이전과 동일 ... */ };

  return (
    <div className="text-sm space-y-2">
       {/* 현재 단계 및 시간 (이전과 동일) */}
       <div className="flex justify-between items-center"> /* ... */ </div>

       {/* 내 역할 및 상태 */}
       <div className="flex items-center">
          {isAlive ? getRoleIcon(role) : <Skull size={20} className="text-gray-500" />}
          <span className={`ml-2 font-medium ${!isAlive ? 'line-through text-gray-500' : ''}`}>
             Your Role: {role || 'Unknown'} {isAlive ? '' : '(Eliminated)'}
          </span>
       </div>

       {/* AI 팀원 표시 (AI 역할일 때만) */}
       {role === 'AI Assassin Robot' && isAlive && aiTeammates.length > 0 && (
           <div className="text-xs text-red-400 flex items-center">
              <Users size={16} className="mr-1" /> AI Teammates: {aiTeammates.join(', ')}
           </div>
       )}

       {/* 스캐너 드로이드 결과 표시 (is_ai 를 is AI Team 으로 해석) */}
       {role === 'Scanner Droid' && scanResult && isAlive && (
           <div className="bg-blue-900/50 border border-blue-700 p-2 rounded text-xs">
              Last Scan: <span className="font-semibold">{scanResult.scanned_player_name}</span> is
              <span className={`font-bold ${scanResult.is_ai ? 'text-red-400' : 'text-green-400'}`}>
                 {scanResult.is_ai ? ' AI Team!' : ' Human Team.'}
              </span>
           </div>
       )}

       {/* 게임 메시지 (이전과 동일) */}
       {gameMessage && ( /* ... */ )}

       {/* 게임 종료 시 역할 공개 (이전과 동일) */}
       {winner && renderFinalRoles()}
    </div>
  );
};

export default StatusDisplay;
```

---

**3. 환경 설정 및 구동 방법**

이전과 **동일**합니다.

1.  **사전 요구 사항:** Python 3.8+, Node.js & npm/yarn
2.  **백엔드 설정:**
    *   `backend` 폴더 이동
    *   (권장) 가상 환경 생성 및 활성화 (`python -m venv venv`, `source venv/bin/activate` 또는 `venv\Scripts\activate`)
    *   의존성 설치: `pip install -r requirements.txt`
    *   `.env` 파일 생성 및 `GEMINI_API_KEY` 설정
3.  **프론트엔드 설정:**
    *   `client` 폴더 이동
    *   의존성 설치: `npm install` 또는 `yarn install`
    *   (선택적) `.env` 파일 생성 (`REACT_APP_API_URL`, `REACT_APP_WS_URL`)
4.  **애플리케이션 실행:**
    *   백엔드 터미널: `uvicorn main:app --host 0.0.0.0 --port 8000 --reload`
    *   프론트엔드 터미널: `npm start` 또는 `yarn start`
5.  **접속:** 브라우저에서 `http://localhost:3000` (또는 프론트엔드 서버 주소)

**주요 변경점 요약 및 참고사항:**

*   **닉네임 자동 할당:** 이제 로비에서 닉네임을 입력할 필요 없이, 서버가 자동으로 `NAME_POOL`에서 이름을 할당합니다.
*   **최소 인원:** 3명의 AI가 포함되므로, 방 생성 시 최소 인원을 6명 또는 7명 이상으로 설정하는 것이 좋습니다. (코드상으로는 `ge=6`으로 변경)
*   **AI 비밀 채팅:** 'AI Assassin Robot' 역할을 맡은 플레이어는 채팅 인터페이스에 'Public Channel'과 'AI Channel (Secret)' 탭이 나타납니다. AI 채널에서 보낸 메시지는 다른 AI 역할 플레이어에게만 전달됩니다.
*   **인간 AI 역할:** 인간 플레이어도 'AI Assassin Robot' 역할을 맡을 수 있으며, 이 경우 비밀 AI 채팅에 참여하고 밤에 암살 대상을 지목할 수 있습니다.
*   **LLM AI:** LLM 기반 AI는 여전히 1명이며, 'AI Assassin Robot' 팀의 일원으로 행동합니다. 비밀 채팅 내용을 참고할 수는 있지만(백엔드 프롬프트 수정 시 가능), 주로 공개 채팅에서 인간인 척 연기합니다. 밤에는 암살 대상을 선택합니다.








































알겠습니다. '이전과 동일' 부분을 모두 포함하여, 다중 AI, 자동 이름 할당, AI 비밀 채팅 등 모든 기능이 반영된 전체 프로젝트의 완성된 소스 코드를 제공합니다.

**전체 폴더 구조**

```
ai-mafia-game-multi-ai/
├── backend/
│   ├── .env
│   ├── main.py
│   └── requirements.txt
└── client/
    ├── node_modules/
    ├── public/
    │   └── index.html
    ├── src/
    │   ├── App.tsx
    │   ├── components/
    │   │   ├── ActionBar.tsx
    │   │   ├── ChatInterface.tsx
    │   │   ├── LoadingSpinner.tsx
    │   │   ├── Lobby.tsx
    │   │   ├── Modal.tsx
    │   │   ├── PlayerList.tsx
    │   │   ├── Room.tsx
    │   │   └── StatusDisplay.tsx
    │   ├── hooks/
    │   │   └── useWebSocket.ts
    │   ├── stores/
    │   │   └── useGameStore.ts
    │   ├── types/
    │   │   └── game.ts
    │   ├── index.css
    │   └── index.tsx
    ├── .env
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    └── tsconfig.json
```

---

**1. 백엔드 (Python - FastAPI)**

*   **`backend/requirements.txt`**

```txt
fastapi
uvicorn[standard]
websockets
python-dotenv
google-generativeai
pydantic
```

*   **`backend/.env`** (YOUR_API_KEY_HERE 부분을 실제 키로 변경)

```
GEMINI_API_KEY=YOUR_API_KEY_HERE
```

*   **`backend/main.py`**

```python
import os
import asyncio
import json
import random
import uuid
from collections import defaultdict, Counter
from typing import Dict, List, Optional, Tuple, Any, Set

import google.generativeai as genai
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Query, Path, Body
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

load_dotenv()

# --- Gemini API 설정 ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    print("경고: GEMINI_API_KEY 환경 변수가 설정되지 않았습니다. AI 기능이 작동하지 않습니다.")
    gemini_model = None
else:
    genai.configure(api_key=GEMINI_API_KEY)
    try:
        # 안전 설정 기본값 사용 또는 필요시 조정
        # safety_settings=[
        #     {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        #     {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        #     {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        #     {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_MEDIUM_AND_ABOVE"},
        # ]
        # gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest', safety_settings=safety_settings)
        gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')
        print("Gemini 모델 로드 성공.")
    except Exception as e:
        print(f"Gemini 모델 로드 실패: {e}. AI 기능이 작동하지 않을 수 있습니다.")
        gemini_model = None

# --- 이름 풀 정의 ---
NAME_POOL = [
    "Alex", "Byte", "Case", "Data", "Echo", "Flux", "Glitch", "Hash",
    "Icon", "Joule", "Kernel", "Logic", "Meta", "Nexus", "Oracle", "Pixel",
    "Query", "Rift", "Socket", "Trace", "Unit", "Vector", "Wave", "Xero",
    "Yotta", "Zetta", "Alpha", "Beta", "Gamma", "Delta", "Sigma", "Omega",
    "Cipher", "Core", "Digit", "Error", "Frame", "Ghost", "Host", "Input",
    "Jinx", "Key", "Link", "Mode", "Node", "Output", "Patch", "Queue",
    "Root", "Script", "Token", "User", "Virus", "Widget", "Xenon", "Yield",
    "Zone", "Bit", "Chip", "Daemon", "Edge", "Fiber", "AgentK", "Unit7",
    "Proxy", "Signal", "Volt", "Amp", "Reboot", "Shell", "Stack", "Stream"
] # 60개 이상 권장

# --- 데이터 모델 ---
class Player(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    username: str # 서버에서 할당됨
    ws: Optional[WebSocket] = None
    role: Optional[str] = None # 'Human', 'AI Assassin Robot', 'Scanner Droid', 'Repair Bot'
    is_alive: bool = True
    is_ai: bool = False # LLM 기반 AI 여부
    is_human_ai: bool = False # AI 역할을 맡은 인간 플레이어 여부
    mimic_target_id: Optional[str] = None
    voted_for: Optional[str] = None
    night_action_target: Optional[str] = None
    last_scan_result: Optional[Dict[str, Any]] = None
    ai_teammates: List[str] = Field(default_factory=list) # AI 팀원 목록 (username)

    class Config:
        arbitrary_types_allowed = True

class Room(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    max_players: int
    password: Optional[str] = None
    players: Dict[str, Player] = Field(default_factory=dict)
    host_id: Optional[str] = None
    status: str = 'waiting'
    phase: str = 'day'
    day_number: int = 0
    # 밤 행동 결과
    ai_kill_requests: Dict[str, str] = Field(default_factory=dict) # {ai_player_id: target_id}
    protected_player_id: Optional[str] = None
    scan_request_id: Optional[str] = None
    # 투표 및 채팅
    votes: Dict[str, str] = Field(default_factory=dict) # 낮 투표 집계용
    chat_history: List[Dict[str, str]] = Field(default_factory=list)
    ai_chat_history: List[Dict[str, str]] = Field(default_factory=list) # AI 비밀 채팅 기록
    # 기타 상태
    ai_player: Optional[Player] = None # LLM AI 플레이어 객체
    assigned_names: Set[str] = Field(default_factory=set) # 방에서 사용 중인 이름 추적
    night_actions_completed: Dict[str, bool] = Field(default_factory=dict)

    class Config:
        arbitrary_types_allowed = True

class Message(BaseModel):
    type: str
    payload: dict

# --- 인메모리 저장소 ---
rooms: Dict[str, Room] = {}
connections: Dict[str, WebSocket] = {}

# --- FastAPI 앱 생성 ---
app = FastAPI(title="AI Mafia Game API - Multi AI", version="1.1.0")

# --- CORS 설정 ---
origins = ["http://localhost:3000", "http://127.0.0.1:3000"] # 필요시 배포 주소 추가
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- WebSocket 관리 함수 ---
async def send_message(player_id: str, message: Message):
    """특정 플레이어에게 WebSocket 메시지 전송"""
    if player_id in connections:
        try:
            await connections[player_id].send_json(message.dict())
        except WebSocketDisconnect:
             print(f"WebSocket already disconnected for {player_id} while trying to send.")
             # 연결 끊김 시 connections 딕셔너리에서 제거 필요 (disconnect 핸들러에서 처리)
        except Exception as e:
            print(f"Error sending message to {player_id}: {e}")

async def broadcast(room_id: str, message: Message, exclude_player_id: Optional[str] = None):
    """방의 모든 활성 플레이어에게 메시지 브로드캐스트 (AI 제외)"""
    if room_id in rooms:
        room = rooms[room_id]
        message_dict = message.dict()
        tasks = []
        active_player_ids = list(connections.keys()) # 현재 연결된 플레이어 ID 목록

        for player_id, player in room.players.items():
            # 연결되어 있고, 살아있고, 제외 대상이 아니어야 함
            if player_id in active_player_ids and player.is_alive and player_id != exclude_player_id:
                try:
                   # tasks.append(connections[player_id].send_json(message_dict)) # 직접 await 사용하지 않음
                   tasks.append(send_message(player_id, message)) # send_message 함수 재활용
                except Exception as e:
                   print(f"Error preparing broadcast to {player_id}: {e}") # 준비 단계 오류 로깅

        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            for result in results:
                if isinstance(result, Exception):
                    # 개별 전송 실패 로깅 (send_message 내부에서 이미 로깅됨)
                    # print(f"Broadcast exception occurred: {result}")
                    pass

async def broadcast_to_role(room_id: str, role: str, message: Message, exclude_player_id: Optional[str] = None):
    """특정 역할을 가진 플레이어들에게만 메시지 브로드캐스트"""
    if room_id in rooms:
        room = rooms[room_id]
        message_dict = message.dict()
        tasks = []
        active_player_ids = list(connections.keys())

        for player_id, player in room.players.items():
            if player.role == role and player.is_alive and player_id in active_player_ids and player_id != exclude_player_id:
                try:
                   # tasks.append(connections[player_id].send_json(message_dict))
                    tasks.append(send_message(player_id, message))
                except Exception as e:
                   print(f"Error preparing broadcast to role {role} player {player_id}: {e}")
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

# --- 이름 할당 함수 ---
def assign_unique_name(room: Room) -> str:
    """방에서 사용되지 않은 이름을 NAME_POOL에서 무작위로 선택하여 반환"""
    available_names = list(set(NAME_POOL) - room.assigned_names)
    if not available_names:
        print(f"Warning: NAME_POOL exhausted for room {room.id}. Generating temporary name.")
        while True:
            # 더 많은 임시 이름 생성 시도
            temp_name = f"Player_{uuid.uuid4().hex[:random.randint(3, 5)]}"
            if temp_name not in room.assigned_names:
                room.assigned_names.add(temp_name)
                return temp_name
    else:
        chosen_name = random.choice(available_names)
        room.assigned_names.add(chosen_name)
        return chosen_name

# --- LLM 관련 함수 ---
async def get_gemini_response(prompt: str) -> str:
    """Gemini API를 호출하여 응답을 반환"""
    if not gemini_model:
        print("LLM (Gemini) is not configured. Returning default response.")
        await asyncio.sleep(random.uniform(0.3, 0.8)) # 약간의 딜레이
        return random.choice(["...", "Hmm...", "Thinking...", "Understood."])

    try:
        response = await gemini_model.generate_content_async(prompt)
        # await asyncio.sleep(random.uniform(0.5, 1.5)) # 응답 시간 현실감
        if hasattr(response, 'text'):
            return response.text.strip()
        elif response.parts:
             # parts 가 있는 경우 첫 번째 part 의 text 반환 (구조 확인 필요)
             return response.parts[0].text.strip()
        else:
             print(f"Gemini Warning: No content generated. Prompt: {prompt[:100]}...")
             # print(f"Safety Feedback: {response.prompt_feedback}")
             return "..."
    except Exception as e:
        print(f"Gemini API Error: {e}")
        # 할당량 또는 기타 오류
        return "..."


async def get_ai_night_choice(ai_player: Player, room: Room) -> Optional[str]:
    """LLM AI의 밤 암살 대상 선택"""
    if not ai_player or not ai_player.is_alive: return None

    living_targets = [p for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot']
    if not living_targets: return None

    target_options = [p.username for p in living_targets]
    ai_username = ai_player.username
    human_ai_teammates = [name for name in ai_player.ai_teammates if name != ai_username]

    prompt = f"""You are part of the 'AI Assassin Robot' team ({ai_username}). Your identity is hidden. It's nighttime.
Your human AI teammates are: {', '.join(human_ai_teammates) if human_ai_teammates else 'None'}.
List of targets (Human Team): {', '.join(target_options)}
Choose one target from the list to eliminate. Select the most suspicious, threatening, or simply a good target. Respond ONLY with the chosen player's username.
Example: Nexus"""

    chosen_name = await get_gemini_response(prompt)

    for player in living_targets:
        if player.username == chosen_name:
            print(f"[AI Night Choice] LLM AI ({ai_username}) chose: {player.username}")
            return player.id

    print(f"[AI Night Choice] LLM AI response invalid ('{chosen_name}'). Choosing randomly among non-AI.")
    return random.choice(living_targets).id

async def get_ai_chat_message(ai_player: Player, room: Room):
    """LLM AI의 공개 채팅 메시지 생성 (인간인 척)"""
    if not gemini_model or not ai_player or not ai_player.is_alive: return

    recent_public_chats = room.chat_history[-15:]
    public_chat_log = "\n".join([f"{msg['sender']}: {msg['message']}" for msg in recent_public_chats])

    living_players_list = [p.username for p in room.players.values() if p.is_alive]
    my_pretend_role = "Human" # AI는 자신이 Human 인 척 함

    # 따라할 대상 선정 (AI 팀 아닌 살아있는 플레이어 중 랜덤)
    if not ai_player.mimic_target_id or ai_player.mimic_target_id not in room.players or \
       not room.players[ai_player.mimic_target_id].is_alive or \
       room.players[ai_player.mimic_target_id].role == 'AI Assassin Robot':
        living_non_ai_team = [p.id for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot' and p.id != ai_player.id]
        if living_non_ai_team:
            ai_player.mimic_target_id = random.choice(living_non_ai_team)
        else:
            ai_player.mimic_target_id = None

    mimic_target = room.players.get(ai_player.mimic_target_id)
    mimic_target_username = mimic_target.username if mimic_target else "other players"

    prompt = f"""You are a member of the 'AI Assassin Robot' team ({ai_player.username}), but you must pretend to be a '{my_pretend_role}'. Never reveal you are an AI.
Current game phase: '{room.phase}'. You are in the public chat channel. Your goal is to survive, deceive players, and eliminate the Human team.
Chat naturally to avoid suspicion. Don't be too quiet, too talkative, too smart, or too awkward.
Subtly mimic the tone or interests of '{mimic_target_username}' sometimes to appear more human.

Recent public chat log:
{public_chat_log}

Currently alive players: {', '.join(living_players_list)}

Write a short (1-2 sentences), very normal, and natural chat message for the public channel suitable for the current situation. Avoid directly accusing or targeting anyone strongly.
"""
    # AI가 가끔 침묵하도록 (예: 25% 확률)
    if random.random() < 0.75:
        ai_message_content = await get_gemini_response(prompt)
        forbidden_words = ["AI", "로봇", "인공지능", "암살", "assassin", "robot", "LLM", "Gemini", "pretend", "role", "deceive"]
        filtered_message = ai_message_content
        for word in forbidden_words:
             # 대소문자 구분 없이 단어 단위로 치환 (더 안전)
            filtered_message = re.sub(r'\b' + re.escape(word) + r'\b', '[CENSORED]', filtered_message, flags=re.IGNORECASE)

        if filtered_message and filtered_message != "...":
            chat_payload = {'sender': ai_player.username, 'message': filtered_message}
            room.chat_history.append(chat_payload)
            await broadcast(room.id, Message(type='chat', payload=chat_payload)) # 공개 채팅으로 전송
            print(f"[AI Public Chat] LLM AI ({ai_player.username}): {filtered_message}")
    else:
        print(f"[AI Public Chat] LLM AI ({ai_player.username}) decided to stay silent this time.")

# --- 게임 로직 ---
def assign_roles_multi_ai(players: List[Player], num_ai=3, num_scanner=1, num_repair=1) -> List[Player]:
    """다중 AI 역할 배정 로직"""
    num_players = len(players)
    min_required = num_ai + num_scanner + num_repair
    if num_players < min_required:
        print(f"Error: Not enough players ({num_players}) to assign roles (min required: {min_required}).")
        return []

    llm_player = next((p for p in players if p.is_ai), None)
    if not llm_player:
        print("Error: LLM AI player not found during role assignment.")
        return []

    human_players = [p for p in players if not p.is_ai]
    random.shuffle(human_players)

    # 1. AI 역할 배정 (LLM 포함)
    ai_players = [llm_player]
    num_human_ai_needed = num_ai - 1
    if len(human_players) >= num_human_ai_needed:
        human_ai_players = human_players[:num_human_ai_needed]
        ai_players.extend(human_ai_players)
        human_players = human_players[num_human_ai_needed:]
    else:
        print(f"Error: Not enough human players ({len(human_players)}) to assign {num_human_ai_needed} human AI roles.")
        return []

    for player in ai_players:
        player.role = 'AI Assassin Robot'
        player.is_human_ai = not player.is_ai

    ai_teammate_names = [p.username for p in ai_players]
    for player in ai_players:
        player.ai_teammates = [name for name in ai_teammate_names if name != player.username]

    print(f" > AI Assassin Robots ({len(ai_players)}): {[p.username for p in ai_players]}")

    # 2. 스캐너 드로이드 배정
    scanner_players = []
    assigned_scanner_count = 0
    if num_scanner > 0 and len(human_players) >= num_scanner:
        scanner_players = human_players[:num_scanner]
        human_players = human_players[num_scanner:]
        for player in scanner_players:
            player.role = 'Scanner Droid'
        assigned_scanner_count = len(scanner_players)
        print(f" > Scanner Droids ({assigned_scanner_count}): {[p.username for p in scanner_players]}")
    elif num_scanner > 0:
        print(f"Warning: Not enough players for {num_scanner} Scanner Droid role(s). Assigned {len(human_players)}.")
        # 남은 플레이어 모두 스캐너로? 아니면 0명? 여기서는 0명으로.
        pass


    # 3. 리페어 봇 배정
    repair_players = []
    assigned_repair_count = 0
    if num_repair > 0 and len(human_players) >= num_repair:
        repair_players = human_players[:num_repair]
        human_players = human_players[num_repair:]
        for player in repair_players:
            player.role = 'Repair Bot'
        assigned_repair_count = len(repair_players)
        print(f" > Repair Bots ({assigned_repair_count}): {[p.username for p in repair_players]}")
    elif num_repair > 0:
        print(f"Warning: Not enough players for {num_repair} Repair Bot role(s). Assigned {len(human_players)}.")
        pass

    # 4. 나머지 Human 배정
    for player in human_players:
        player.role = 'Human'
    print(f" > Humans ({len(human_players)}): {[p.username for p in human_players]}")

    return players


async def start_game(room_id: str):
    """게임 시작 처리"""
    if room_id not in rooms: return
    room = rooms[room_id]

    MIN_PLAYERS = 6 # 최소 인원 (AI 3명 포함)
    if len(room.players) < MIN_PLAYERS:
        await broadcast(room_id, Message(type='error', payload={'message': f'최소 {MIN_PLAYERS}명 이상 필요합니다. (현재 {len(room.players)}명)'}))
        return

    room.status = 'playing'
    room.day_number = 0
    room.chat_history = []
    room.ai_chat_history = []

    # --- LLM AI 플레이어 추가 (역할 배정 전) ---
    # LLM AI 는 항상 존재한다고 가정 (방 생성 시점에서 결정되지 않음)
    llm_ai_username = assign_unique_name(room)
    llm_ai_player = Player(username=llm_ai_username, is_ai=True)
    room.players[llm_ai_player.id] = llm_ai_player
    room.ai_player = llm_ai_player
    print(f"Room {room.name}: LLM AI Player '{llm_ai_player.username}' added.")

    # --- 역할 배정 ---
    player_list = list(room.players.values())
    assigned_players = assign_roles_multi_ai(player_list, num_ai=3, num_scanner=1, num_repair=1) # 역할 수 고정

    if not assigned_players:
        print(f"Error: Role assignment failed for room {room.id}.")
        await broadcast(room_id, Message(type='error', payload={'message': '역할 배정 오류 발생. 게임을 시작할 수 없습니다.'}))
        # 롤백: LLM AI 제거 및 이름 반환
        if llm_ai_player.id in room.players: del room.players[llm_ai_player.id]
        if llm_ai_username in room.assigned_names: room.assigned_names.remove(llm_ai_username)
        room.ai_player = None
        room.status = 'waiting'
        # 다른 플레이어 역할도 초기화 필요 시 추가
        for p in player_list: p.role = None
        return

    print(f"Game starting in room {room.name}. Total Players: {len(room.players)}")

    # 플레이어 상태 초기화
    for player in room.players.values():
        player.is_alive = True
        player.voted_for = None
        player.night_action_target = None
        player.last_scan_result = None

    # 역할 정보 및 플레이어 목록 전송
    await update_player_list(room_id)
    for player_id, player in room.players.items():
         if player_id in connections:
             role_info_payload = {
                 'role': player.role,
                 'ai_teammates': player.ai_teammates if player.role == 'AI Assassin Robot' else []
             }
             await send_message(player_id, Message(type='role_info', payload=role_info_payload))

    await broadcast(room_id, Message(type='system', payload={'message': f"게임 시작! {len(room.players)}명 중 숨어있는 3명의 AI 암살 로봇을 찾아내세요!"}))
    await start_night_phase(room_id)


async def check_win_condition(room_id: str):
    """승리 조건 확인"""
    if room_id not in rooms: return False
    room = rooms[room_id]
    if room.status != 'playing': return False # 게임 중일 때만 체크

    living_players = [p for p in room.players.values() if p.is_alive]
    living_ai_count = sum(1 for p in living_players if p.role == 'AI Assassin Robot')
    living_human_team_count = len(living_players) - living_ai_count

    winner = None
    message = ""

    if living_ai_count == 0:
        winner = "Human Team"
        message = "모든 AI 암살 로봇을 찾아냈습니다! Human 팀 승리!"
    elif living_ai_count >= living_human_team_count:
        winner = "AI Assassin Robot Team"
        message = "남은 Human 팀원의 수가 AI 암살 로봇의 수보다 적거나 같아졌습니다. AI 암살 로봇 팀 승리!"

    if winner:
        room.status = 'finished'
        final_roles = {p.username: p.role for p in room.players.values()}
        await broadcast(room_id, Message(type='game_over', payload={'winner': winner, 'message': message, 'roles': final_roles}))
        print(f"Game over in room {room.id}. Winner: {winner}")
        # 선택적: 방 자동 리셋 또는 삭제 타이머
        # asyncio.create_task(reset_or_delete_room_delayed(room_id, 60))
        return True
    return False

async def start_night_phase(room_id: str):
    """밤 단계 시작"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if await check_win_condition(room_id): return

    room.phase = 'night'
    room.day_number += 1
    room.ai_kill_requests = {}
    room.protected_player_id = None
    room.scan_request_id = None
    room.night_actions_completed = {}

    for player in room.players.values():
        player.night_action_target = None
        player.voted_for = None
        player.last_scan_result = None

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'night', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': f"Day {room.day_number}. 밤이 되었습니다. 각자 능력을 사용하세요."}))
    await broadcast_to_role(room_id, 'AI Assassin Robot', Message(type='system', payload={'message': "AI 채널: 암살 대상을 논의하고 지목하세요."}))

    # 밤 행동 요청 및 처리
    night_tasks = []
    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]
    living_non_ai_options = [opt for opt in living_players_options if room.players[opt['id']].role != 'AI Assassin Robot']

    # LLM AI 행동 예약
    if room.ai_player and room.ai_player.is_alive:
         room.night_actions_completed[room.ai_player.id] = False
         night_tasks.append(asyncio.create_task(process_llm_ai_night_action(room)))

    # 특수 역할 및 인간 AI 에게 행동 요청
    for player_id, player in room.players.items():
        if player.is_alive and player_id in connections:
             action_payload = {'options': []}
             request_needed = False
             action_type = None

             if player.role == 'AI Assassin Robot' and not player.is_ai: # 인간 AI
                  action_payload['options'] = living_non_ai_options
                  action_type = 'assassinate'
                  request_needed = True
             elif player.role == 'Scanner Droid':
                  action_payload['options'] = [opt for opt in living_players_options if opt['id'] != player_id]
                  action_type = 'scan'
                  request_needed = True
             elif player.role == 'Repair Bot':
                  action_payload['options'] = living_players_options
                  action_type = 'protect'
                  request_needed = True

             if request_needed:
                 action_payload['action_type'] = action_type
                 room.night_actions_completed[player_id] = False
                 night_tasks.append(send_message(player_id, Message(type='night_action_request', payload=action_payload)))

    # 밤 시간 타이머
    night_duration = 45 # AI 논의 시간 고려
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'night', 'duration': night_duration}))

    # 밤 행동 완료 대기
    async def wait_for_night_actions():
        try:
            await asyncio.wait_for(check_all_night_actions_done(room), timeout=night_duration)
            print(f"Room {room.id}: All required night actions completed or timeout reached.")
        except asyncio.TimeoutError:
            print(f"Room {room.id}: Night action timeout.")
        finally:
             if room.status == 'playing':
                await process_night_results(room_id)

    night_tasks.append(asyncio.create_task(wait_for_night_actions()))
    if night_tasks:
        await asyncio.gather(*[task for task in night_tasks if isinstance(task, asyncio.Task)], return_exceptions=True)


async def process_llm_ai_night_action(room: Room):
     """LLM AI의 밤 암살 대상 선택 처리"""
     if not room.ai_player or not room.ai_player.is_alive: return
     ai_target_id = await get_ai_night_choice(room.ai_player, room)
     if ai_target_id:
         room.ai_kill_requests[room.ai_player.id] = ai_target_id
         print(f"[Night Action] LLM AI ({room.ai_player.username}) requested kill target: {room.players.get(ai_target_id, Player(username='Unknown')).username}")
         # AI 비밀 채팅에 선택 알림 (선택적)
         ai_chat_payload = {'sender': room.ai_player.username, 'message': f"(선택: {room.players.get(ai_target_id).username})"}
         room.ai_chat_history.append(ai_chat_payload)
         await broadcast_to_role(room.id, 'AI Assassin Robot', Message(type='ai_chat', payload=ai_chat_payload))
     else:
         print("[Night Action] LLM AI did not choose a kill target.")
     # 완료 상태는 여기서 True 로 설정
     room.night_actions_completed[room.ai_player.id] = True

async def check_all_night_actions_done(room: Room):
    """모든 필수 밤 역할 행동 완료 체크"""
    while True:
        required_players = [p_id for p_id, p in room.players.items() if p.is_alive and p.role in ['AI Assassin Robot', 'Scanner Droid', 'Repair Bot']]
        if not required_players: break

        # 완료되지 않은 필수 플레이어 찾기
        not_completed = [p_id for p_id in required_players if not room.night_actions_completed.get(p_id, False)]

        if not not_completed:
            print(f"Room {room.id}: All {len(required_players)} required night actions are complete.")
            break # 모두 완료

        # print(f"DEBUG Night Check: Waiting for {len(not_completed)} players: {[room.players[pid].username for pid in not_completed]}") # 디버깅

        if room.status != 'playing' or room.phase != 'night':
            print(f"Room {room.id}: Night phase ended while waiting for actions.")
            break
        await asyncio.sleep(1)


async def process_night_results(room_id: str):
    """밤 결과 처리 및 낮 시작"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'night': return

    print(f"Room {room.id}: Processing night results...")
    eliminated_player = None
    eliminated_player_info = "어젯밤, 아무 일도 일어나지 않았습니다."

    # 1. AI 암살 결정
    ai_target_votes = Counter(room.ai_kill_requests.values())
    final_ai_target_id = None
    if ai_target_votes:
        max_votes = max(ai_target_votes.values())
        candidates = [pid for pid, count in ai_target_votes.items() if count == max_votes]
        if len(candidates) == 1:
            final_ai_target_id = candidates[0]
        elif len(candidates) > 1: # 동점일 경우
            print(f" > AI kill vote tied between: {[room.players.get(pid, Player(username='?')).username for pid in candidates]}. No kill this night.")
            final_ai_target_id = None # 동점 시 무효화
        if final_ai_target_id:
             target_player = room.players.get(final_ai_target_id)
             if target_player:
                print(f" > AI team decided to target: {target_player.username}")
             else:
                 print(f" > AI team target ID {final_ai_target_id} not found in players.")
                 final_ai_target_id = None # 대상 없으면 무효


    # 2. 리페어 봇 보호 적용
    protected_username = "Unknown"
    if room.protected_player_id and room.protected_player_id in room.players:
        protected_username = room.players[room.protected_player_id].username
        print(f" > Repair Bot protected: {protected_username}")

    # 3. 최종 암살 처리
    if final_ai_target_id:
        target_player = room.players.get(final_ai_target_id)
        if target_player and target_player.is_alive:
            if final_ai_target_id == room.protected_player_id:
                eliminated_player_info = f"어젯밤, 누군가({target_player.username}) 공격받았지만 Repair Bot 덕분에 무사했습니다!"
                print(f" > AI target {target_player.username} was protected.")
                repair_bot = next((p for p in room.players.values() if p.role == 'Repair Bot'), None)
                if repair_bot and repair_bot.id in connections:
                    await send_message(repair_bot.id, Message(type='system', payload={'message': f'밤 사이 당신의 보호로 {target_player.username}님이 목숨을 구했습니다.'}))
            else:
                target_player.is_alive = False
                eliminated_player = target_player
                eliminated_player_info = f"어젯밤, {target_player.username}님이 공격당했습니다."
                print(f" > Player {target_player.username} was eliminated by AI team.")
        elif not target_player:
             print(f" > AI final target ID {final_ai_target_id} is invalid.")
        # else: 이미 죽은 플레이어 공격 시 무시

    # 4. 스캐너 드로이드 스캔 결과 처리/전송
    scanner_droid = next((p for p in room.players.values() if p.role == 'Scanner Droid' and p.is_alive), None)
    if scanner_droid and room.scan_request_id:
        scanned_player = room.players.get(room.scan_request_id)
        if scanned_player:
            # 스캔 대상이 AI 팀 소속인지 확인
            is_target_ai_team = scanned_player.role == 'AI Assassin Robot'
            scan_result_payload = {
                'scanned_player_id': scanned_player.id,
                'scanned_player_name': scanned_player.username,
                'is_ai': is_target_ai_team # AI 팀 여부
            }
            scanner_droid.last_scan_result = scan_result_payload
            if scanner_droid.id in connections:
                 scan_msg = f"스캔 결과: {scanned_player.username}님은 {'AI 팀' if is_target_ai_team else 'Human 팀'}입니다."
                 await send_message(scanner_droid.id, Message(type='scan_result', payload=scan_result_payload))
                 await send_message(scanner_droid.id, Message(type='system', payload={'message': scan_msg})) # 시스템 메시지로도 전송
                 print(f" > Scanner Droid {scanner_droid.username} scanned {scanned_player.username}. Result: {'AI Team' if is_target_ai_team else 'Human Team'}")
        else:
            if scanner_droid.id in connections:
                 await send_message(scanner_droid.id, Message(type='system', payload={'message': '스캔 대상이 유효하지 않았습니다.'}))

    # 게임 종료 조건 즉시 체크
    if await check_win_condition(room_id): return

    # 낮 단계 시작
    room.phase = 'day'
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'day', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "낮이 밝았습니다."}))
    await broadcast(room_id, Message(type='system', payload={'message': eliminated_player_info}))

    if eliminated_player:
        await update_player_list(room_id)

    await start_discussion_phase(room_id)


async def start_discussion_phase(room_id: str):
    """낮 토론 시작"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return

    discussion_time = 90 # 토론 시간
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'day', 'duration': discussion_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"토론 시간 {discussion_time}초 시작!"}))

    # LLM AI 채팅 활성화 (비동기)
    async def llm_ai_chat_during_day():
        start_time = asyncio.get_event_loop().time()
        end_time = start_time + discussion_time
        num_chats = random.randint(2, 4) # 채팅 빈도 조정
        chat_times = sorted([random.uniform(start_time + 10, end_time - 10) for _ in range(num_chats)])

        chat_tasks = []
        for chat_time in chat_times:
             delay = chat_time - asyncio.get_event_loop().time()
             if delay > 0:
                 chat_tasks.append(asyncio.create_task(schedule_llm_ai_chat(room, delay)))

        if chat_tasks:
           try:
               await asyncio.gather(*chat_tasks)
           except Exception as e:
               print(f"Error during scheduled AI chat: {e}")

        # 토론 시간 종료 후 투표 시작 (정확한 시간 계산)
        remaining_time = end_time - asyncio.get_event_loop().time()
        if remaining_time > 0:
            await asyncio.sleep(remaining_time)

        if room.status == 'playing' and room.phase == 'day': # 상태 재확인
            await start_voting_phase(room_id)

    async def schedule_llm_ai_chat(room_obj: Room, delay: float):
         await asyncio.sleep(delay)
         # LLM AI가 존재하고, 살아있고, 게임 중이고, 낮 단계일 때만
         if room_obj.status == 'playing' and room_obj.phase == 'day' and room_obj.ai_player and room_obj.ai_player.is_alive:
              # get_ai_chat_message 는 내부적으로 gemini_model 존재 여부 체크
              await get_ai_chat_message(room_obj.ai_player, room_obj)

    asyncio.create_task(llm_ai_chat_during_day())


async def start_voting_phase(room_id: str):
    """낮 투표 시작"""
    if room_id not in rooms: return
    room = rooms[room_id]
    if room.status != 'playing' or room.phase != 'day': return
    if await check_win_condition(room_id): return

    room.phase = 'voting'
    room.votes = {}
    for player in room.players.values(): player.voted_for = None

    await broadcast(room_id, Message(type='game_state', payload={'phase': 'voting', 'day': room.day_number}))
    await broadcast(room_id, Message(type='system', payload={'message': "토론 시간이 종료되었습니다. 투표를 시작합니다."}))

    living_players_options = [{'id': p.id, 'username': p.username} for p in room.players.values() if p.is_alive]

    # 각 플레이어에게 자신 제외 투표 옵션 전송
    for voter_id, voter in room.players.items():
        if voter.is_alive and voter_id in connections: # AI 포함 모든 연결된 플레이어에게 전송 (단, AI는 UI 사용 안 함)
            options_for_voter = [opt for opt in living_players_options if opt['id'] != voter_id]
            # AI 역할에게는 투표 UI 를 보내지 않을 수 있음 (선택적)
            # if not voter.role == 'AI Assassin Robot':
            await send_message(voter_id, Message(type='vote_start', payload={'options': options_for_voter}))

    vote_time = 45 # 투표 시간
    await broadcast(room_id, Message(type='timer_start', payload={'phase': 'voting', 'duration': vote_time}))
    await broadcast(room_id, Message(type='system', payload={'message': f"투표 시간 {vote_time}초! 의심되는 플레이어를 지목하세요."}))

    async def wait_for_vote_end():
        await asyncio.sleep(vote_time)
        # 시간 종료 시점에 상태 확인 후 결과 처리
        if room_id in rooms and rooms[room_id].status == 'playing' and rooms[room_id].phase == 'voting':
           print(f"Room {room.id}: Vote time ended. Processing results.")
           await process_voting_results(room_id)

    asyncio.create_task(wait_for_vote_end())


async def process_voting_results(room_id: str):
    """낮 투표 결과 처리"""
    if room_id not in rooms: return
    room = rooms[room_id]
    # 중복 처리 방지
    if room.phase != 'voting' or room.status != 'playing':
        print(f"Skipping vote results processing. Phase: {room.phase}, Status: {room.status}")
        return

    room.phase = 'results' # 결과 처리 중 상태 변경
    await broadcast(room_id, Message(type='game_state', payload={'phase': 'results', 'day': room.day_number}))
    await broadcast(room_id, Message(type='vote_end', payload={})) # 프론트엔드 투표 UI 닫기

    # 모든 AI (LLM 포함)가 투표 (살아있는 인간 팀 중 랜덤 선택)
    living_human_team_ids = [p.id for p in room.players.values() if p.is_alive and p.role != 'AI Assassin Robot']
    for ai_player in room.players.values():
        # 살아있고, AI 역할이고, 아직 투표 안했을 때
        if ai_player.role == 'AI Assassin Robot' and ai_player.is_alive and not ai_player.voted_for:
             if living_human_team_ids:
                 ai_vote_target_id = random.choice(living_human_team_ids)
                 ai_player.voted_for = ai_vote_target_id
                 print(f"[AI Vote] AI ({ai_player.username}) voted for {room.players.get(ai_vote_target_id, Player(username='Unknown')).username}")
             else:
                 print(f"[AI Vote] No living human team members for AI ({ai_player.username}) to vote for.")

    # 투표 집계 (Player 객체의 voted_for 사용)
    votes_cast = [p.voted_for for p in room.players.values() if p.is_alive and p.voted_for is not None]
    room.votes = Counter(votes_cast) # room.votes 에 집계 결과 저장

    # 투표 결과 상세 메시지 생성
    vote_details = []
    # 살아있는 모든 플레이어의 투표 기록 표시
    for voter in sorted(room.players.values(), key=lambda p: p.username):
         if voter.is_alive:
             target_player = room.players.get(voter.voted_for) if voter.voted_for else None
             target_name = target_player.username if target_player else " (Skip)"
             # AI 투표는 별도 표시 가능 (선택적)
             # prefix = "[AI] " if voter.role == 'AI Assassin Robot' else ""
             vote_details.append(f"{voter.username} -> {target_name}")

    vote_summary_msg = "투표 결과: " + ", ".join(vote_details) if vote_details else "투표 결과: 아무도 투표하지 않았습니다."
    await broadcast(room_id, Message(type='system', payload={'message': vote_summary_msg}))

    # 최다 득표자 결정
    max_votes = 0
    eliminated_candidates = []
    if room.votes:
       # 유효한 대상(살아있는 플레이어)에 대한 투표만 고려
       valid_vote_counts = {target_id: count for target_id, count in room.votes.items() if target_id in room.players and room.players[target_id].is_alive}
       if valid_vote_counts:
          max_votes = max(valid_vote_counts.values())
          # 최다 득표자 목록 생성
          eliminated_candidates = [p_id for p_id, count in valid_vote_counts.items() if count == max_votes]

    result_message = ""
    eliminated_player = None
    if not eliminated_candidates or max_votes == 0:
         result_message = "투표 결과, 아무도 지목되지 않았습니다."
    elif len(eliminated_candidates) > 1: # 동점자 발생
        ties = [room.players.get(pid, Player(username='?')).username for pid in eliminated_candidates]
        result_message = f"투표 결과 동점입니다: {', '.join(ties)}. 이번 투표는 무효 처리됩니다."
    else: # 단독 최다 득표자
        eliminated_id = eliminated_candidates[0]
        if eliminated_id in room.players:
            eliminated_player = room.players[eliminated_id]
            eliminated_player.is_alive = False # 처형
            result_message = f"투표 결과, {eliminated_player.username} ({eliminated_player.role})님이 처형되었습니다."
            print(f"[Vote Result] Player {eliminated_player.username} eliminated by vote.")
            # 제거 후 즉시 승리 조건 체크
            if await check_win_condition(room_id): return
        else:
             result_message = "투표 결과 처리 중 오류 발생 (플레이어 ID 찾기 실패)."

    await broadcast(room_id, Message(type='system', payload={'message': result_message}))

    # 사망자 발생 시 플레이어 목록 업데이트
    if eliminated_player:
        await update_player_list(room_id)

    # 결과 발표 후 다음 밤 시작 전 딜레이
    await asyncio.sleep(5)
    # 게임 상태 재확인 후 다음 밤 시작
    if room_id in rooms and rooms[room_id].status == 'playing':
        await start_night_phase(room_id)


async def update_player_list(room_id: str):
    """플레이어 목록 업데이트 브로드캐스트"""
    if room_id in rooms:
        room = rooms[room_id]
        player_list_payload = [
            {'id': p.id, 'username': p.username, 'is_alive': p.is_alive, 'is_host': p.id == room.host_id}
            for p in room.players.values() # LLM AI 포함 모든 플레이어
        ]
        # 플레이어 이름 순으로 정렬하여 전송 (선택적)
        player_list_payload.sort(key=lambda p: p['username'])
        await broadcast(room_id, Message(type='player_list', payload={'players': player_list_payload}))

async def handle_player_disconnect(room_id: str, player_id: str):
    """플레이어 연결 종료 처리"""
    if player_id not in connections: return # 이미 처리됨

    websocket = connections.pop(player_id, None) # 연결 목록에서 제거
    print(f"Player (ID: {player_id}) disconnected from room {room_id}")

    if room_id in rooms:
        room = rooms[room_id]
        player = room.players.pop(player_id, None) # 방의 플레이어 목록에서 제거

        if player:
            player_name = player.username
            # 할당되었던 이름 반환
            if player_name in room.assigned_names:
                room.assigned_names.remove(player_name)
                print(f" > Name '{player_name}' returned to pool.")

            # LLM AI 플레이어 이탈 시 (치명적 오류)
            if player.is_ai:
                room.ai_player = None
                print(f"CRITICAL ERROR: LLM AI player {player_name} disconnected/removed.")
                await broadcast(room_id, Message(type='error', payload={'message': '게임 오류: AI 플레이어 연결 해제됨. 게임을 종료합니다.'}))
                room.status = 'finished'
                # 추가적인 게임 정리 로직 필요 시

            await broadcast(room_id, Message(type='system', payload={'message': f"{player_name}님이 나갔습니다."}))
            await update_player_list(room_id) # 플레이어 목록 갱신

            # 호스트 변경 로직 (인간 플레이어 중에서)
            if room.host_id == player_id and room.players:
                 human_players = [p for p_id, p in room.players.items() if not p.is_ai and p_id in connections]
                 if human_players:
                     new_host = random.choice(human_players)
                     room.host_id = new_host.id
                     await broadcast(room_id, Message(type='system', payload={'message': f"{new_host.username}님이 새로운 방장이 되었습니다."}))
                     await update_player_list(room_id)
                 else:
                     room.host_id = None # 남은 인간 플레이어 없음

            # 게임 중 생존자 이탈 시 처리
            if room.status == 'playing' and player.is_alive:
                player.is_alive = False # 나간 사람은 죽은 것으로 간주
                print(f"Player {player_name} left while alive during the game.")
                await update_player_list(room_id) # 사망 처리 반영
                # 즉시 승리 조건 체크
                if await check_win_condition(room_id): return

            # 방 정리 로직 (인간 플레이어가 없으면 방 삭제)
            human_player_exists = any(not p.is_ai for p_id, p in room.players.items() if p_id in connections)
            if not human_player_exists:
                 print(f"Room {room.id} has no human players left. Deleting room.")
                 # LLM AI 도 제거
                 if room.ai_player and room.ai_player.id in room.players:
                      del room.players[room.ai_player.id]
                 if room.ai_player and room.ai_player.username in room.assigned_names:
                      room.assigned_names.remove(room.ai_player.username)

                 # 방 삭제 전 안전 확인
                 if room_id in rooms:
                     del rooms[room_id]
        else:
            # players 딕셔너리에 해당 player_id 가 없는 경우 (드문 케이스)
             print(f"Warning: Disconnected player_id {player_id} not found in room {room_id} players dict.")


# --- API Endpoints ---
@app.get("/api/rooms", summary="Get list of available game rooms")
async def get_rooms_api():
    room_list = []
    current_rooms = list(rooms.items())
    for room_id, room in current_rooms:
        # 방 유효성 체크
        if not room.players: continue

        # 실제 연결된 인간 플레이어 + LLM AI 수
        current_human_players = sum(1 for p_id, p in room.players.items() if not p.is_ai and p_id in connections)
        ai_player_count = 1 if room.ai_player else 0

        room_list.append({
            "id": room.id,
            "name": room.name,
            "current_players": current_human_players + ai_player_count,
            "max_players": room.max_players,
            "status": room.status,
            "is_private": bool(room.password)
        })
    return room_list

class CreateRoomRequest(BaseModel): # username 제거
    name: str = Field(..., min_length=2, max_length=20)
    max_players: int = Field(..., ge=6, le=12, description="Max players (incl. 3 AIs, 6-12)")
    password: Optional[str] = Field(None, min_length=4, max_length=20)

@app.post("/api/rooms", summary="Create a new game room")
async def create_room_api(request: CreateRoomRequest):
     if any(r.name == request.name for r in rooms.values()):
        raise HTTPException(status_code=400, detail="Room name already exists.")

     room = Room(
        name=request.name,
        max_players=request.max_players,
        password=request.password # TODO: 해싱 필요
     )
     # 방 생성 시 assigned_names 초기화 확인
     room.assigned_names = set()
     rooms[room.id] = room
     print(f"Room created: {room.name} (ID: {room.id}), Max Players: {room.max_players}, Private: {bool(room.password)}")
     return {"room_id": room.id}

# --- WebSocket Endpoint ---
@app.websocket("/ws/{room_id}") # username 경로 파라미터 제거
async def websocket_endpoint(websocket: WebSocket, room_id: str, password: Optional[str] = Query(None)):
    player_id = None
    player_name = None # 할당된 이름 추적용
    try:
        if room_id not in rooms:
            await websocket.close(code=1008, reason="Room not found")
            return

        room = rooms[room_id]

        if room.password and room.password != password:
            await websocket.close(code=1008, reason="Invalid password")
            return

        # 인원 수 확인 (LLM 제외 실제 접속자)
        current_connections = len([p_id for p_id, p in room.players.items() if p_id in connections])
        max_allowed = room.max_players - 1 # LLM 자리 제외

        if room.status == 'waiting' and current_connections >= max_allowed:
             await websocket.close(code=1008, reason="Room is full")
             return
        if room.status != 'waiting':
            await websocket.close(code=1008, reason="Game already started or finished")
            return

        # --- 이름 할당 ---
        player_name = assign_unique_name(room)
        if not player_name:
            await websocket.close(code=1011, reason="Failed to assign name")
            return

        # --- 플레이어 연결 성공 ---
        await websocket.accept()
        player = Player(username=player_name, ws=websocket)
        player_id = player.id
        connections[player_id] = websocket
        room.players[player_id] = player

        if room.host_id is None: room.host_id = player_id

        print(f"Player {player_name} (ID: {player_id}) connected to room {room.name} ({room_id})")

        # 연결 성공 메시지 (할당된 이름 포함)
        await send_message(player_id, Message(type='connected', payload={
            'room_id': room.id, 'player_id': player_id, 'username': player_name, 'max_players': room.max_players
        }))

        await broadcast(room_id, Message(type='system', payload={'message': f"{player_name}님이 입장했습니다."}), exclude_player_id=player_id)
        await update_player_list(room_id)

        # 인원 충족 시 호스트에게 알림 (LLM 포함 계산)
        current_total_players = len(room.players) # LLM 포함 확인
        if room.status == 'waiting' and current_total_players == room.max_players and room.host_id == player_id:
             await send_message(player_id, Message(type='system', payload={'message': f"인원이 모두 모였습니다 ({room.max_players}명). 게임을 시작할 수 있습니다!"}))

        # --- 메시지 수신 루프 ---
        while True:
            data = await websocket.receive_json()
            message = Message(**data)
            # print(f"Received message from {player_name} (ID: {player_id}): {message.type}") # 로깅 간소화

            # 플레이어 유효성 재확인
            if player_id not in room.players or player_id not in connections:
                print(f"Player {player_name}({player_id}) no longer valid, breaking loop.")
                break
            current_player = room.players[player_id]

            # --- 메시지 타입별 처리 ---
            if message.type == 'chat': # 공개 채팅
                msg_content = message.payload.get('message', '')[:100].strip()
                if not msg_content: continue # 빈 메시지 무시
                # 대기 중이거나, 게임 중 살아있고 밤이 아닐 때
                if room.status == 'waiting' or (room.status == 'playing' and current_player.is_alive and room.phase != 'night'):
                    chat_payload = {'sender': player_name, 'message': msg_content}
                    room.chat_history.append(chat_payload)
                    await broadcast(room.id, Message(type='chat', payload=chat_payload))
                else:
                    await send_message(player_id, Message(type='error', payload={'message': '지금은 공개 채팅을 할 수 없습니다.'}))


            elif message.type == 'send_ai_chat': # AI 비밀 채팅
                 msg_content = message.payload.get('message', '')[:100].strip()
                 if not msg_content: continue
                 # AI 역할이고 살아있을 때만
                 if current_player.role == 'AI Assassin Robot' and current_player.is_alive:
                     ai_chat_payload = {'sender': player_name, 'message': msg_content}
                     room.ai_chat_history.append(ai_chat_payload)
                     # 다른 AI 팀원에게만 전송 (자신 제외)
                     await broadcast_to_role(room.id, 'AI Assassin Robot', Message(type='ai_chat', payload=ai_chat_payload), exclude_player_id=player_id)
                     # 본인에게도 확인용 전송 (클라이언트에서 isSelf 로 구분)
                     await send_message(player_id, Message(type='ai_chat', payload=ai_chat_payload))
                 else:
                      await send_message(player_id, Message(type='error', payload={'message': 'AI 비밀 채팅을 보낼 권한이 없습니다.'}))


            elif message.type == 'start_game':
                if player_id == room.host_id and room.status == 'waiting':
                    # LLM 포함 전체 인원수 체크
                    if len(room.players) == room.max_players:
                         await start_game(room_id)
                    else:
                        await send_message(player_id, Message(type='error', payload={'message': f'인원이 부족합니다. ({len(room.players)}/{room.max_players}명)'}))
                elif player_id != room.host_id: await send_message(player_id, Message(type='error', payload={'message': '방장만 게임을 시작할 수 있습니다.'}))
                else: await send_message(player_id, Message(type='error', payload={'message': '지금은 게임을 시작할 수 없습니다.'}))


            elif message.type == 'vote': # 낮 투표
                 if room.phase == 'voting' and current_player.is_alive:
                      # AI 는 UI 로 투표하지 않음 (서버 내부 처리)
                      if current_player.is_ai:
                            # print(f"Debug: Ignoring vote message from LLM AI {player_name}")
                            continue

                      target_id = message.payload.get('target_id')
                      if target_id == player_id: await send_message(player_id, Message(type='error', payload={'message': '자기 자신에게 투표할 수 없습니다.'}))
                      elif target_id in room.players and room.players[target_id].is_alive:
                          current_player.voted_for = target_id
                          print(f"[Vote] {player_name} voted for {room.players[target_id].username}")
                          await send_message(player_id, Message(type='system', payload={'message': f"{room.players[target_id].username}님에게 투표했습니다."}))
                          # 모든 '인간' 플레이어 투표 완료 체크
                          living_humans = [p for p_id, p in room.players.items() if p.is_alive and not p.is_ai and p_id in connections]
                          votes_cast_count = sum(1 for p in living_humans if p.voted_for is not None)
                          if votes_cast_count == len(living_humans):
                               print(f"Room {room.id}: All living humans voted. Processing results early.")
                               await asyncio.sleep(0.5) # 동시 처리 방지
                               if room.phase == 'voting': await process_voting_results(room_id)
                      else: await send_message(player_id, Message(type='error', payload={'message': '유효하지 않은 투표 대상입니다.'}))
                 # 투표 불가 사유
                 elif not current_player.is_alive: await send_message(player_id, Message(type='error', payload={'message': '사망자는 투표할 수 없습니다.'}))
                 else: await send_message(player_id, Message(type='error', payload={'message': '지금은 투표 시간이 아닙니다.'}))


            elif message.type == 'night_action': # 밤 능력 사용
                if room.phase == 'night' and current_player.is_alive:
                    target_id = message.payload.get('target_id')
                    action_type = message.payload.get('action_type')

                    valid_target = target_id in room.players and room.players[target_id].is_alive
                    valid_action = False
                    fail_reason = "잘못된 대상 또는 액션입니다."

                    if current_player.role == 'Scanner Droid' and action_type == 'scan':
                        if target_id != player_id: valid_action = True
                        else: fail_reason = "자기 자신을 스캔할 수 없습니다."
                    elif current_player.role == 'Repair Bot' and action_type == 'protect':
                        valid_action = True # 자신 포함 가능
                    elif current_player.role == 'AI Assassin Robot' and not current_player.is_ai and action_type == 'assassinate': # 인간 AI 암살
                        if target_id in room.players and room.players[target_id].role != 'AI Assassin Robot': valid_action = True
                        else: fail_reason = "AI 팀원은 암살할 수 없습니다."

                    if valid_target and valid_action:
                        current_player.night_action_target = target_id
                        room.night_actions_completed[player_id] = True # 행동 완료
                        action_verb = "used ability on"
                        if action_type == 'assassinate': action_verb = "requested elimination of"
                        elif action_type == 'scan': action_verb = "scanned"
                        elif action_type == 'protect': action_verb = "protected"
                        print(f"[Night Action] {current_player.role} {player_name} {action_verb} {room.players[target_id].username}")
                        await send_message(player_id, Message(type='system', payload={'message': f'{room.players[target_id].username}님에게 능력을 사용했습니다.'}))

                        # 밤 행동 결과 저장
                        if action_type == 'scan': room.scan_request_id = target_id
                        elif action_type == 'protect': room.protected_player_id = target_id
                        elif action_type == 'assassinate': room.ai_kill_requests[player_id] = target_id
                    else:
                        if not valid_target: fail_reason = "선택한 대상이 유효하지 않습니다."
                        await send_message(player_id, Message(type='error', payload={'message': fail_reason}))
                # 능력 사용 불가 사유
                elif room.phase != 'night': await send_message(player_id, Message(type='error', payload={'message': '밤이 아닙니다.'}))
                elif not current_player.is_alive: await send_message(player_id, Message(type='error', payload={'message': '사망자는 능력을 사용할 수 없습니다.'}))
                else: await send_message(player_id, Message(type='error', payload={'message': '해당 역할은 이 능력을 사용할 수 없습니다.'}))


    except WebSocketDisconnect:
        print(f"WebSocketDisconnect for player {player_name or 'Unknown'} (ID: {player_id})")
        if player_id: await handle_player_disconnect(room_id, player_id)
    except Exception as e:
        import traceback
        print(f"Error in WebSocket connection for {player_name or 'Unknown'} (ID: {player_id}): {e}")
        traceback.print_exc() # 상세 에러 로그 출력
        if player_id: await handle_player_disconnect(room_id, player_id)
    finally:
        # 연결 종료 시 확실하게 connections 에서 제거
        if player_id and player_id in connections:
             del connections[player_id]
        print(f"Connection closed for {player_name or 'Unknown'} (ID: {player_id})")

# --- 정적 파일 서빙 설정 (선택적, 빌드 후 사용) ---
# from fastapi.staticfiles import StaticFiles
# build_dir = "../client/build"
# static_dir = os.path.join(build_dir, "static")
# index_html = os.path.join(build_dir, "index.html")

# if os.path.exists(build_dir) and os.path.exists(index_html):
#     app.mount("/static", StaticFiles(directory=static_dir), name="static")
#     @app.get("/{full_path:path}", include_in_schema=False)
#     async def serve_react_app(full_path: str):
#         return HTMLResponse(content=open(index_html).read(), status_code=200)
# else:
#     print(f"Warning: Frontend build directory not found at {build_dir}. Serving API only.")
#     @app.get("/", include_in_schema=False)
#     async def root(): return {"message": "AI Mafia Game Backend (Multi-AI) is running."}

# --- 서버 실행 ---
if __name__ == "__main__":
    import uvicorn
    import re # 정규표현식 사용 위해 import 추가
    print("Starting AI Mafia Game Backend Server (Multi-AI Mode)...")
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True, log_level="info")

```

---

**2. 프론트엔드 (React + TypeScript + Zustand + Tailwind CSS)**

*   **`client/package.json`** (주요 의존성 예시 - 버전은 다를 수 있음)

```json
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.101",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "axios": "^1.7.2",
    "phosphor-react": "^1.4.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.52.0",
    "react-scripts": "5.0.1",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4",
    "zustand": "^4.5.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.4"
  }
}
```

*   **`client/tailwind.config.js`**

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'primary': '#00ffff', // Cyan
        'secondary': '#f0f',   // Magenta
        'background': '#1a1a2e', // Dark blue/purple
        'card': '#162447',     // Darker blue
        'text-primary': '#e0e0e0', // Light gray
        'text-secondary': '#a0a0a0', // Gray
        'accent': '#ff7f50',   // Coral
      },
      fontFamily: {
        'sans': ['Inter', 'sans-serif'], // 예시 폰트 (설치 필요 시)
      }
    },
  },
  plugins: [],
}
```

*   **`client/postcss.config.js`**

```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

*   **`client/tsconfig.json`** (Create React App 기본 설정 예시)

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}
```

*   **`client/src/index.css`**

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-background text-text-primary font-sans;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 스크롤바 스타일링 (선택적) */
::-webkit-scrollbar {
  width: 8px;
  height: 8px; /* 가로 스크롤바 높이 */
}
::-webkit-scrollbar-track {
  background: #2a2a3e;
}
::-webkit-scrollbar-thumb {
  background-color: #4a4a6a;
  border-radius: 4px;
  border: 2px solid #2a2a3e;
}
::-webkit-scrollbar-thumb:hover {
   background-color: #6a6a8a;
 }

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
```

*   **`client/src/index.tsx`**

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

*   **`client/src/types/game.ts`**

```typescript
// src/types/game.ts
export interface Player {
  id: string;
  username: string; // Server assigned
  is_alive: boolean;
  is_host: boolean;
}

export interface RoomInfo {
  id: string;
  name: string;
  current_players: number;
  max_players: number;
  status: 'waiting' | 'playing' | 'finished';
  is_private: boolean;
}

export type Role = 'Human' | 'AI Assassin Robot' | 'Scanner Droid' | 'Repair Bot' | null;
export type GamePhase = 'lobby' | 'waiting' | 'night' | 'day' | 'voting' | 'results' | 'finished';

export interface ChatMessage {
  sender: string; // username
  message: string;
  timestamp?: number;
  isSelf?: boolean; // 내가 보낸 메시지인지 클라이언트에서 구분용
}

export interface ScanResult {
    scanned_player_id: string;
    scanned_player_name: string;
    is_ai: boolean; // Is part of the AI team
}

export interface NightActionPayload {
    options: Player[];
    action_type: 'scan' | 'protect' | 'assassinate'; // 암살 액션 추가
}

export interface FinalRoles {
    [username: string]: Role | string; // 서버에서 오는 역할 문자열 받을 수 있게
}

// AI 팀원 정보 추가
export interface RoleInfoPayload {
    role: Role;
    ai_teammates: string[]; // username list
}

export interface GameState {
  // Connection & Room Info
  isConnected: boolean;
  roomId: string | null;
  roomName?: string; // 방 이름 추가 (선택적)
  maxPlayers: number | null;
  // Player Info
  playerId: string | null;
  username: string | null; // 내 이름 (서버 할당)
  role: Role;
  isAlive: boolean;
  isHost: boolean;
  aiTeammates: string[]; // 내 AI 팀원 목록
  // Game Status
  phase: GamePhase;
  dayNumber: number;
  players: Player[];
  // Interaction
  chatMessages: ChatMessage[];
  aiChatMessages: ChatMessage[]; // AI 비밀 채팅 메시지
  errorMessage: string | null;
  systemMessage: string | null; // 시스템 메시지 전용 상태
  // Night Action
  nightAction: {
      required: boolean;
      payload: NightActionPayload | null; // 밤 행동 요청 데이터
      chosenTargetId: string | null; // 사용자가 선택한 밤 행동 대상
  };
  scanResult: ScanResult | null; // 스캐너 드로이드의 스캔 결과
  // Voting
  voteOptions: Player[];
  isVotingPhase: boolean; // 투표 UI 표시 여부 (timer 와 별개)
  votedPlayerId: string | null; // 내가 투표한 대상 ID
  // Timer
  timer: {
      phase: string; // 현재 타이머가 속한 단계 (night, day, voting)
      duration: number; // 전체 시간 (초)
      endTime: number | null; // 타이머 종료 시각 (타임스탬프)
  };
  // Game End
  winner: string | null; // 'Human Team', 'AI Assassin Robot Team'
  finalRoles: FinalRoles | null; // 게임 종료 시 역할 공개
}
```

*   **`client/src/stores/useGameStore.ts`**

```typescript
// src/stores/useGameStore.ts
import create from 'zustand';
import { GameState, Role, Player, ChatMessage, ScanResult, NightActionPayload, FinalRoles, RoleInfoPayload } from '../types/game';

interface GameStoreActions {
  setConnected: (status: boolean) => void;
  setInitialConnection: (roomId: string, playerId: string, username: string, maxPlayers: number) => void;
  setPlayers: (players: Player[]) => void;
  updatePlayerStatus: (playerId: string, isAlive: boolean) => void;
  setRoleInfo: (payload: RoleInfoPayload) => void;
  setIsHost: (isHost: boolean) => void;
  setPhase: (phase: GameState['phase']) => void;
  setDayNumber: (day: number) => void;
  addChatMessage: (message: ChatMessage) => void;
  addAiChatMessage: (message: ChatMessage) => void;
  setErrorMessage: (message: string | null) => void;
  setSystemMessage: (message: string | null) => void;
  requestNightAction: (payload: NightActionPayload) => void;
  clearNightAction: () => void;
  setNightActionTarget: (targetId: string | null) => void;
  setScanResult: (result: ScanResult | null) => void;
  startVoting: (options: Player[]) => void;
  endVoting: () => void;
  setVotedPlayer: (playerId: string | null) => void;
  startTimer: (phase: string, duration: number) => void;
  clearTimer: () => void;
  setGameOver: (winner: string, message: string, roles: FinalRoles) => void;
  resetStore: () => void;
}

const initialState: GameState = {
  isConnected: false,
  roomId: null,
  maxPlayers: null,
  playerId: null,
  username: null,
  role: null,
  isAlive: true,
  isHost: false,
  aiTeammates: [],
  phase: 'lobby',
  dayNumber: 0,
  players: [],
  chatMessages: [],
  aiChatMessages: [],
  errorMessage: null,
  systemMessage: null,
  nightAction: { required: false, payload: null, chosenTargetId: null },
  scanResult: null,
  voteOptions: [],
  isVotingPhase: false,
  votedPlayerId: null,
  timer: { phase: '', duration: 0, endTime: null },
  winner: null,
  finalRoles: null,
};

export const useGameStore = create<GameState & GameStoreActions>((set, get) => ({
  ...initialState,

  setConnected: (status) => set({ isConnected: status }),
  setInitialConnection: (roomId, playerId, username, maxPlayers) => set({
    ...initialState,
    isConnected: true,
    roomId,
    playerId,
    username,
    maxPlayers,
    phase: 'waiting',
  }),
  setPlayers: (players) => set((state) => {
      const me = players.find(p => p.id === state.playerId);
      return {
          players,
          isAlive: me ? me.is_alive : state.isAlive,
          isHost: me ? me.is_host : state.isHost,
      };
  }),
  updatePlayerStatus: (playerId, isAlive) => set((state) => ({
      players: state.players.map(p => p.id === playerId ? { ...p, is_alive: isAlive } : p),
      isAlive: state.playerId === playerId ? isAlive : state.isAlive,
  })),
  setRoleInfo: ({ role, ai_teammates }) => set({ role, aiTeammates: ai_teammates || [] }),
  setIsHost: (isHost) => set({ isHost }),
  setPhase: (phase) => set((state) => {
      const newState: Partial<GameState> = { phase };
      if (phase !== 'night') {
          newState.nightAction = { required: false, payload: null, chosenTargetId: null };
          newState.scanResult = null;
      }
      if (phase !== 'voting') {
          newState.isVotingPhase = false;
          newState.voteOptions = [];
          newState.votedPlayerId = null;
      }
      // 타이머 초기화 조건 수정: 로비/대기/결과/종료 시
      if (['lobby', 'waiting', 'results', 'finished'].includes(phase)) {
           newState.timer = { phase: '', duration: 0, endTime: null };
      }
      newState.systemMessage = null; // 일반 시스템 메시지 클리어
      return newState;
  }),
  setDayNumber: (day) => set({ dayNumber: day }),
  addChatMessage: (message) => set((state) => ({
      chatMessages: [...state.chatMessages, { ...message, timestamp: Date.now(), isSelf: message.sender === state.username }].slice(-100),
  })),
  addAiChatMessage: (message) => set((state) => ({
      aiChatMessages: [...state.aiChatMessages, { ...message, timestamp: Date.now(), isSelf: message.sender === state.username }].slice(-50),
  })),
  setErrorMessage: (message) => set({ errorMessage: message }),
  setSystemMessage: (message) => set({ systemMessage: message }),
  requestNightAction: (payload) => set({ nightAction: { required: true, payload: payload, chosenTargetId: null }, systemMessage: '밤 능력을 사용할 대상을 선택하세요.' }),
  clearNightAction: () => set({ nightAction: { required: false, payload: null, chosenTargetId: null } }),
  setNightActionTarget: (targetId) => set((state) => ({ nightAction: { ...state.nightAction, chosenTargetId: targetId } })),
  setScanResult: (result) => set({ scanResult: result }),
  startVoting: (options) => set({ isVotingPhase: true, voteOptions: options, systemMessage: '투표할 플레이어를 선택하세요.', votedPlayerId: null }),
  endVoting: () => set({ isVotingPhase: false, voteOptions: [], systemMessage: null }),
  setVotedPlayer: (playerId) => set({ votedPlayerId: playerId }),
  startTimer: (phase, duration) => set({ timer: { phase, duration, endTime: Date.now() + duration * 1000 } }),
  clearTimer: () => set({ timer: { phase: '', duration: 0, endTime: null } }),
  setGameOver: (winner, message, roles) => set({
      winner,
      systemMessage: message,
      finalRoles: roles,
      phase: 'finished',
      isVotingPhase: false,
      timer: initialState.timer,
      nightAction: initialState.nightAction,
      aiTeammates: [],
  }),
  resetStore: () => set({ ...initialState }),
}));

```

*   **`client/src/hooks/useWebSocket.ts`**

```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef, useCallback } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { ChatMessage, Player, ScanResult, NightActionPayload, FinalRoles, RoleInfoPayload } from '../types/game';

const WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws';

// Hook 인자에서 username 제거
export const useWebSocket = (roomId: string | null, password?: string | null) => {
  const ws = useRef<WebSocket | null>(null);
  const {
    setConnected, setInitialConnection, setPlayers, setPhase, setDayNumber, setRoleInfo, setIsHost,
    addChatMessage, addAiChatMessage, setErrorMessage, setSystemMessage, requestNightAction, clearNightAction,
    setScanResult, startVoting, endVoting, startTimer, clearTimer, setGameOver,
    updatePlayerStatus, resetStore,
  } = useGameStore.getState();

  const sendMessage = useCallback((message: object) => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message));
    } else {
      console.error("WebSocket is not connected.");
      setErrorMessage("서버에 연결되지 않았습니다.");
    }
  }, [setErrorMessage]);

  useEffect(() => {
    if (!roomId) {
        if (ws.current) { console.log("Closing WebSocket connection due to missing roomId."); ws.current.close(); ws.current = null; setConnected(false); resetStore(); }
        return;
    }
    if (ws.current && ws.current.readyState === WebSocket.OPEN) { console.log("WebSocket already connected."); return; }

    // WebSocket URL 에서 username 제거
    const connectUrl = `${WS_URL}/${roomId}${password ? `?password=${encodeURIComponent(password)}` : ''}`;
    console.log("Attempting to connect to WebSocket:", connectUrl);
    ws.current = new WebSocket(connectUrl);
    let localWs = ws.current;

    localWs.onopen = () => { console.log("WebSocket Connected"); setConnected(true); setErrorMessage(null); };
    localWs.onclose = (event) => {
        console.log("WebSocket Disconnected:", event.reason, event.code);
        if (localWs === ws.current) {
            ws.current = null;
            setConnected(false);
            if (event.code !== 1000 && event.code !== 1005) { setErrorMessage(event.reason || "서버와 연결이 끊어졌습니다."); }
            else if (event.code === 1008){ setErrorMessage(event.reason || "서버 연결 실패 (방 없음, 비밀번호 오류, 인원 초과 등)"); }
            resetStore();
        }
     };
    localWs.onerror = (error) => {
        console.error("WebSocket Error:", error);
        if (localWs === ws.current) {
            ws.current = null;
            setConnected(false);
            setErrorMessage("WebSocket 연결 오류 발생");
            resetStore();
        }
     };

    localWs.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        // console.log("Message from server:", message.type); // 타입만 로깅
        const actions = useGameStore.getState();

        switch (message.type) {
          case 'connected': actions.setInitialConnection(message.payload.room_id, message.payload.player_id, message.payload.username, message.payload.max_players); break;
          case 'player_list': actions.setPlayers(message.payload.players as Player[]); break;
          case 'game_state': actions.setPhase(message.payload.phase); actions.setDayNumber(message.payload.day); break;
          case 'role_info': actions.setRoleInfo(message.payload as RoleInfoPayload); break;
          case 'chat': actions.addChatMessage(message.payload as ChatMessage); break;
          case 'ai_chat': actions.addAiChatMessage(message.payload as ChatMessage); break;
          case 'system': actions.addChatMessage({ sender: 'System', message: message.payload.message }); break;
          case 'night_action_request': actions.requestNightAction(message.payload as NightActionPayload); break;
          case 'scan_result':
             actions.setScanResult(message.payload as ScanResult);
             actions.addChatMessage({ sender: 'System', message: `스캔 결과: ${message.payload.scanned_player_name}님은 ${message.payload.is_ai ? 'AI 팀' : 'Human 팀'}입니다.` });
             break;
          case 'vote_start': actions.startVoting(message.payload.options as Player[]); break;
          case 'vote_end': actions.endVoting(); break;
          case 'timer_start': actions.startTimer(message.payload.phase, message.payload.duration); break;
          case 'game_over': actions.setGameOver(message.payload.winner, message.payload.message, message.payload.roles as FinalRoles); break;
           case 'error': actions.setErrorMessage(message.payload.message); break;
          default: console.warn("Unknown message type from server:", message.type);
        }
      } catch (error) { console.error("Failed to parse message or handle:", error); }
    };

    // Cleanup
    return () => {
      if (localWs) {
        console.log("Closing WebSocket connection on cleanup.");
        localWs.onopen = null; localWs.onmessage = null; localWs.onerror = null; localWs.onclose = null;
        if (localWs.readyState === WebSocket.OPEN || localWs.readyState === WebSocket.CONNECTING) { localWs.close(1000); }
      }
      if (localWs === ws.current) { ws.current = null; }
    };
  }, [roomId, password, setConnected, setInitialConnection, setPlayers, setPhase, setDayNumber, setRoleInfo, addChatMessage, addAiChatMessage, setErrorMessage, setSystemMessage, requestNightAction, setScanResult, startVoting, endVoting, startTimer, setGameOver, resetStore]);

  return { sendMessage };
};
```

*   **`client/src/App.tsx`**

```typescript
import React, { useState, useCallback, useEffect } from 'react';
import Lobby from './components/Lobby';
import Room from './components/Room';
import { useGameStore } from './stores/useGameStore';

function App() {
    const [currentView, setCurrentView] = useState<'lobby' | 'room'>('lobby');
    const [roomId, setRoomId] = useState<string | null>(null);
    const [roomPassword, setRoomPassword] = useState<string | null>(null);
    const resetGameStore = useGameStore(state => state.resetStore);
    const storeRoomId = useGameStore(state => state.roomId);
    const isConnected = useGameStore(state => state.isConnected); // 연결 상태 감시

    const handleJoinRoom = useCallback((joinedRoomId: string, password?: string) => {
        setRoomId(joinedRoomId);
        setRoomPassword(password || null);
        setCurrentView('room');
    }, []);

    const handleLeaveRoom = useCallback(() => {
        resetGameStore();
        setRoomId(null);
        setRoomPassword(null);
        setCurrentView('lobby');
    }, [resetGameStore]);

    useEffect(() => {
        // 스토어의 roomId 가 null 이 되고, 연결도 끊겼을 때 로비로 이동
        if (currentView === 'room' && storeRoomId === null && !isConnected) {
            console.log("Detected room disconnect from store & websocket, returning to lobby.");
            // 에러 메시지가 있다면 잠시 보여주고 이동할 수도 있음
            // setTimeout(handleLeaveRoom, 1500);
            handleLeaveRoom();
        }
    }, [storeRoomId, isConnected, currentView, handleLeaveRoom]);

    return (
        <div className="App bg-background min-h-screen">
            {currentView === 'lobby' ? (
                <Lobby onJoinRoom={handleJoinRoom} />
            ) : roomId ? (
                <Room
                    roomId={roomId}
                    password={roomPassword}
                    onLeaveRoom={handleLeaveRoom}
                />
            ) : (
                 <Lobby onJoinRoom={handleJoinRoom} /> // 비정상 상태 -> 로비
            )}
        </div>
    );
}

export default App;
```

*   **`client/src/components/Lobby.tsx`**

```typescript
// src/components/Lobby.tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useForm } from 'react-hook-form';
import { Lock, PlusCircle, SignIn, Users } from 'phosphor-react';
import { RoomInfo } from '../types/game';
import Modal from './Modal';
import LoadingSpinner from './LoadingSpinner';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

interface CreateRoomFormData {
  name: string;
  max_players: number;
  password?: string;
}

interface LobbyProps {
  onJoinRoom: (roomId: string, password?: string) => void;
}

const Lobby: React.FC<LobbyProps> = ({ onJoinRoom }) => {
  const [rooms, setRooms] = useState<RoomInfo[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showPasswordModal, setShowPasswordModal] = useState(false);
  const [joiningRoom, setJoiningRoom] = useState<RoomInfo | null>(null);
  const [passwordInput, setPasswordInput] = useState('');

  const { register, handleSubmit, reset, formState: { errors } } = useForm<CreateRoomFormData>({
    defaultValues: { max_players: 7 } // 기본값 7명
  });

  const fetchRooms = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await axios.get(`${API_URL}/api/rooms`);
      setRooms(response.data);
    } catch (err: any) {
      console.error("Failed to fetch rooms:", err);
      setError(err.response?.data?.detail || "Failed to load rooms list.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchRooms();
    const intervalId = setInterval(fetchRooms, 5000); // 5초마다 갱신
    return () => clearInterval(intervalId);
  }, []);

  const handleCreateRoomSubmit = async (data: CreateRoomFormData) => {
     setIsLoading(true);
     setError(null);
     try {
       const payload = { ...data, password: data.password || null };
       const response = await axios.post(`${API_URL}/api/rooms`, payload);
       const { room_id } = response.data;
       setShowCreateModal(false);
       reset({ name: '', max_players: 7, password: '' });
       onJoinRoom(room_id, data.password); // 생성 후 바로 입장
     } catch (err: any) {
       console.error("Failed to create room:", err);
       setError(err.response?.data?.detail || "Failed to create room. Name might be taken or server error.");
     } finally { setIsLoading(false); }
  };

  const handleJoinClick = (room: RoomInfo) => {
    setError(null);
    if (room.status !== 'waiting') { setError("Game in progress or finished."); return; }
    if (room.current_players >= room.max_players) { setError("Room is full."); return; }

    if (room.is_private) {
      setJoiningRoom(room);
      setPasswordInput('');
      setShowPasswordModal(true);
    } else {
      onJoinRoom(room.id);
    }
  };

  const handlePasswordSubmit = () => {
    if (joiningRoom) {
      setError(null); // 비밀번호 시도 시 이전 에러 클리어
      onJoinRoom(joiningRoom.id, passwordInput);
      // 비밀번호가 틀리면 useWebSocket 에서 에러 처리 및 스토어 리셋됨
      setShowPasswordModal(false); // 성공 여부와 관계없이 모달은 닫음 (피드백은 Room 컴포넌트에서)
      setPasswordInput('');
      setJoiningRoom(null);
    }
  };

  return (
    <div className="container mx-auto p-4 sm:p-6 max-w-3xl">
      <div className="text-center mb-8">
        <h1 className="text-4xl font-bold text-primary mb-2">AI Assassin Robot</h1>
        <p className="text-lg text-text-secondary">3 AIs hide among humans. Can you survive?</p>
      </div>

      {error && !showPasswordModal && <div className="bg-red-800 text-white p-3 rounded mb-4 text-center animate-pulse">{error}</div>}

      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl text-secondary font-semibold">Available Rooms</h2>
        <button
          onClick={() => { setError(null); reset(); setShowCreateModal(true); }}
          className="bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded inline-flex items-center transition duration-200 disabled:opacity-50"
          disabled={isLoading}
        >
          <PlusCircle size={20} className="mr-2" /> Create New Room
        </button>
      </div>

      {isLoading && rooms.length === 0 && <div className="text-center p-10"><LoadingSpinner message="Loading rooms..."/></div>}
      <div className="space-y-3 max-h-[60vh] overflow-y-auto pr-2 bg-card p-4 rounded-lg shadow-lg border border-gray-700">
        {rooms.length > 0 ? rooms.map((room) => (
          <div key={room.id} className="bg-background p-4 rounded-lg flex flex-col sm:flex-row justify-between items-center shadow-md hover:bg-gray-700 transition duration-150">
             <div className="flex items-center space-x-3 mb-2 sm:mb-0 w-full sm:w-auto">
               {room.is_private && <Lock size={20} className="text-yellow-400 flex-shrink-0" title="Private Room"/>}
               <span className="font-semibold text-lg truncate flex-grow min-w-0" title={room.name}>{room.name}</span>
               <span className={`text-xs font-medium px-2 py-0.5 rounded ${room.status === 'waiting' ? 'bg-green-700' : 'bg-red-700'}`}>{room.status}</span>
            </div>
             <div className="flex items-center space-x-4 w-full sm:w-auto justify-end">
               <span className="text-text-secondary inline-flex items-center" title="Players"> <Users size={18} className="mr-1"/> {room.current_players}/{room.max_players}</span>
               <button
                 onClick={() => handleJoinClick(room)}
                 className={`px-3 py-1 rounded transition duration-200 flex items-center ${
                   room.status !== 'waiting' || room.current_players >= room.max_players
                     ? 'bg-gray-600 cursor-not-allowed text-gray-400'
                     : 'bg-secondary hover:bg-pink-600 text-white'
                 }`}
                 disabled={room.status !== 'waiting' || room.current_players >= room.max_players}
                 title={room.status !== 'waiting' ? 'Game in progress/finished' : room.current_players >= room.max_players ? 'Room full' : 'Join Room'}
               >
                 <SignIn size={18} /> <span className="ml-1 hidden sm:inline">Join</span>
               </button>
             </div>
          </div>
        )) : (
           !isLoading && <p className="text-center text-text-secondary py-10">No rooms. Create one!</p>
        )}
      </div>

      {/* 방 만들기 모달 */}
       <Modal isOpen={showCreateModal} onClose={() => setShowCreateModal(false)} title="Create New Room">
           <form onSubmit={handleSubmit(handleCreateRoomSubmit)} className="space-y-4">
               <div>
                   <label htmlFor="c-name" className="block text-sm font-medium text-text-secondary">Room Name</label>
                   <input id="c-name" {...register("name", { required: "Required", minLength: { value: 2, message: "Min 2 chars"}, maxLength: { value: 20, message: "Max 20 chars"} })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary"/>
                   {errors.name && <p className="text-red-500 text-xs mt-1">{errors.name.message}</p>}
               </div>
               <div>
                   <label htmlFor="c-max_players" className="block text-sm font-medium text-text-secondary">Max Players (incl. 3 AIs, 6-12)</label>
                   <select id="c-max_players" {...register("max_players", { valueAsNumber: true })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary appearance-none">
                       {[6, 7, 8, 9, 10, 11, 12].map(n => <option key={n} value={n}>{n} players</option>)}
                   </select>
               </div>
                <div>
                    <label htmlFor="c-password" className="block text-sm font-medium text-text-secondary">Password (Optional)</label>
                    <input id="c-password" type="password" {...register("password", { minLength: {value: 4, message: "Min 4 chars"}, maxLength: {value: 20, message:"Max 20 chars"} })} className="mt-1 block w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary" placeholder="Leave blank for public"/>
                    {errors.password && <p className="text-red-500 text-xs mt-1">{errors.password.message}</p>}
                </div>
               <button type="submit" className="w-full bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded transition" disabled={isLoading}>
                   {isLoading ? "Creating..." : "Create & Join"}
               </button>
               {/* 모달 내 에러 표시 */}
               {error && showCreateModal && <p className="text-red-500 text-center mt-2 text-sm">{error}</p>}
           </form>
       </Modal>

      {/* 비밀번호 입력 모달 */}
       <Modal isOpen={showPasswordModal} onClose={() => setShowPasswordModal(false)} title={`Enter Password for '${joiningRoom?.name}'`}>
         <div className="space-y-4">
           <p className="text-text-secondary">This room requires a password.</p>
           <input id="room-password" type="password" value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)} className="w-full p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary" placeholder="Password" autoFocus onKeyPress={(e) => e.key === 'Enter' && handlePasswordSubmit()}/>
           {/* 비밀번호 모달 내 에러 표시 */}
            {error && showPasswordModal && <p className="text-red-500 text-center text-sm">{error}</p>}
           <button onClick={handlePasswordSubmit} className="w-full bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded transition">Enter Room</button>
         </div>
       </Modal>
    </div>
  );
};

export default Lobby;
```

*   **`client/src/components/ChatInterface.tsx`**

```typescript
// src/components/ChatInterface.tsx
import React, { useState, useRef, useEffect } from 'react';
import { ChatMessage, Role, GamePhase } from '../types/game'; // GamePhase 임포트
import { PaperPlaneTilt, ChatCircleDots, EyeSlash, Info } from 'phosphor-react';

interface ChatWindowProps {
  messages: ChatMessage[];
  title: string;
}

const ChatWindow: React.FC<ChatWindowProps> = ({ messages, title }) => {
  const chatEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // 스크롤 시 약간의 지연을 주어 부드러운 효과 개선 시도
    const timer = setTimeout(() => {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }, 100);
    return () => clearTimeout(timer);
  }, [messages]);

  return (
    <div className="flex-1 bg-background p-3 sm:p-4 overflow-y-auto mb-1">
       <div className="space-y-3">
            {messages.map((msg, index) => (
                <div key={`${title}-${index}-${msg.timestamp || index}`} className={`flex flex-col ${msg.isSelf ? 'items-end' : 'items-start'} w-full`}>
                    {msg.sender === 'System' ? (
                        <p className="text-center text-xs text-accent italic bg-card/70 px-2 py-1 rounded-full max-w-xs sm:max-w-md mx-auto my-1 flex items-center">
                           <Info size={12} className="mr-1"/> {msg.message}
                        </p>
                    ) : (
                        <div className={`flex flex-col max-w-[85%] ${msg.isSelf ? 'items-end' : 'items-start'}`}>
                             <span className={`text-xs mb-0.5 ${msg.isSelf ? 'text-primary' : 'text-text-secondary'}`}>
                                {msg.sender}
                            </span>
                            <div className={`p-2 rounded-lg shadow break-words ${msg.isSelf ? 'bg-primary/90 text-background' : 'bg-card'}`}>
                                <p className="text-sm leading-snug">{msg.message}</p>
                            </div>
                        </div>
                    )}
                </div>
            ))}
        </div>
      <div ref={chatEndRef} />
    </div>
  );
};


interface ChatInterfaceProps {
  role: Role;
  isAlive: boolean;
  phase: GamePhase; // GamePhase 타입 사용
  publicMessages: ChatMessage[];
  aiMessages: ChatMessage[];
  sendMessage: (message: object) => void;
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
    role, isAlive, phase, publicMessages, aiMessages, sendMessage
}) => {
  const [activeTab, setActiveTab] = useState<'public' | 'ai'>('public');
  const [chatInput, setChatInput] = useState('');
  const [aiChatInput, setAiChatInput] = useState('');
  const isAIPlayer = role === 'AI Assassin Robot';

  // AI 플레이어이고, AI 채널에 새 메시지가 오면 탭을 AI 로 자동 전환 (선택적)
  // useEffect(() => {
  //   if (isAIPlayer && aiMessages.length > 0 && aiMessages[aiMessages.length - 1].sender !== useGameStore.getState().username) {
  //     setActiveTab('ai');
  //   }
  // }, [aiMessages, isAIPlayer]);

  const handleChatSubmit = (e: React.FormEvent, channel: 'public' | 'ai') => {
    e.preventDefault();
    const input = channel === 'public' ? chatInput : aiChatInput;
    const type = channel === 'public' ? 'chat' : 'send_ai_chat';

    // 공개 채팅: 게임 중(낮, 투표, 결과) 살아있을 때 가능
    const canSendPublic = isAlive && ['day', 'voting', 'results'].includes(phase);
    // AI 채팅: AI 역할이고 살아있을 때 항상 가능 (밤에도 논의 가능)
    const canSendAI = isAlive && isAIPlayer;

    if (input.trim() && ((channel === 'public' && canSendPublic) || (channel === 'ai' && canSendAI))) {
      sendMessage({ type, payload: { message: input.trim() } });
      if (channel === 'public') {
        setChatInput('');
      } else {
        setAiChatInput('');
      }
    } else {
        let reason = "";
        if (!isAlive) reason = "Eliminated players cannot chat.";
        else if (channel === 'public' && !canSendPublic) reason = "Cannot send public chat during this phase.";
        else if (channel === 'ai' && !canSendAI) reason = "Only living AI players can use the AI channel.";
        else if (!input.trim()) reason = "Message cannot be empty.";
        console.log("Chat blocked:", reason);
        // 사용자에게 피드백 필요 시 추가 (예: 입력 필드 흔들기)
    }
  };

  return (
    <div className="flex-1 flex flex-col max-h-screen overflow-hidden">
        {/* 탭 버튼 */}
        {isAIPlayer && (
            <div className="flex border-b border-gray-700 bg-card flex-shrink-0">
                <button
                    onClick={() => setActiveTab('public')}
                    className={`flex-1 py-2 px-4 text-sm font-medium flex items-center justify-center transition duration-150 ${
                        activeTab === 'public' ? 'bg-background text-primary border-b-2 border-primary' : 'text-text-secondary hover:bg-gray-700/50'
                    }`}
                >
                   <ChatCircleDots size={16} className="mr-1"/> Public Channel
                </button>
                <button
                    onClick={() => setActiveTab('ai')}
                    className={`flex-1 py-2 px-4 text-sm font-medium flex items-center justify-center transition duration-150 ${
                        activeTab === 'ai' ? 'bg-background text-red-500 border-b-2 border-red-500' : 'text-text-secondary hover:bg-gray-700/50'
                    }`}
                >
                   <EyeSlash size={16} className="mr-1"/> AI Channel (Secret)
                </button>
            </div>
        )}

        {/* 채팅창 표시 */}
        <div className="flex-1 overflow-hidden relative">
            {/* 각 탭 컨텐츠를 절대 위치로 배치하고 activeTab 에 따라 보이게 함 */}
            <div className={`absolute inset-0 transition-opacity duration-200 ${activeTab === 'public' ? 'opacity-100 z-10' : 'opacity-0 z-0 pointer-events-none'}`}>
                 <ChatWindow messages={publicMessages} title="Public Chat" />
            </div>
            {isAIPlayer && (
                 <div className={`absolute inset-0 transition-opacity duration-200 ${activeTab === 'ai' ? 'opacity-100 z-10' : 'opacity-0 z-0 pointer-events-none'}`}>
                    <ChatWindow messages={aiMessages} title="AI Secret Channel" />
                 </div>
            )}
            {/* AI가 아닌 경우 항상 공개 채팅 표시 */}
             {!isAIPlayer && (
                  <div className="absolute inset-0 opacity-100 z-10">
                     <ChatWindow messages={publicMessages} title="Public Chat" />
                  </div>
             )}
        </div>


        {/* 입력 영역 */}
        <div className="bg-card p-3 sm:p-4 border-t border-gray-700 flex-shrink-0">
            {/* 공개 채팅 입력 */}
            {(!isAIPlayer || activeTab === 'public') && (
                <form onSubmit={(e) => handleChatSubmit(e, 'public')} className="flex items-center space-x-2">
                   <input
                       type="text"
                       value={chatInput}
                       onChange={(e) => setChatInput(e.target.value)}
                       placeholder={isAlive && ['day', 'voting', 'results'].includes(phase) ? "Public message..." : "Public chat unavailable"}
                       maxLength={100}
                       className="flex-grow p-2 bg-background border border-gray-600 rounded focus:outline-none focus:border-primary disabled:opacity-50"
                       disabled={!isAlive || !['day', 'voting', 'results'].includes(phase)}
                   />
                   <button
                       type="submit"
                       className="bg-primary hover:bg-cyan-600 text-background p-2 rounded disabled:opacity-50 disabled:cursor-not-allowed transition"
                       disabled={!isAlive || !['day', 'voting', 'results'].includes(phase)}
                       title="Send Public Message"
                   >
                       <PaperPlaneTilt size={20} weight="fill"/>
                   </button>
               </form>
            )}
             {/* AI 비밀 채팅 입력 */}
            {isAIPlayer && activeTab === 'ai' && (
                 <form onSubmit={(e) => handleChatSubmit(e, 'ai')} className="flex items-center space-x-2">
                   <input
                       type="text"
                       value={aiChatInput}
                       onChange={(e) => setAiChatInput(e.target.value)}
                       placeholder={isAlive ? "Secret AI message..." : "Chat unavailable"}
                       maxLength={100}
                       className="flex-grow p-2 bg-background border border-red-700 rounded focus:outline-none focus:border-red-500 disabled:opacity-50"
                       disabled={!isAlive}
                   />
                   <button
                       type="submit"
                       className="bg-red-600 hover:bg-red-700 text-white p-2 rounded disabled:opacity-50 disabled:cursor-not-allowed transition"
                       disabled={!isAlive}
                       title="Send AI Secret Message"
                   >
                       <PaperPlaneTilt size={20} weight="fill"/>
                   </button>
               </form>
            )}
        </div>
    </div>
  );
};

export default ChatInterface;
```

*   **`client/src/components/ActionBar.tsx`**

```typescript
// src/components/ActionBar.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Player, Role, NightActionPayload } from '../types/game';
import { Users, Hourglass, PersonSimpleRun, Play, GameController, Shield, Detective, Skull, Sword } from 'phosphor-react';
import { useGameStore } from '../stores/useGameStore';

interface ActionBarProps {
  phase: GamePhase;
  isAlive: boolean;
  isHost: boolean;
  role: Role;
  sendMessage: (message: object) => void;
  playersInRoom: number; // LLM 포함 전체 플레이어 수
  maxPlayers: number;
  onLeaveRoom: () => void;
  // Voting
  isVotingPhase: boolean;
  voteOptions: Player[];
  votedPlayerId: string | null;
  // Night Action
  nightActionRequired: boolean;
  nightActionPayload: NightActionPayload | null;
  nightActionChosenTargetId: string | null;
  // Game End
  winner: string | null;
}

const ActionBar: React.FC<ActionBarProps> = ({
  phase, isAlive, isHost, role, sendMessage, playersInRoom, maxPlayers, onLeaveRoom,
  isVotingPhase, voteOptions, votedPlayerId,
  nightActionRequired, nightActionPayload, nightActionChosenTargetId,
  winner
}) => {
  const [selectedTargetId, setSelectedTargetId] = useState<string | null>(null);
  const { setNightActionTarget } = useGameStore(); // 스토어 액션 가져오기

   // 선택된 타겟 ID를 스토어에 반영
   useEffect(() => {
       setNightActionTarget(selectedTargetId);
   }, [selectedTargetId, setNightActionTarget]);

  // 단계 변경 시 선택 초기화
  useEffect(() => {
      setSelectedTargetId(null);
  }, [phase]);

  const handleStartGame = () => {
    if (isHost && phase === 'waiting') {
      sendMessage({ type: 'start_game' });
    }
  };

  const handleVote = (targetId: string) => {
    // 살아있고, 투표 단계이고, 아직 투표 안했고, AI 역할이 아닐 때 (AI는 자동투표)
    if (isVotingPhase && isAlive && !votedPlayerId && role !== 'AI Assassin Robot') {
      sendMessage({ type: 'vote', payload: { target_id: targetId } });
      setSelectedTargetId(null); // 투표 후 선택 해제
    }
  };

  const handleNightAction = () => {
     // 살아있고, 밤 액션 필요하고, 타겟 선택했고, 페이로드 있을 때
    if (nightActionRequired && isAlive && selectedTargetId && nightActionPayload) {
        // LLM AI는 이 버튼을 누르지 않음 (서버에서 처리)
        if (role === 'AI Assassin Robot' && useGameStore.getState().username?.startsWith('AI_')) { // LLM AI 구분 (더 나은 방법 필요)
            console.log("LLM AI action is handled by server.");
            return;
        }
        sendMessage({
            type: 'night_action',
            payload: { target_id: selectedTargetId, action_type: nightActionPayload.action_type }
        });
        // 성공 시 선택 해제
        setSelectedTargetId(null);
        // 액션 완료 후 nightActionRequired 를 false 로 바꾸는 것은 서버 응답에 의존
    }
  };

  // 시작 가능 조건 (LLM 포함 전체 인원)
  const canStartGame = playersInRoom === maxPlayers;

  return (
    // 액션바 영역 스타일링 (채팅 인터페이스 아래에 위치)
    <div className="bg-card p-3 sm:p-4 border-t border-gray-700 flex-shrink-0">
      {/* 게임 종료 시 */}
      {winner && (
        <div className="text-center">
          <p className={`text-xl font-bold mb-4 ${winner.includes('Human') ? 'text-green-400' : 'text-red-500'}`}>
             {winner === 'Human Team' ? '🏆 Humans Win!' : '🤖 AI Team Wins!'}
          </p>
          <button
            onClick={onLeaveRoom}
            className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded inline-flex items-center transition"
          >
            <PersonSimpleRun size={20} className="mr-2"/> Return to Lobby
          </button>
        </div>
      )}

      {/* 게임 대기 중 */}
      {phase === 'waiting' && !winner && (
        <div className="flex flex-col sm:flex-row items-center justify-between gap-2">
          <p className="text-text-secondary text-sm sm:text-base flex items-center">
            <Users size={18} className="mr-1"/> Waiting for players... ({playersInRoom}/{maxPlayers})
          </p>
          <button
            onClick={handleStartGame}
            disabled={!isHost || !canStartGame}
            className="bg-primary hover:bg-cyan-600 text-background font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed inline-flex items-center transition w-full sm:w-auto justify-center"
          >
             <Play size={20} className="mr-2"/>
             {isHost ? (canStartGame ? 'Start Game' : `Waiting (${maxPlayers - playersInRoom} more)`) : 'Waiting for Host...'}
          </button>
        </div>
      )}

      {/* 게임 진행 중 (밤) - 능력 사용 */}
       {phase === 'night' && isAlive && !winner && (
         <div className="flex flex-col items-center">
             {nightActionRequired && nightActionPayload ? (
                 <div className="w-full text-center">
                     <p className="text-lg text-accent mb-3 flex items-center justify-center font-semibold">
                         {role === 'Scanner Droid' && <><Detective className="mr-2"/> Select player to scan:</>}
                         {role === 'Repair Bot' && <><Shield className="mr-2"/> Select player to protect:</>}
                         {role === 'AI Assassin Robot' && <><Sword className="mr-2 text-red-500"/> Select target to eliminate:</>}
                     </p>
                     {/* 타겟 선택 버튼 목록 */}
                     <div className="flex flex-wrap justify-center gap-2 mb-3 max-h-24 overflow-y-auto p-1 rounded bg-background/50">
                        {nightActionPayload.options.length > 0 ? nightActionPayload.options.map(player => (
                            <button key={player.id} onClick={() => setSelectedTargetId(player.id)}
                                className={`px-3 py-1 rounded border text-sm transition duration-150 ${
                                    selectedTargetId === player.id
                                        ? 'bg-primary text-background border-primary ring-2 ring-primary'
                                        : 'bg-background hover:bg-gray-700 border-gray-600'
                                }`}
                            > {player.username} </button>
                        )) : <p className="text-sm text-text-secondary italic">No valid targets available.</p>}
                     </div>
                     {/* 확인 버튼 */}
                     <button onClick={handleNightAction} disabled={!selectedTargetId || nightActionPayload.options.length === 0}
                         className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 inline-flex items-center transition">
                          <GameController size={20} className="mr-2"/> Confirm Action
                     </button>
                 </div>
             ) : ( // 능력이 없거나, LLM AI 이거나, 이미 사용한 경우
                 <p className="text-text-secondary flex items-center justify-center italic">
                    {role === 'AI Assassin Robot' && isAlive ? <Hourglass size={18} className="mr-1 animate-spin"/> : ''}
                    {role === 'AI Assassin Robot' ? 'Discussing targets...' : 'Waiting for night to end...'}
                 </p>
             )}
         </div>
       )}

       {/* 게임 진행 중 (투표) */}
       {isVotingPhase && isAlive && !winner && (
           <div className="mt-2">
               <p className="text-lg text-accent mb-3 text-center font-semibold">Voting Phase: Choose who to eliminate!</p>
               <div className="flex flex-wrap justify-center gap-2 mb-3 max-h-32 overflow-y-auto p-1 rounded bg-background/50">
                   {voteOptions.length > 0 ? voteOptions.map(player => (
                       <button
                           key={player.id}
                           onClick={() => handleVote(player.id)}
                           // AI 역할이거나 이미 투표했으면 비활성화
                           disabled={!!votedPlayerId || role === 'AI Assassin Robot'}
                           className={`px-3 py-1 rounded border text-sm transition duration-150 ${
                               votedPlayerId === player.id
                                   ? 'bg-red-700 text-white border-red-500' // 내가 투표한 대상
                                   : votedPlayerId ? 'bg-gray-600 border-gray-700 text-gray-400 cursor-not-allowed' // 투표 완료 시 비활성 스타일
                                   : role === 'AI Assassin Robot' ? 'bg-gray-600 border-gray-700 text-gray-400 cursor-not-allowed' // AI 역할 비활성 스타일
                                   : 'bg-background hover:bg-red-800 border-gray-600 hover:border-red-700' // 기본/호버 스타일
                           }`}
                           title={role === 'AI Assassin Robot' ? "AI votes automatically" : votedPlayerId ? "Already voted" : `Vote for ${player.username}`}
                       >
                           {player.username}
                       </button>
                   )) : <p className="text-sm text-text-secondary italic">No one to vote for.</p>}
               </div>
               {votedPlayerId && <p className="text-center text-green-400 text-sm">You voted for {voteOptions.find(p=>p.id === votedPlayerId)?.username}. Waiting for others...</p>}
               {role === 'AI Assassin Robot' && !votedPlayerId && <p className="text-center text-gray-400 text-sm italic">AI voting is processed automatically...</p>}
           </div>
       )}

       {/* 관전 중 */}
       {!isAlive && phase !== 'finished' && (
           <p className="text-center text-text-secondary italic flex items-center justify-center">
              <Skull size={18} className="mr-1"/> You are eliminated. Spectating the game...
           </p>
       )}

       {/* 낮, 결과 단계에서는 채팅 입력이 ChatInterface 에 있으므로 별도 표시 없음 */}

    </div>
  );
};

export default ActionBar;
```

*   **`client/src/components/PlayerList.tsx`**

```typescript
// src/components/PlayerList.tsx
import React from 'react';
import { Player } from '../types/game';
import { User, Crown, Ghost, Robot } from 'phosphor-react'; // Robot 아이콘은 현재 미사용

interface PlayerListProps {
  players: Player[];
  selfPlayerId: string | null;
}

const PlayerList: React.FC<PlayerListProps> = ({ players, selfPlayerId }) => {
  // 이름순 정렬
  const sortedPlayers = [...players].sort((a, b) => a.username.localeCompare(b.username));

  return (
    <div className="space-y-2 flex-grow overflow-y-auto pr-1">
      {sortedPlayers.map((player) => (
        <div
          key={player.id}
          className={`flex items-center p-2 rounded transition duration-150 shadow-sm ${
            player.id === selfPlayerId ? 'bg-primary/20 border border-primary/50' : 'bg-background/50'
          } ${!player.is_alive ? 'opacity-50' : ''}`}
        >
          {/* 생존/사망 아이콘 */}
          <div className={`mr-2 flex-shrink-0 ${!player.is_alive ? 'text-gray-500' : 'text-secondary'}`}>
            {player.is_alive ? <User size={20} weight="fill" /> : <Ghost size={20} weight="fill" />}
          </div>
          {/* 플레이어 이름 (자신 표시) */}
          <span className={`font-medium flex-grow truncate ${!player.is_alive ? 'line-through text-text-secondary' : ''}`}>
            {player.username} {player.id === selfPlayerId ? <span className="text-xs text-primary ml-1">(You)</span> : ''}
          </span>
          {/* 호스트 아이콘 */}
          {player.is_host && (
            <Crown size={18} weight="fill" className="text-yellow-400 ml-2 flex-shrink-0" title="Host"/>
          )}
        </div>
      ))}
       {/* 플레이어가 없을 때 메시지 (선택적) */}
      {players.length === 0 && (
          <p className="text-center text-text-secondary italic py-4">No players yet.</p>
      )}
    </div>
  );
};

export default PlayerList;
```

*   **`client/src/components/StatusDisplay.tsx`**

```typescript
// src/components/StatusDisplay.tsx
import React, { useState, useEffect } from 'react';
import { GamePhase, Role, ScanResult, FinalRoles } from '../types/game';
import { Sun, Moon, Hourglass, Person, Robot, Detective, Shield, Skull, Question, Trophy, Users, Info } from 'phosphor-react'; // 아이콘 추가

interface StatusDisplayProps {
  phase: GamePhase;
  dayNumber: number;
  role: Role;
  isAlive: boolean;
  timer: { phase: string; duration: number; endTime: number | null };
  winner: string | null;
  gameMessage: string | null;
  scanResult: ScanResult | null;
  finalRoles: FinalRoles | null;
  selfUsername: string | null;
  aiTeammates: string[];
}

const getPhaseIcon = (phase: GamePhase) => {
    switch(phase) {
        case 'day': return <Sun size={20} className="text-yellow-400" />;
        case 'night': return <Moon size={20} className="text-indigo-400" />;
        case 'voting': return <Users size={20} className="text-orange-400" />;
        case 'results': return <Hourglass size={20} className="text-gray-400" />;
        case 'finished': return <Trophy size={20} className="text-yellow-500" />;
        default: return <Hourglass size={20} className="text-gray-400" />; // waiting, lobby 등
    }
};

const getRoleIcon = (role: Role | string | null) => { // string 타입도 받을 수 있게
    switch(role) {
        case 'Human': return <Person size={18} className="text-green-400" />;
        case 'AI Assassin Robot': return <Robot size={18} className="text-red-500" />;
        case 'Scanner Droid': return <Detective size={18} className="text-blue-400" />;
        case 'Repair Bot': return <Shield size={18} className="text-teal-400" />;
        default: return <Question size={18} className="text-gray-400" />;
    }
};

const StatusDisplay: React.FC<StatusDisplayProps> = ({
  phase, dayNumber, role, isAlive, timer, winner, gameMessage, scanResult, finalRoles, selfUsername, aiTeammates
}) => {
  const [timeLeft, setTimeLeft] = useState<number | null>(null);

  useEffect(() => {
    if (timer.endTime && timer.phase === phase && phase !== 'finished') { // 종료 시 타이머 멈춤
      const updateTimer = () => {
        const now = Date.now();
        const remaining = Math.max(0, Math.ceil((timer.endTime! - now) / 1000));
        setTimeLeft(remaining);
        if (remaining === 0) {
           setTimeLeft(null);
        }
      };
      updateTimer();
      const intervalId = setInterval(updateTimer, 1000);
      return () => clearInterval(intervalId);
    } else {
      setTimeLeft(null);
    }
  }, [timer, phase]);


  const renderFinalRoles = () => {
      if (!finalRoles) return null;
      // 이름 순 정렬
      const sortedUsernames = Object.keys(finalRoles).sort();
      return (
          <div className="mt-4 pt-4 border-t border-gray-600">
              <h4 className="text-base font-semibold text-secondary mb-2">Final Roles:</h4>
              <ul className="space-y-1 text-xs max-h-32 overflow-y-auto pr-2">
                  {sortedUsernames.map((username) => (
                      <li key={username} className={`flex items-center ${username === selfUsername ? 'font-bold text-primary' : 'text-text-secondary'}`}>
                          {getRoleIcon(finalRoles[username])}
                          <span className="ml-2">{username}: {finalRoles[username]}</span>
                      </li>
                  ))}
              </ul>
          </div>
      );
  };

  return (
    <div className="text-sm space-y-2">
      {/* 현재 단계 및 시간 */}
      <div className="flex justify-between items-center">
        <span className="flex items-center font-semibold text-base">
           {getPhaseIcon(phase)}
           <span className="ml-2 capitalize">{phase === 'lobby' || phase === 'waiting' ? 'Waiting Area' : `Day ${dayNumber} - ${phase}`}</span>
        </span>
        {timeLeft !== null && timeLeft > 0 && (
           <span className="text-accent font-mono bg-background px-2 py-0.5 rounded text-base">
              {String(Math.floor(timeLeft / 60)).padStart(2, '0')}:{String(timeLeft % 60).padStart(2, '0')}
           </span>
        )}
      </div>

      {/* 내 역할 및 상태 */}
       <div className="flex items-center text-base">
          {isAlive ? getRoleIcon(role) : <Skull size={20} className="text-gray-500" />}
          <span className={`ml-2 font-medium ${!isAlive ? 'line-through text-gray-500' : ''}`}>
             Your Role: {role || 'Assigning...'} {isAlive ? '' : '(Eliminated)'}
          </span>
       </div>

       {/* AI 팀원 표시 */}
       {role === 'AI Assassin Robot' && isAlive && aiTeammates.length > 0 && (
           <div className="text-xs text-red-400 flex items-center bg-red-900/30 p-1 rounded border border-red-800">
              <Users size={16} className="mr-1 flex-shrink-0" />
              <span className="font-medium mr-1">AI Team:</span>
              <span className="truncate">{aiTeammates.join(', ')}</span>
           </div>
       )}

       {/* 스캐너 드로이드 결과 표시 */}
       {role === 'Scanner Droid' && scanResult && isAlive && (
           <div className="bg-blue-900/50 border border-blue-700 p-2 rounded text-xs">
              <span className="font-semibold">Last Scan:</span> {scanResult.scanned_player_name} is
              <span className={`font-bold ml-1 ${scanResult.is_ai ? 'text-red-400' : 'text-green-400'}`}>
                 {scanResult.is_ai ? 'AI Team!' : 'Human Team.'}
              </span>
           </div>
       )}

       {/* 게임 메시지 */}
       {gameMessage && !winner && ( // 게임 오버 메시지는 결과 영역에서 크게 표시하므로 중복 방지
           <p className={`text-center font-semibold py-1 px-2 rounded text-accent italic text-xs bg-card/50`}>
               <Info size={12} className="inline mr-1" /> {gameMessage}
           </p>
       )}

      {/* 게임 종료 시 역할 공개 */}
      {winner && renderFinalRoles()}

    </div>
  );
};

export default StatusDisplay;
```

*   **`client/src/components/Modal.tsx`**

```typescript
// src/components/Modal.tsx
import React from 'react';
import { X } from 'phosphor-react';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
  if (!isOpen) return null;

  return (
    <div
        className="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50 p-4"
        onClick={onClose} // 오버레이 클릭 시 닫기
    >
      <div
          className="bg-card p-6 rounded-lg shadow-xl max-w-md w-full relative animate-fade-in"
          onClick={(e) => e.stopPropagation()} // 모달 내부 클릭 시 이벤트 전파 방지
      >
        <button
          onClick={onClose}
          className="absolute top-3 right-3 text-text-secondary hover:text-primary transition"
          aria-label="Close modal"
        >
          <X size={24} />
        </button>
        <h2 className="text-xl font-semibold text-primary mb-4">{title}</h2>
        <div>{children}</div>
      </div>
      {/* Animation keyframes (in index.css or here) */}
      <style>
          {`
            @keyframes fade-in {
                from { opacity: 0; transform: scale(0.95); }
                to { opacity: 1; transform: scale(1); }
            }
            .animate-fade-in {
                animation: fade-in 0.2s ease-out forwards;
            }
          `}
      </style>
    </div>
  );
};

export default Modal;
```

*   **`client/src/components/LoadingSpinner.tsx`**

```typescript
// src/components/LoadingSpinner.tsx
import React from 'react';
import { CircleNotch } from 'phosphor-react';

interface LoadingSpinnerProps {
  message?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ message = "Loading..." }) => {
  return (
    <div className="flex flex-col items-center justify-center p-4 text-text-secondary">
      <CircleNotch size={32} className="animate-spin text-primary mb-2" />
      <p>{message}</p>
    </div>
  );
};

export default LoadingSpinner;
```

*   **`client/src/components/Room.tsx`**

```typescript
// src/components/Room.tsx
import React, { useState, useEffect } from 'react';
import { useGameStore } from '../stores/useGameStore';
import { useWebSocket } from '../hooks/useWebSocket';
import PlayerList from './PlayerList';
import ChatInterface from './ChatInterface'; // ChatInterface 사용
import ActionBar from './ActionBar';
import StatusDisplay from './StatusDisplay';
import LoadingSpinner from './LoadingSpinner';

interface RoomProps {
  roomId: string;
  password?: string | null;
  onLeaveRoom: () => void;
}

const Room: React.FC<RoomProps> = ({ roomId, password, onLeaveRoom }) => {
  const { sendMessage } = useWebSocket(roomId, password);
  const {
      isConnected, players, phase, dayNumber, role, isAlive, isHost, username,
      chatMessages, aiChatMessages, voteOptions, isVotingPhase, votedPlayerId, timer,
      errorMessage, systemMessage, winner, finalRoles, playerId,
      nightAction, scanResult, maxPlayers, aiTeammates
  } = useGameStore();

  const [isLoadingClient, setIsLoadingClient] = useState(true);

  useEffect(() => {
      // 연결되고, 플레이어 ID 와 이름이 모두 설정되면 로딩 완료
      if (isConnected && playerId && username) {
          setIsLoadingClient(false);
      }
      // 연결 오류 처리
      if (!isConnected && errorMessage && !isLoadingClient) {
          console.error("Room component detected disconnection with error:", errorMessage);
          // 에러 발생 시 로비 이동은 App.tsx 에서 처리
      }
  }, [isConnected, playerId, username, errorMessage, isLoadingClient]);

  // 로딩 중 표시
  if (isLoadingClient && !errorMessage) {
       return (
           <div className="flex justify-center items-center h-screen bg-background">
               <LoadingSpinner message={`Joining room ${roomId}...`} />
           </div>
       );
   }

   // 연결 에러 발생 시
   if (errorMessage && !isConnected) {
       return (
           <div className="flex flex-col justify-center items-center h-screen text-center p-4 bg-background">
               <p className="text-red-500 text-xl mb-4">{errorMessage}</p>
               <button onClick={onLeaveRoom} className="bg-secondary hover:bg-pink-600 text-white font-bold py-2 px-4 rounded transition">
                   Return to Lobby
               </button>
           </div>
       );
   }

   // 정상 렌더링
   if (!playerId || !username) {
        // 플레이어 정보 아직 없을 때 (이론상 로딩에서 걸러짐)
       return <div className="flex justify-center items-center h-screen"><LoadingSpinner message="Initializing player..."/></div>;
   }


  return (
    <div className="flex flex-col md:flex-row h-screen max-h-screen overflow-hidden bg-background text-text-primary">

      {/* Left Panel (Players & Status) */}
       <div className="w-full md:w-[280px] lg:w-[320px] bg-card p-3 sm:p-4 flex flex-col overflow-y-auto border-r border-gray-700 md:max-h-screen flex-shrink-0">
         <h3 className="text-xl font-semibold text-secondary mb-3">Participants</h3>
         <PlayerList players={players} selfPlayerId={playerId} />
         <div className="mt-auto pt-4 border-t border-gray-700">
            <StatusDisplay
               phase={phase}
               dayNumber={dayNumber}
               role={role}
               isAlive={isAlive}
               timer={timer}
               winner={winner}
               gameMessage={systemMessage}
               scanResult={scanResult}
               finalRoles={finalRoles}
               selfUsername={username}
               aiTeammates={aiTeammates}
            />
         </div>
          <button onClick={onLeaveRoom} className="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-2 rounded text-sm transition">Leave Room</button>
       </div>

      {/* Right Panel (Chat & Actions) */}
       <div className="flex-1 flex flex-col max-h-screen overflow-hidden">
           {/* ChatInterface 사용 */}
           <ChatInterface
               role={role}
               isAlive={isAlive}
               phase={phase}
               publicMessages={chatMessages}
               aiMessages={aiChatMessages}
               sendMessage={sendMessage}
           />

           {/* ActionBar */}
           <ActionBar
               phase={phase}
               isAlive={isAlive}
               isHost={isHost}
               role={role}
               sendMessage={sendMessage}
               playersInRoom={players.length}
               maxPlayers={maxPlayers ?? 0}
               onLeaveRoom={onLeaveRoom}
               isVotingPhase={isVotingPhase}
               voteOptions={voteOptions}
               votedPlayerId={votedPlayerId}
               nightActionRequired={nightAction.required}
               nightActionPayload={nightAction.payload}
               nightActionChosenTargetId={nightAction.chosenTargetId}
               winner={winner}
           />
       </div>
    </div>
  );
};

export default Room;
```

---

**3. 환경 설정 및 구동 방법**

이전 설명과 동일합니다.

1.  **사전 요구 사항:** Python 3.8+, Node.js & npm/yarn
2.  **백엔드 설정:** `backend` 폴더에서 가상 환경 설정, `pip install -r requirements.txt`, `.env` 파일에 `GEMINI_API_KEY` 설정.
3.  **프론트엔드 설정:** `client` 폴더에서 `npm install` (또는 `yarn install`), 필요시 `.env` 파일 설정.
4.  **실행:**
    *   백엔드: `uvicorn main:app --host 0.0.0.0 --port 8000 --reload`
    *   프론트엔드: `npm start` (또는 `yarn start`)
5.  **접속:** 브라우저에서 `http://localhost:3000` (또는 프론트엔드 서버 주소)

이제 모든 파일의 전체 코드가 제공되었으며, 다중 AI, 자동 이름 할당, AI 비밀 채팅 기능이 포함되었습니다.